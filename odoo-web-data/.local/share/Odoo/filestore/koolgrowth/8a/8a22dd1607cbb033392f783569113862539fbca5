
/*********************************************************************
*  Filepath: /base/static/tests/test_ir_model_fields_translation.js  *
*  Lines: 48                                                         *
*********************************************************************/
odoo.define('@base/../tests/test_ir_model_fields_translation', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");
function checkLoginColumn(translation) {
    return [
        stepUtils.showAppsMenuItem(), {
            content: "Settings",
            trigger: 'a[data-menu-xmlid="base.menu_administration"]',
            run: 'click',
        }, {
            content: "Open Users & Companies",
            trigger: '[data-menu-xmlid="base.menu_users"]',
            run: "click",
        }, {
            content: "Open Users",
            trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
            run: "click",
        }, {
            content: `Login column should be ${translation}`,
            trigger: `[data-name="login"] span:contains("${translation}")`,
        }
    ]
}

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour', {
    url: '/odoo',
    steps: () => checkLoginColumn('Login')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_en_tour2', {
    url: '/odoo',
    steps: () => checkLoginColumn('Login2')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour', {
    url: '/odoo',
    steps: () => checkLoginColumn('Identifiant')
});

registry.category("web_tour.tours").add('ir_model_fields_translation_fr_tour2', {
    url: '/odoo',
    steps: () => checkLoginColumn('Identifiant2')
});

return __exports;
});
;

/**********************************************************
*  Filepath: /web/static/tests/legacy/helpers/cleanup.js  *
*  Lines: 124                                             *
**********************************************************/
odoo.define('@web/../tests/legacy/helpers/cleanup', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/helpers/cleanup default=false */

// -----------------------------------------------------------------------------
// Cleanup
// -----------------------------------------------------------------------------

const cleanups = [];

/**
 * Register a cleanup callback that will be executed whenever the current test
 * is done.
 *
 * - the cleanups will be executed in reverse order
 * - they will be executed even if the test fails/crashes
 *
 * @param {Function} callback
 */
__exports.registerCleanup = registerCleanup; function registerCleanup(callback) {
    cleanups.push(callback);
}

if (window.QUnit) {
    QUnit.on("OdooAfterTestHook", (info) => {
        if (QUnit.config.debug) {
            return;
        }
        let cleanup;
        // note that this calls the cleanup callbacks in reverse order!
        while ((cleanup = cleanups.pop())) {
            try {
                cleanup(info);
            } catch (error) {
                console.error(error);
            }
        }
    });

    // -----------------------------------------------------------------------------
    // Check leftovers
    // -----------------------------------------------------------------------------

    /**
     * List of elements tolerated in the body after a test. The property "keep"
     * prevents the element from being removed (typically: qunit suite elements).
     */
    const validElements = [
        // always in the body:
        { tagName: "DIV", attr: "id", value: "qunit", keep: true },
        { tagName: "DIV", attr: "id", value: "qunit-fixture", keep: true },
        // shouldn't be in the body after a test but are tolerated:
        { tagName: "SCRIPT", attr: "id", value: "" },
        { tagName: "DIV", attr: "class", value: "o_notification_manager" },
        { tagName: "DIV", attr: "class", value: "tooltip fade bs-tooltip-auto" },
        { tagName: "DIV", attr: "class", value: "tooltip fade bs-tooltip-auto show" },
        { tagName: "DIV", attr: "class", value: "tooltip tooltip-field-info fade bs-tooltip-auto" },
        {
            tagName: "DIV",
            attr: "class",
            value: "tooltip tooltip-field-info fade bs-tooltip-auto show",
        },

        // Due to a Document Kanban bug (already present in 12.0)
        { tagName: "DIV", attr: "class", value: "ui-helper-hidden-accessible" },
        {
            tagName: "UL",
            attr: "class",
            value: "ui-menu ui-widget ui-widget-content ui-autocomplete ui-front",
        },
        {
            tagName: "UL",
            attr: "class",
            value: "ui-menu ui-widget ui-widget-content ui-autocomplete dropdown-menu ui-front", // many2ones
        },
    ];

    /**
     * After each test, we check that there is no leftover in the DOM.
     *
     * Note: this event is not QUnit standard, we added it for this specific use case.
     * As a payload, an object with keys 'moduleName' and 'testName' is provided. It
     * is used to indicate the test that left elements in the DOM, when it happens.
     */
    QUnit.on("OdooAfterTestHook", function (info) {
        if (QUnit.config.debug) {
            return;
        }
        const failed = info.testReport.getStatus() === "failed";
        const toRemove = [];
        // check for leftover elements in the body
        for (const bodyChild of document.body.children) {
            const tolerated = validElements.find(
                (e) => e.tagName === bodyChild.tagName && bodyChild.getAttribute(e.attr) === e.value
            );
            if (!failed && !tolerated) {
                QUnit.pushFailure(
                    `Body still contains undesirable elements:\n${bodyChild.outerHTML}`
                );
            }
            if (!tolerated || !tolerated.keep) {
                toRemove.push(bodyChild);
            }
        }
        // cleanup leftovers in #qunit-fixture
        const qunitFixture = document.getElementById("qunit-fixture");
        if (qunitFixture.children.length) {
            toRemove.push(...qunitFixture.children);
        }
        // remove unwanted elements if not in debug
        for (const el of toRemove) {
            el.remove();
        }
        document.body.classList.remove("modal-open");
    });
}

return __exports;
});

odoo.define(`@web/../tests/helpers/cleanup`, ['@web/../tests/legacy/helpers/cleanup'], function (require) {
                        return require('@web/../tests/legacy/helpers/cleanup');
                        });
;

/********************************************************
*  Filepath: /web/static/tests/legacy/helpers/utils.js  *
*  Lines: 1147                                          *
********************************************************/
odoo.define('@web/../tests/legacy/helpers/utils', ['@web/core/templates', '@web/core/browser/browser', '@web/core/browser/feature_detection', '@web/core/network/download', '@web/core/popover/popover', '@web/core/utils/concurrency', '@web/core/utils/patch', '@web/core/utils/ui', '@web/core/l10n/translation', '@web/../tests/legacy/helpers/cleanup', '@web/env', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/helpers/utils default=false */

const { getTemplate } = require("@web/core/templates");
const { browser } = require("@web/core/browser/browser");
const { isMacOS } = require("@web/core/browser/feature_detection");
const { download } = require("@web/core/network/download");
const { getPopoverForTarget } = require("@web/core/popover/popover");
const { Deferred } = require("@web/core/utils/concurrency");
const { patch } = require("@web/core/utils/patch");
const { isVisible } = require("@web/core/utils/ui");
const { appTranslateFn } = require("@web/core/l10n/translation");const _t = (str, ...args) => appTranslateFn(str, "web", ...args);
const { registerCleanup } = require("@web/../tests/legacy/helpers/cleanup");
const { customDirectives, globalValues } = require("@web/env");

const {
    App,
    onError,
    onMounted,
    onPatched,
    onRendered,
    onWillDestroy,
    onWillPatch,
    onWillRender,
    onWillStart,
    onWillUnmount,
    onWillUpdateProps,
    useComponent,
} = require("@odoo/owl");

/**
 * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType
 *
 * @typedef {Side | `${Side}-${Side}` | { x?: number, y?: number }} Position
 *
 * @typedef {"bottom" | "left" | "right" | "top"} Side
 *
 * @typedef TriggerEventOptions
 * @property {boolean} [skipVisibilityCheck=false]
 * @property {boolean} [sync=false]
 */

/**
 * Patch the native Date object
 *
 * Note that it will be automatically unpatched at the end of the test
 *
 * @param {number} [year]
 * @param {number} [month]
 * @param {number} [day]
 * @param {number} [hours]
 * @param {number} [minutes]
 * @param {number} [seconds]
 * @param {number} [ms=0]
 */
__exports.patchDate = patchDate; function patchDate(year, month, day, hours, minutes, seconds, ms = 0) {
    var RealDate = window.Date;
    var actualDate = new RealDate();

    // By default, RealDate uses the browser offset, so we must replace it with the offset fixed in luxon.
    var fakeDate = new RealDate(year, month, day, hours, minutes, seconds, ms);
    if (!(luxon.Settings.defaultZone instanceof luxon.FixedOffsetZone)) {
        throw new Error("luxon.Settings.defaultZone must be a FixedOffsetZone");
    }
    const browserOffset = -fakeDate.getTimezoneOffset();
    const patchedOffset = luxon.Settings.defaultZone.offset();
    const offsetDiff = patchedOffset - browserOffset;
    const correctedMinutes = fakeDate.getMinutes() - offsetDiff;
    fakeDate.setMinutes(correctedMinutes);

    var timeInterval = actualDate.getTime() - fakeDate.getTime();

    // eslint-disable-next-line no-global-assign
    window.Date = (function (NativeDate) {
        function Date(Y, M, D, h, m, s, ms) {
            var length = arguments.length;
            let date;
            if (arguments.length > 0) {
                date =
                    length == 1 && String(Y) === Y // isString(Y)
                        ? // We explicitly pass it through parse:
                          new NativeDate(Date.parse(Y))
                        : // We have to manually make calls depending on argument
                        // length here
                        length >= 7
                        ? new NativeDate(Y, M, D, h, m, s, ms)
                        : length >= 6
                        ? new NativeDate(Y, M, D, h, m, s)
                        : length >= 5
                        ? new NativeDate(Y, M, D, h, m)
                        : length >= 4
                        ? new NativeDate(Y, M, D, h)
                        : length >= 3
                        ? new NativeDate(Y, M, D)
                        : length >= 2
                        ? new NativeDate(Y, M)
                        : length >= 1
                        ? new NativeDate(Y)
                        : new NativeDate();
                // Prevent mixups with unfixed Date object
                date.constructor = Date;
                return date;
            } else {
                date = new NativeDate();
                var time = date.getTime();
                time -= timeInterval;
                date.setTime(time);
                return date;
            }
        }

        // Copy any custom methods a 3rd party library may have added
        for (var key in NativeDate) {
            Date[key] = NativeDate[key];
        }

        // Copy "native" methods explicitly; they may be non-enumerable
        // exception: 'now' uses fake date as reference
        Date.now = function () {
            var date = new NativeDate();
            var time = date.getTime();
            time -= timeInterval;
            return time;
        };
        Date.UTC = NativeDate.UTC;
        Date.prototype = NativeDate.prototype;
        Date.prototype.constructor = Date;

        // Upgrade Date.parse to handle simplified ISO 8601 strings
        Date.parse = NativeDate.parse;
        return Date;
    })(Date);

    registerCleanup(() => {
        window.Date = RealDate;
    });
}

/**
 * Applies a fixed time zone to luxon based on an offset to the UTC time zone.
 *
 * @param {number} offset the number of minutes ahead or behind the UTC time zone
 *                          +120 => UTC+2
 *                          -120 => UTC-2
 */
__exports.patchTimeZone = patchTimeZone; function patchTimeZone(offset) {
    patchWithCleanup(luxon.Settings, { defaultZone: luxon.FixedOffsetZone.instance(offset) });
}

/**
 *
 * @param {Object} obj object to patch
 * @param {Object} patchValue the actual patch description
 */
__exports.patchWithCleanup = patchWithCleanup; function patchWithCleanup(obj, patchValue) {
    const unpatch = patch(obj, patchValue);
    registerCleanup(() => {
        unpatch();
    });
}

/**
 * @returns {Element}
 */
__exports.getFixture = getFixture; function getFixture() {
    if (!window.QUnit) {
        return document;
    }
    if (QUnit.config.debug) {
        return document.body;
    } else {
        return document.getElementById("qunit-fixture");
    }
}

__exports.nextTick = nextTick; async function nextTick() {
    await new Promise((resolve) => window.requestAnimationFrame(resolve));
    await new Promise((resolve) => setTimeout(resolve));
}

__exports.makeDeferred = makeDeferred; function makeDeferred() {
    return new Deferred();
}

__exports.findElement = findElement; function findElement(el, selector) {
    let target = el;
    if (selector) {
        const els = el.querySelectorAll(selector);
        if (els.length === 0) {
            throw new Error(`No element found (selector: ${selector})`);
        }
        if (els.length > 1) {
            throw new Error(`Found ${els.length} elements, instead of 1 (selector: ${selector})`);
        }
        target = els[0];
    }
    return target;
}

//-----------------------------------------------------------------------------
// Event init attributes mappers
//-----------------------------------------------------------------------------

/** @param {EventInit} [args] */
const mapBubblingEvent = (args) => ({ ...args, bubbles: true });

/** @param {EventInit} [args] */
const mapNonBubblingEvent = (args) => ({ ...args, bubbles: false });

/** @param {EventInit} [args={}] */
const mapBubblingPointerEvent = (args = {}) => ({
    clientX: args.pageX,
    clientY: args.pageY,
    ...args,
    bubbles: true,
    cancelable: true,
    view: window,
});

/** @param {EventInit} [args] */
const mapNonBubblingPointerEvent = (args) => ({
    ...mapBubblingPointerEvent(args),
    bubbles: false,
    cancelable: false,
});

/** @param {EventInit} [args={}] */
const mapCancelableTouchEvent = (args = {}) => ({
    ...args,
    bubbles: true,
    cancelable: true,
    composed: true,
    rotation: 0.0,
    touches: args.touches ? [...args.touches.map((e) => new Touch(e))] : undefined,
    view: window,
    zoom: 1.0,
});

/** @param {EventInit} [args] */
const mapNonCancelableTouchEvent = (args) => ({
    ...mapCancelableTouchEvent(args),
    cancelable: false,
});

/** @param {EventInit} [args] */
const mapKeyboardEvent = (args) => ({
    ...args,
    bubbles: true,
    cancelable: true,
});

/**
 * @template {typeof Event} T
 * @param {EventType} eventType
 * @returns {[T, (attrs: EventInit) => EventInit]}
 */
const getEventConstructor = (eventType) => {
    switch (eventType) {
        // Mouse events
        case "auxclick":
        case "click":
        case "contextmenu":
        case "dblclick":
        case "mousedown":
        case "mouseup":
        case "mousemove":
        case "mouseover":
        case "mouseout": {
            return [MouseEvent, mapBubblingPointerEvent];
        }
        case "mouseenter":
        case "mouseleave": {
            return [MouseEvent, mapNonBubblingPointerEvent];
        }
        // Pointer events
        case "pointerdown":
        case "pointerup":
        case "pointermove":
        case "pointerover":
        case "pointerout": {
            return [PointerEvent, mapBubblingPointerEvent];
        }
        case "pointerenter":
        case "pointerleave": {
            return [PointerEvent, mapNonBubblingPointerEvent];
        }
        // Focus events
        case "focusin": {
            return [FocusEvent, mapBubblingEvent];
        }
        case "focus":
        case "blur": {
            return [FocusEvent, mapNonBubblingEvent];
        }
        // Clipboard events
        case "cut":
        case "copy":
        case "paste": {
            return [ClipboardEvent, mapBubblingEvent];
        }
        // Keyboard events
        case "keydown":
        case "keypress":
        case "keyup": {
            return [KeyboardEvent, mapKeyboardEvent];
        }
        // Drag events
        case "drag":
        case "dragend":
        case "dragenter":
        case "dragstart":
        case "dragleave":
        case "dragover":
        case "drop": {
            return [DragEvent, mapBubblingEvent];
        }
        // Input events
        case "input": {
            return [InputEvent, mapBubblingEvent];
        }
        // Composition events
        case "compositionstart":
        case "compositionend": {
            return [CompositionEvent, mapBubblingEvent];
        }
        // UI events
        case "scroll": {
            return [UIEvent, mapNonBubblingEvent];
        }
        // Touch events
        case "touchstart":
        case "touchend":
        case "touchmove": {
            return [TouchEvent, mapCancelableTouchEvent];
        }
        case "touchcancel": {
            return [TouchEvent, mapNonCancelableTouchEvent];
        }
        // Default: base Event constructor
        default: {
            return [Event, mapBubblingEvent];
        }
    }
};

/**
 * @template {EventType} T
 * @param {Element} el
 * @param {string | null | undefined | false} selector
 * @param {T} eventType
 * @param {EventInit} [eventInit]
 * @param {TriggerEventOptions} [options={}]
 * @returns {GlobalEventHandlersEventMap[T] | Promise<GlobalEventHandlersEventMap[T]>}
 */
__exports.triggerEvent = triggerEvent; function triggerEvent(el, selector, eventType, eventInit, options = {}) {
    const errors = [];
    const target = findElement(el, selector);

    // Error handling
    if (typeof eventType !== "string") {
        errors.push("event type must be a string");
    }
    if (!target) {
        errors.push("cannot find target");
    } else if (!options.skipVisibilityCheck && !isVisible(target)) {
        errors.push("target is not visible");
    }
    if (errors.length) {
        throw new Error(
            `Cannot trigger event${eventType ? ` "${eventType}"` : ""}${
                selector ? ` (with selector "${selector}")` : ""
            }: ${errors.join(" and ")}`
        );
    }

    // Actual dispatch
    const [Constructor, processParams] = getEventConstructor(eventType);
    const event = new Constructor(eventType, processParams(eventInit));
    target.dispatchEvent(event);

    if (window.QUnit && QUnit.config.debug) {
        const group = `%c[${event.type.toUpperCase()}]`;
        console.groupCollapsed(group, "color: #b52c9b");
        console.log(target, event);
        console.groupEnd(group, "color: #b52c9b");
    }

    if (options.sync) {
        return event;
    } else {
        return nextTick().then(() => event);
    }
}

/**
 * @param {Element} el
 * @param {string | null | undefined | false} selector
 * @param {(EventType | [EventType, EventInit])[]} [eventDefs]
 * @param {TriggerEventOptions} [options={}]
 */
__exports.triggerEvents = triggerEvents; function triggerEvents(el, selector, eventDefs, options = {}) {
    const events = [...eventDefs].map((eventDef) => {
        const [eventType, eventInit] = Array.isArray(eventDef) ? eventDef : [eventDef, {}];
        return triggerEvent(el, selector, eventType, eventInit, options);
    });
    if (options.sync) {
        return events;
    } else {
        return nextTick().then(() => events);
    }
}

/**
 * Triggers a scroll event on the given target
 *
 * If the target cannot be scrolled or an axis has reached
 * the end of the scrollable area, the event can be transmitted
 * to its nearest parent until it can be triggered
 *
 * @param {Element} target target of the scroll event
 * @param {Object} coordinates
 * @param {number} coordinates.left coordinates to scroll horizontally
 * @param {number} coordinates.top coordinates to scroll vertically
 * @param {boolean} canPropagate states if the scroll can propagate to a scrollable parent
 */
__exports.triggerScroll = triggerScroll; async function triggerScroll(
    target,
    coordinates = { left: null, top: null },
    canPropagate = true
) {
    const isScrollable =
        (target.scrollHeight > target.clientHeight && target.clientHeight > 0) ||
        (target.scrollWidth > target.clientWidth && target.clientWidth > 0);
    if (!isScrollable && !canPropagate) {
        return;
    }
    if (isScrollable) {
        const canScrollFrom = {
            left:
                coordinates.left > target.scrollLeft
                    ? target.scrollLeft + target.clientWidth < target.scrollWidth
                    : target.scrollLeft > 0,
            top:
                coordinates.top > target.scrollTop
                    ? target.scrollTop + target.clientHeight < target.scrollHeight
                    : target.scrollTop > 0,
        };
        const scrollCoordinates = {};
        Object.entries(coordinates).forEach(([key, value]) => {
            if (value !== null && canScrollFrom[key]) {
                scrollCoordinates[key] = value;
                delete coordinates[key];
            }
        });
        target.scrollTo(scrollCoordinates);
        await triggerEvent(target, null, "scroll");
        if (!canPropagate || !Object.entries(coordinates).length) {
            return;
        }
    }
    target.parentElement
        ? triggerScroll(target.parentElement, coordinates)
        : triggerEvent(window, null, "scroll");
    await nextTick();
}

__exports.click = click; function click(
    el,
    selector,
    { mouseEventInit = {}, skipDisabledCheck = false, skipVisibilityCheck = false } = {}
) {
    if (!skipDisabledCheck && el.disabled) {
        throw new Error("Can't click on a disabled button");
    }
    return triggerEvents(
        el,
        selector,
        [
            "pointerdown",
            "mousedown",
            "focus",
            "focusin",
            "pointerup",
            "mouseup",
            ["click", mouseEventInit],
        ],
        { skipVisibilityCheck }
    );
}

__exports.clickCreate = clickCreate; function clickCreate(htmlElement) {
    if (
        htmlElement.querySelectorAll(
            ".o_control_panel_main_buttons .o_form_button_create"
        ).length
    ) {
        return click(
            htmlElement,
            ".o_control_panel_main_buttons .o_form_button_create"
        );
    } else if (
        htmlElement.querySelectorAll(
            ".o_control_panel_main_buttons .o_list_button_create"
        ).length
    ) {
        return click(
            htmlElement,
            ".o_control_panel_main_buttons .o_list_button_create"
        );
    } else {
        throw new Error("No edit button found to be clicked.");
    }
}

__exports.clickEdit = clickEdit; function clickEdit(htmlElement) {
    if (htmlElement.querySelectorAll(".o_list_button_edit").length) {
        return click(htmlElement, ".o_list_button_edit");
    } else {
        throw new Error("No edit button found to be clicked.");
    }
}

__exports.clickSave = clickSave; async function clickSave(htmlElement) {
    if (htmlElement.querySelectorAll(".o_form_status_indicator").length) {
        await mouseEnter(htmlElement, ".o_form_status_indicator");
    }
    if (htmlElement.querySelectorAll(".o_form_button_save").length) {
        return click(htmlElement, ".o_form_button_save");
    }
    const listSaveButtons = htmlElement.querySelectorAll(".o_list_button_save");
    if (listSaveButtons.length) {
        return listSaveButtons.length >= 2 ? click(listSaveButtons[1]) : click(listSaveButtons[0]);
    } else {
        throw new Error("No save button found to be clicked.");
    }
}

__exports.clickDiscard = clickDiscard; async function clickDiscard(htmlElement) {
    if (htmlElement.querySelectorAll(".o_form_status_indicator").length) {
        await mouseEnter(htmlElement, ".o_form_status_indicator");
    }
    if (htmlElement.querySelectorAll(".o_form_button_cancel").length) {
        return click(htmlElement, ".o_form_button_cancel");
    } else if ($(htmlElement).find(".o_list_button_discard:visible").length) {
        return click($(htmlElement).find(".o_list_button_discard:visible").get(0));
    } else {
        throw new Error("No discard button found to be clicked.");
    }
}

/**
 * Trigger pointerenter and mouseenter events on the given target. If no
 * coordinates are given, the event is located by default
 * in the middle of the target to simplify the test process
 *
 * @param {Element} el
 * @param {string} selector
 * @param {Object} coordinates position of the mouseenter event
 */
__exports.mouseEnter = mouseEnter; async function mouseEnter(el, selector, coordinates) {
    const target = el.querySelector(selector) || el;
    const atPos = coordinates || {
        clientX: target.getBoundingClientRect().left + target.getBoundingClientRect().width / 2,
        clientY: target.getBoundingClientRect().top + target.getBoundingClientRect().height / 2,
    };
    return triggerEvents(target, null, ["pointerenter", "mouseenter"], atPos);
}

/**
 * Trigger pointerleave and mouseleave events on the given target.
 *
 * @param {Element} el
 * @param {string} selector
 */
__exports.mouseLeave = mouseLeave; async function mouseLeave(el, selector) {
    const target = el.querySelector(selector) || el;
    return triggerEvents(target, null, ["pointerleave", "mouseleave"]);
}

__exports.editInput = editInput; async function editInput(el, selector, value) {
    const input = findElement(el, selector);
    if (!(input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) {
        throw new Error("Only 'input' and 'textarea' elements can be edited with 'editInput'.");
    }
    if (
        !["text", "textarea", "email", "search", "color", "number", "file", "tel"].includes(
            input.type
        )
    ) {
        throw new Error(`Type "${input.type}" not supported by 'editInput'.`);
    }

    const eventOpts = {};
    if (input.type === "file") {
        const files = Array.isArray(value) ? value : [value];
        const dataTransfer = new DataTransfer();
        for (const file of files) {
            if (!(file instanceof File)) {
                throw new Error(`File input value should be one or several File objects.`);
            }
            dataTransfer.items.add(file);
        }
        input.files = dataTransfer.files;
        eventOpts.skipVisibilityCheck = true;
    } else {
        input.value = value;
    }

    await triggerEvents(input, null, ["input", "change"], eventOpts);

    if (input.type === "file") {
        // Need to wait for the file to be loaded by the input
        await nextTick();
        await nextTick();
    }
}

__exports.editSelect = editSelect; function editSelect(el, selector, value) {
    const select = findElement(el, selector);
    if (select.tagName !== "SELECT") {
        throw new Error("Only select tag can be edited with selectInput.");
    }
    select.value = value;
    return triggerEvent(select, null, "change");
}

__exports.editSelectMenu = editSelectMenu; async function editSelectMenu(el, selector, value) {
    const dropdown = el.querySelector(selector);
    await click(dropdown.querySelector(".dropdown-toggle"));
    for (const item of Array.from(el.querySelectorAll(".o_select_menu_menu .dropdown-item"))) {
        if (item.textContent === value) {
            return click(item);
        }
    }
}

/**
 * Triggers an hotkey properly disregarding the operating system.
 *
 * @param {string} hotkey
 * @param {boolean} addOverlayModParts
 * @param {KeyboardEventInit} eventAttrs
 */
__exports.triggerHotkey = triggerHotkey; async function triggerHotkey(hotkey, addOverlayModParts = false, eventAttrs = {}) {
    eventAttrs.key = hotkey.split("+").pop();

    if (/shift/i.test(hotkey)) {
        eventAttrs.shiftKey = true;
    }

    if (/control/i.test(hotkey)) {
        if (isMacOS()) {
            eventAttrs.metaKey = true;
        } else {
            eventAttrs.ctrlKey = true;
        }
    }

    if (/alt/i.test(hotkey) || addOverlayModParts) {
        if (isMacOS()) {
            eventAttrs.ctrlKey = true;
        } else {
            eventAttrs.altKey = true;
        }
    }

    if (!("bubbles" in eventAttrs)) {
        eventAttrs.bubbles = true;
    }

    const [keydownEvent, keyupEvent] = await triggerEvents(
        document.activeElement,
        null,
        [
            ["keydown", eventAttrs],
            ["keyup", eventAttrs],
        ],
        { skipVisibilityCheck: true }
    );

    return { keydownEvent, keyupEvent };
}

__exports.mockDownload = mockDownload; function mockDownload(cb) {
    patchWithCleanup(download, { _download: cb });
}

const hushConsole = __exports.hushConsole = Object.create(null);
for (const propName of Object.keys(window.console)) {
    hushConsole[propName] = () => {};
}

__exports.mockSendBeacon = mockSendBeacon; function mockSendBeacon(mock) {
    patchWithCleanup(navigator, {
        sendBeacon: (url, blob) => {
            return mock(url, blob) !== false;
        },
    });
}

__exports.mockTimeout = mockTimeout; function mockTimeout() {
    const timeouts = new Map();
    let currentTime = 0;
    let id = 1;
    patchWithCleanup(browser, {
        setTimeout(fn, delay = 0) {
            timeouts.set(id, { fn, scheduledFor: delay + currentTime, id });
            return id++;
        },
        clearTimeout(id) {
            timeouts.delete(id);
        },
    });
    return {
        execRegisteredTimeouts() {
            for (const { fn } of timeouts.values()) {
                fn();
            }
            timeouts.clear();
        },
        async advanceTime(duration) {
            // wait here so all microtasktick scheduled in this frame can be
            // executed and possibly register their own timeout
            await nextTick();
            currentTime += duration;
            for (const { fn, scheduledFor, id } of timeouts.values()) {
                if (scheduledFor <= currentTime) {
                    fn();
                    timeouts.delete(id);
                }
            }
            // wait here to make sure owl can update the UI
            await nextTick();
        },
    };
}

__exports.mockAnimationFrame = mockAnimationFrame; function mockAnimationFrame() {
    const callbacks = new Map();
    let currentTime = 0;
    let id = 1;
    patchWithCleanup(browser, {
        requestAnimationFrame(fn) {
            callbacks.set(id, { fn, scheduledFor: 16 + currentTime, id });
            return id++;
        },
        cancelAnimationFrame(id) {
            callbacks.delete(id);
        },
        performance: { now: () => currentTime },
    });
    return {
        execRegisteredAnimationFrames() {
            for (const { fn } of callbacks.values()) {
                fn(currentTime);
            }
            callbacks.clear();
        },
        async advanceFrame(count = 1) {
            // wait here so all microtasktick scheduled in this frame can be
            // executed and possibly register their own timeout
            await nextTick();
            currentTime += 16 * count;
            for (const { fn, scheduledFor, id } of callbacks.values()) {
                if (scheduledFor <= currentTime) {
                    fn(currentTime);
                    callbacks.delete(id);
                }
            }
            // wait here to make sure owl can update the UI
            await nextTick();
        },
    };
}

__exports.mount = mount; async function mount(Comp, target, config = {}) {
    let { props, env } = config;
    env = env || {};
    const configuration = {
        env,
        getTemplate,
        test: true,
        props,
        customDirectives,
        globalValues,
    };
    if (env.services && "localization" in env.services) {
        configuration.translateFn = _t;
    }
    const app = new App(Comp, configuration);
    registerCleanup(() => app.destroy());
    return app.mount(target);
}

__exports.destroy = destroy; function destroy(comp) {
    comp.__owl__.app.destroy();
}

__exports.findChildren = findChildren; function findChildren(comp, predicate = (e) => e) {
    const queue = [];
    [].unshift.apply(queue, Object.values(comp.__owl__.children));

    while (queue.length > 0) {
        const curNode = queue.pop();
        if (predicate(curNode)) {
            return curNode;
        }
        [].unshift.apply(queue, Object.values(curNode.component.__owl__.children));
    }
}

// partial replacement of t-ref on component
__exports.useChild = useChild; function useChild() {
    const node = useComponent().__owl__;
    const setChild = () => {
        const componentNode = Object.values(node.children)[0];
        node.component.child = componentNode.component;
    };
    onMounted(setChild);
    onPatched(setChild);
}

__exports.useLogLifeCycle = useLogLifeCycle; function useLogLifeCycle(logFn, name = "") {
    const component = useComponent();
    let loggedName = `${component.constructor.name}`;
    if (name) {
        loggedName = `${component.constructor.name} ${name}`;
    }
    onError(() => {
        logFn(`onError ${loggedName}`);
    });
    onMounted(() => {
        logFn(`onMounted ${loggedName}`);
    });
    onPatched(() => {
        logFn(`onPatched ${loggedName}`);
    });
    onRendered(() => {
        logFn(`onRendered ${loggedName}`);
    });
    onWillDestroy(() => {
        logFn(`onWillDestroy ${loggedName}`);
    });
    onWillPatch(() => {
        logFn(`onWillPatch ${loggedName}`);
    });
    onWillRender(() => {
        logFn(`onWillRender ${loggedName}`);
    });
    onWillStart(() => {
        logFn(`onWillStart ${loggedName}`);
    });
    onWillUnmount(() => {
        logFn(`onWillUnmount ${loggedName}`);
    });
    onWillUpdateProps(() => {
        logFn(`onWillUpdateProps ${loggedName}`);
    });
}

/**
 * Returns the list of nodes containing n2 (included) that do not contain n1.
 *
 * @param {Node} n1
 * @param {Node} n2
 * @returns {Node[]}
 */
function getDifferentParents(n1, n2) {
    const parents = [n2];
    while (parents[0].parentNode) {
        const parent = parents[0].parentNode;
        if (parent.contains(n1)) {
            break;
        }
        parents.unshift(parent);
    }
    return parents;
}

/**
 * Helper performing a drag and drop sequence.
 *
 * - 'from' is used to determine the element on which the drag will start;
 * - 'target' will determine the element on which the first one will be dropped.
 *
 * The first element will be dragged by its center, and will be dropped on the
 * bottom-right inner pixel of the target element. This behavior covers both
 * cases of appending the first element to the end of a list (toSelector =
 * target list) or moving it at the position of another element, effectively
 * placing the first element before the second (toSelector = other element).
 *
 * A position can be given to drop the first element above, below, or on the
 * side of the second (default is inside, as specified above).
 *
 * Note that only the last event is awaited, since all the others are
 * considered to be synchronous.
 *
 * @param {Element | string} from
 * @param {Element | string} to
 * @param {Position} [position]
 */
__exports.dragAndDrop = dragAndDrop; async function dragAndDrop(from, to, position) {
    const { drop } = await drag(from);
    await drop(to, position);
}

/**
 * Helper performing a drag.
 *
 * - the 'from' selector is used to determine the element on which the drag will
 *  start;
 * - the 'target' selector will determine the element on which the dragged element will be
 * moved.
 *
 * Returns a drop function
 *
 * @param {Element | string} from
 */
__exports.drag = drag; async function drag(from, pointerType = "mouse") {
    const assertIsDragging = (fn, endDrag) => {
        return {
            async [fn.name](...args) {
                if (dragEndReason) {
                    throw new Error(
                        `Cannot execute drag helper '${fn.name}': drag sequence has been ended by '${dragEndReason}'.`
                    );
                }
                await fn(...args);
                if (endDrag) {
                    dragEndReason = fn.name;
                }
            },
        }[fn.name];
    };

    const cancel = assertIsDragging(async function cancel() {
        await triggerEvent(window, null, "keydown", { key: "Escape" });
    }, true);

    /**
     * @param {Element | string} [to]
     * @param {Position} [position]
     */
    const drop = assertIsDragging(async function drop(to, position) {
        if (to) {
            await moveTo(to, position);
        }
        await triggerEvent(target || source, null, "pointerup", targetPosition);
    }, true);

    /**
     * @param {Element | string} selector
     */
    const getEl = (selector) =>
        selector instanceof Element ? selector : fixture.querySelector(selector);

    /**
     * @param {Position} [position]
     */
    const getTargetPosition = (position) => {
        const tRect = target.getBoundingClientRect();
        const tPos = {
            clientX: Math.floor(tRect.x),
            clientY: Math.floor(tRect.y),
        };
        if (position && typeof position === "object") {
            // x and y coordinates start from the element's initial coordinates
            tPos.clientX += position.x || 0;
            tPos.clientY += position.y || 0;
        } else {
            const positions = typeof position === "string" ? position.split("-") : [];

            // X position
            if (positions.includes("left")) {
                tPos.clientX -= 1;
            } else if (positions.includes("right")) {
                tPos.clientX += Math.ceil(tRect.width) + 1;
            } else {
                tPos.clientX += Math.floor(tRect.width / 2);
            }

            // Y position
            if (positions.includes("top")) {
                tPos.clientY -= 1;
            } else if (positions.includes("bottom")) {
                tPos.clientY += Math.ceil(tRect.height) + 1;
            } else {
                tPos.clientY += Math.floor(tRect.height / 2);
            }
        }
        return tPos;
    };

    /**
     * @param {Element | string} [to]
     * @param {Position} [position]
     */
    const moveTo = assertIsDragging(async function moveTo(to, position) {
        target = getEl(to);
        if (!target) {
            return;
        }

        // Recompute target position
        targetPosition = getTargetPosition(position);

        // Move, enter and drop the element on the target
        await triggerEvent(source, null, "pointermove", { ...targetPosition, button: -1 });

        // "pointerenter" is fired on every parent of `target` that do not contain
        // `from` (typically: different parent lists).
        for (const parent of getDifferentParents(source, target)) {
            triggerEvent(parent, null, "pointerenter", targetPosition);
        }
        await nextTick();

        return dragHelpers;
    }, false);

    const dragHelpers = { cancel, drop, moveTo };
    const fixture = getFixture();

    const source = getEl(from instanceof Element ? from : fixture.querySelector(from));
    const sourceRect = source.getBoundingClientRect();

    let dragEndReason = null;
    let target;
    let targetPosition;

    // Pointer down on main target
    await triggerEvent(source, null, "pointerdown", {
        pointerType,
        clientX: sourceRect.x + sourceRect.width / 2,
        clientY: sourceRect.y + sourceRect.height / 2,
    });

    return dragHelpers;
}

/**
 * Returns the dropdown menu for a specific toggler.
 *
 * @param {HTMLElement} target
 * @param {String|HTMLElement} togglerSelector
 * @returns {HTMLElement|undefined}
 */
__exports.getDropdownMenu = getDropdownMenu; function getDropdownMenu(target, togglerSelector) {
    if (!(target instanceof HTMLElement)) {
        throw new Error(`getDropdownMenu: target is not an HTMLElement.`);
    }
    let el =
        togglerSelector instanceof HTMLElement
            ? togglerSelector
            : target.querySelector(togglerSelector);

    if (el && !el.classList.contains("o-dropdown")) {
        el = el.querySelector(".o-dropdown");
    }
    if (!el) {
        throw new Error(`getDropdownMenu: Could not find element "${togglerSelector}".`);
    }
    return getPopoverForTarget(el);
}

__exports.clickDropdown = clickDropdown; async function clickDropdown(target, fieldName) {
    const dropdownInput = target.querySelector(`[name='${fieldName}'] .dropdown input`);
    dropdownInput.focus();
    await nextTick();
    await click(dropdownInput);
}

__exports.clickOpenedDropdownItem = clickOpenedDropdownItem; async function clickOpenedDropdownItem(target, fieldName, itemContent) {
    const dropdowns = target.querySelectorAll(`[name='${fieldName}'] .dropdown .dropdown-menu`);
    if (dropdowns.length === 0) {
        throw new Error(`No dropdown found for field ${fieldName}`);
    } else if (dropdowns.length > 1) {
        throw new Error(`Found ${dropdowns.length} dropdowns for field ${fieldName}`);
    }
    const dropdownItems = dropdowns[0].querySelectorAll("li");
    const indexToClick = Array.from(dropdownItems)
        .map((html) => html.textContent)
        .indexOf(itemContent);
    if (indexToClick === -1) {
        throw new Error(`The element '${itemContent}' does not exist in the dropdown`);
    }
    await click(dropdownItems[indexToClick]);
}

__exports.selectDropdownItem = selectDropdownItem; async function selectDropdownItem(target, fieldName, itemContent) {
    await clickDropdown(target, fieldName);
    await clickOpenedDropdownItem(target, fieldName, itemContent);
}

__exports.getNodesTextContent = getNodesTextContent; function getNodesTextContent(nodes) {
    return Array.from(nodes).map((n) => n.textContent);
}

/**
 * Click to open the dropdown on a many2one
 */
__exports.clickOpenM2ODropdown = clickOpenM2ODropdown; async function clickOpenM2ODropdown(el, fieldName, selector) {
    const m2oSelector = `${selector || ""} .o_field_many2one[name=${fieldName}] input`;
    const matches = el.querySelectorAll(m2oSelector);
    if (matches.length !== 1) {
        throw new Error(
            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`
        );
    }

    await click(matches[0]);
    return matches[0];
}

/**
 * Click on the active (highlighted) selection in a m2o dropdown.
 */
// TO FIX
__exports.clickM2OHighlightedItem = clickM2OHighlightedItem; async function clickM2OHighlightedItem(el, fieldName, selector) {
    const m2oSelector = `${selector || ""} .o_field_many2one[name=${fieldName}] input`;
    // const $dropdown = $(m2oSelector).autocomplete('widget');
    const matches = el.querySelectorAll(m2oSelector);
    if (matches.length !== 1) {
        throw new Error(
            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`
        );
    }
    // clicking on an li (no matter which one), will select the focussed one
    return click(matches[0].parentElement.querySelector("li"));
}

// X2Many
__exports.addRow = addRow; async function addRow(target, selector) {
    await click(target.querySelector(`${selector ? selector : ""} .o_field_x2many_list_row_add a`));
}

__exports.removeRow = removeRow; async function removeRow(target, index) {
    await click(target.querySelectorAll(".o_list_record_remove")[index]);
}

return __exports;
});

odoo.define(`@web/../tests/helpers/utils`, ['@web/../tests/legacy/helpers/utils'], function (require) {
                        return require('@web/../tests/legacy/helpers/utils');
                        });
;

/************************************************
*  Filepath: /web/static/tests/legacy/utils.js  *
*  Lines: 695                                   *
************************************************/
odoo.define('@web/../tests/legacy/utils', ['@web/core/utils/ui', '@web/../tests/helpers/cleanup', '@web/../tests/helpers/utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@web/../tests/utils default=false */

const { isVisible } = require("@web/core/utils/ui");
const { registerCleanup } = require("@web/../tests/helpers/cleanup");
const {
    click: webClick,
    getFixture,
    makeDeferred,
    triggerEvents: webTriggerEvents,
} = require("@web/../tests/helpers/utils");

/**
 * Create a fake object 'dataTransfer', linked to some files,
 * which is passed to drag and drop events.
 *
 * @param {Object[]} files
 * @returns {Object}
 */
function createFakeDataTransfer(files) {
    return {
        dropEffect: "all",
        effectAllowed: "all",
        files,
        items: [],
        types: ["Files"],
    };
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then clicks on it.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options] forwarded to `contains`
 * @param {boolean} [options.shiftKey]
 */
__exports.click = click; async function click(selector, options = {}) {
    const { shiftKey } = options;
    delete options.shiftKey;
    await contains(selector, { click: { shiftKey }, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then dragenters `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dragenterFiles = dragenterFiles; async function dragenterFiles(selector, files, options) {
    await contains(selector, { dragenterFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then dragovers `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dragoverFiles = dragoverFiles; async function dragoverFiles(selector, files, options) {
    await contains(selector, { dragoverFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then drops `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.dropFiles = dropFiles; async function dropFiles(selector, files, options) {
    await contains(selector, { dropFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then inputs `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.inputFiles = inputFiles; async function inputFiles(selector, files, options) {
    await contains(selector, { inputFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then pastes `files` on it.
 *
 * @param {string} selector
 * @param {Object[]} files
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.pasteFiles = pasteFiles; async function pasteFiles(selector, files, options) {
    await contains(selector, { pasteFiles: files, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then focuses on it.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.focus = focus; async function focus(selector, options) {
    await contains(selector, { setFocus: true, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then inserts the given `content`.
 *
 * @param {string} selector
 * @param {string} content
 * @param {ContainsOptions} [options] forwarded to `contains`
 * @param {boolean} [options.replace=false]
 */
__exports.insertText = insertText; async function insertText(selector, content, options = {}) {
    const { replace = false } = options;
    delete options.replace;
    await contains(selector, { ...options, insertText: { content, replace } });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then sets its `scrollTop` to the given value.
 *
 * @param {string} selector
 * @param {number|"bottom"} scrollTop
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.scroll = scroll; async function scroll(selector, scrollTop, options) {
    await contains(selector, { setScroll: scrollTop, ...options });
}

/**
 * Waits until exactly one element matching the given `selector` is present in
 * `options.target` and then triggers `event` on it.
 *
 * @param {string} selector
 * @param {(import("@web/../tests/helpers/utils").EventType|[import("@web/../tests/helpers/utils").EventType, EventInit])[]} events
 * @param {ContainsOptions} [options] forwarded to `contains`
 */
__exports.triggerEvents = triggerEvents; async function triggerEvents(selector, events, options) {
    await contains(selector, { triggerEvents: events, ...options });
}

function log(ok, message) {
    if (window.QUnit) {
        QUnit.assert.ok(ok, message);
    } else {
        if (ok) {
            console.log(message);
        } else {
            console.error(message);
        }
    }
}

let hasUsedContainsPositively = false;
if (window.QUnit) {
    QUnit.testStart(() => (hasUsedContainsPositively = false));
}
/**
 * @typedef {[string, ContainsOptions]} ContainsTuple tuple representing params of the contains
 *  function, where the first element is the selector, and the second element is the options param.
 * @typedef {Object} ContainsOptions
 * @property {ContainsTuple} [after] if provided, the found element(s) must be after the element
 *  matched by this param.
 * @property {ContainsTuple} [before] if provided, the found element(s) must be before the element
 *  matched by this param.
 * @property {Object} [click] if provided, clicks on the first found element
 * @property {ContainsTuple|ContainsTuple[]} [contains] if provided, the found element(s) must
 *  contain the provided sub-elements.
 * @property {number} [count=1] numbers of elements to be found to declare the contains check
 *  as successful. Elements are counted after applying all other filters.
 * @property {Object[]} [dragenterFiles] if provided, dragenters the given files on the found element
 * @property {Object[]} [dragoverFiles] if provided, dragovers the given files on the found element
 * @property {Object[]} [dropFiles] if provided, drops the given files on the found element
 * @property {Object[]} [inputFiles] if provided, inputs the given files on the found element
 * @property {{content:string, replace:boolean}} [insertText] if provided, adds to (or replace) the
 *  value of the first found element by the given content.
 * @property {ContainsTuple} [parent] if provided, the found element(s) must have as
 *  parent the node matching the parent parameter.
 * @property {Object[]} [pasteFiles] if provided, pastes the given files on the found element
 * @property {number|"bottom"} [scroll] if provided, the scrollTop of the found element(s)
 *  must match.
 *  Note: when using one of the scrollTop options, it is advised to ensure the height is not going
 *  to change soon, by checking with a preceding contains that all the expected elements are in DOM.
 * @property {boolean} [setFocus] if provided, focuses the first found element.
 * @property {boolean} [shadowRoot] if provided, targets the shadowRoot of the found elements.
 * @property {number|"bottom"} [setScroll] if provided, sets the scrollTop on the first found
 *  element.
 * @property {HTMLElement} [target=getFixture()]
 * @property {string[]} [triggerEvents] if provided, triggers the given events on the found element
 * @property {string} [text] if provided, the textContent of the found element(s) or one of their
 *  descendants must match. Use `textContent` option for a match on the found element(s) only.
 * @property {string} [textContent] if provided, the textContent of the found element(s) must match.
 *  Prefer `text` option for a match on the found element(s) or any of their descendants, usually
 *  allowing for a simpler and less specific selector.
 * @property {string} [value] if provided, the input value of the found element(s) must match.
 *  Note: value changes are not observed directly, another mutation must happen to catch them.
 * @property {boolean} [visible] if provided, the found element(s) must be (in)visible
 */
class Contains {
    /**
     * @param {string} selector
     * @param {ContainsOptions} [options={}]
     */
    constructor(selector, options = {}) {
        this.selector = selector;
        this.options = options;
        this.options.count ??= 1;
        this.options.targetParam = this.options.target;
        this.options.target ??= getFixture();
        let selectorMessage = `${this.options.count} of "${this.selector}"`;
        if (this.options.visible !== undefined) {
            selectorMessage = `${selectorMessage} ${
                this.options.visible ? "visible" : "invisible"
            }`;
        }
        if (this.options.targetParam) {
            selectorMessage = `${selectorMessage} inside a specific target`;
        }
        if (this.options.parent) {
            selectorMessage = `${selectorMessage} inside a specific parent`;
        }
        if (this.options.contains) {
            selectorMessage = `${selectorMessage} with a specified sub-contains`;
        }
        if (this.options.text !== undefined) {
            selectorMessage = `${selectorMessage} with text "${this.options.text}"`;
        }
        if (this.options.textContent !== undefined) {
            selectorMessage = `${selectorMessage} with textContent "${this.options.textContent}"`;
        }
        if (this.options.value !== undefined) {
            selectorMessage = `${selectorMessage} with value "${this.options.value}"`;
        }
        if (this.options.scroll !== undefined) {
            selectorMessage = `${selectorMessage} with scroll "${this.options.scroll}"`;
        }
        if (this.options.after !== undefined) {
            selectorMessage = `${selectorMessage} after a specified element`;
        }
        if (this.options.before !== undefined) {
            selectorMessage = `${selectorMessage} before a specified element`;
        }
        this.selectorMessage = selectorMessage;
        if (this.options.contains && !Array.isArray(this.options.contains[0])) {
            this.options.contains = [this.options.contains];
        }
        if (this.options.count) {
            hasUsedContainsPositively = true;
        } else if (!hasUsedContainsPositively) {
            throw new Error(
                `Starting a test with "contains" of count 0 for selector "${this.selector}" is useless because it might immediately resolve. Start the test by checking that an expected element actually exists.`
            );
        }
        /** @type {string} */
        this.successMessage = undefined;
        /** @type {function} */
        this.executeError = undefined;
    }

    /**
     * Starts this contains check, either immediately resolving if there is a
     * match, or registering appropriate listeners and waiting until there is a
     * match or a timeout (resolving or rejecting respectively).
     *
     * Success or failure messages will be logged with QUnit as well.
     *
     * @returns {Promise}
     */
    run() {
        this.done = false;
        this.def = makeDeferred();
        this.scrollListeners = new Set();
        this.onScroll = () => this.runOnce("after scroll");
        if (!this.runOnce("immediately")) {
            this.timer = setTimeout(
                () => this.runOnce("Timeout of 5 seconds", { crashOnFail: true }),
                5000
            );
            this.observer = new MutationObserver((mutations) => {
                try {
                    this.runOnce("after mutations");
                } catch (e) {
                    this.def.reject(e); // prevents infinite loop in case of programming error
                }
            });
            this.observer.observe(this.options.target, {
                attributes: true,
                childList: true,
                subtree: true,
            });
            registerCleanup(() => {
                if (!this.done) {
                    this.runOnce("Test ended", { crashOnFail: true });
                }
            });
        }
        return this.def;
    }

    /**
     * Runs this contains check once, immediately returning the result (or
     * undefined), and possibly resolving or rejecting the main promise
     * (and printing QUnit log) depending on options.
     * If undefined is returned it means the check was not successful.
     *
     * @param {string} whenMessage
     * @param {Object} [options={}]
     * @param {boolean} [options.crashOnFail=false]
     * @param {boolean} [options.executeOnSuccess=true]
     * @returns {HTMLElement[]|undefined}
     */
    runOnce(whenMessage, { crashOnFail = false, executeOnSuccess = true } = {}) {
        const res = this.select();
        if (res?.length === this.options.count || crashOnFail) {
            // clean before doing anything else to avoid infinite loop due to side effects
            this.observer?.disconnect();
            clearTimeout(this.timer);
            for (const el of this.scrollListeners ?? []) {
                el.removeEventListener("scroll", this.onScroll);
            }
            this.done = true;
        }
        if (res?.length === this.options.count) {
            this.successMessage = `Found ${this.selectorMessage} (${whenMessage})`;
            if (executeOnSuccess) {
                this.executeAction(res[0]);
            }
            return res;
        } else {
            this.executeError = () => {
                let message = `Failed to find ${this.selectorMessage} (${whenMessage}).`;
                message = res
                    ? `${message} Found ${res.length} instead.`
                    : `${message} Parent not found.`;
                if (this.parentContains) {
                    if (this.parentContains.successMessage) {
                        log(true, this.parentContains.successMessage);
                    } else {
                        this.parentContains.executeError();
                    }
                }
                log(false, message);
                this.def?.reject(new Error(message));
                for (const childContains of this.childrenContains || []) {
                    if (childContains.successMessage) {
                        log(true, childContains.successMessage);
                    } else {
                        childContains.executeError();
                    }
                }
            };
            if (crashOnFail) {
                this.executeError();
            }
        }
    }

    /**
     * Executes the action(s) given to this constructor on the found element,
     * prints the success messages, and resolves the main deferred.

     * @param {HTMLElement} el
     */
    executeAction(el) {
        let message = this.successMessage;
        if (this.options.click) {
            message = `${message} and clicked it`;
            webClick(el, undefined, {
                mouseEventInit: this.options.click,
                skipDisabledCheck: true,
                skipVisibilityCheck: true,
            });
        }
        if (this.options.dragenterFiles) {
            message = `${message} and dragentered ${this.options.dragenterFiles.length} file(s)`;
            const ev = new Event("dragenter", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dragenterFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.dragoverFiles) {
            message = `${message} and dragovered ${this.options.dragoverFiles.length} file(s)`;
            const ev = new Event("dragover", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dragoverFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.dropFiles) {
            message = `${message} and dropped ${this.options.dropFiles.length} file(s)`;
            const ev = new Event("drop", { bubbles: true });
            Object.defineProperty(ev, "dataTransfer", {
                value: createFakeDataTransfer(this.options.dropFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.inputFiles) {
            message = `${message} and inputted ${this.options.inputFiles.length} file(s)`;
            // could not use _createFakeDataTransfer as el.files assignation will only
            // work with a real FileList object.
            const dataTransfer = new window.DataTransfer();
            for (const file of this.options.inputFiles) {
                dataTransfer.items.add(file);
            }
            el.files = dataTransfer.files;
            /**
             * Changing files programatically is not supposed to trigger the event but
             * it does in Chrome versions before 73 (which is on runbot), so in that
             * case there is no need to make a manual dispatch, because it would lead to
             * the files being added twice.
             */
            const versionRaw = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
            const chromeVersion = versionRaw ? parseInt(versionRaw[2], 10) : false;
            if (!chromeVersion || chromeVersion >= 73) {
                el.dispatchEvent(new Event("change"));
            }
        }
        if (this.options.insertText !== undefined) {
            message = `${message} and inserted text "${this.options.insertText.content}" (replace: ${this.options.insertText.replace})`;
            el.focus();
            if (this.options.insertText.replace) {
                el.value = "";
                el.dispatchEvent(new window.KeyboardEvent("keydown", { key: "Backspace" }));
                el.dispatchEvent(new window.KeyboardEvent("keyup", { key: "Backspace" }));
                el.dispatchEvent(new window.InputEvent("input"));
            }
            for (const char of this.options.insertText.content) {
                el.value += char;
                el.dispatchEvent(new window.KeyboardEvent("keydown", { key: char }));
                el.dispatchEvent(new window.KeyboardEvent("keyup", { key: char }));
                el.dispatchEvent(new window.InputEvent("input"));
            }
            el.dispatchEvent(new window.InputEvent("change"));
        }
        if (this.options.pasteFiles) {
            message = `${message} and pasted ${this.options.pasteFiles.length} file(s)`;
            const ev = new Event("paste", { bubbles: true });
            Object.defineProperty(ev, "clipboardData", {
                value: createFakeDataTransfer(this.options.pasteFiles),
            });
            el.dispatchEvent(ev);
        }
        if (this.options.setFocus) {
            message = `${message} and focused it`;
            el.focus();
        }
        if (this.options.setScroll !== undefined) {
            message = `${message} and set scroll to "${this.options.setScroll}"`;
            el.scrollTop =
                this.options.setScroll === "bottom" ? el.scrollHeight : this.options.setScroll;
        }
        if (this.options.triggerEvents) {
            message = `${message} and triggered "${this.options.triggerEvents.join(", ")}" events`;
            webTriggerEvents(el, null, this.options.triggerEvents, {
                skipVisibilityCheck: true,
            });
        }
        if (this.parentContains) {
            log(true, this.parentContains.successMessage);
        }
        log(true, message);
        for (const childContains of this.childrenContains) {
            log(true, childContains.successMessage);
        }
        this.def?.resolve();
    }

    /**
     * Returns the found element(s) according to this constructor setup.
     * If undefined is returned it means the parent cannot be found
     *
     * @returns {HTMLElement[]|undefined}
     */
    select() {
        const target = this.selectParent();
        if (!target) {
            return;
        }
        const baseRes = [...target.querySelectorAll(this.selector)]
            .map((el) => (this.options.shadowRoot ? el.shadowRoot : el))
            .filter((el) => el);
        /** @type {Contains[]} */
        this.childrenContains = [];
        const res = baseRes.filter((el, currentIndex) => {
            let condition =
                (this.options.textContent === undefined ||
                    el.textContent.trim() === this.options.textContent) &&
                (this.options.value === undefined || el.value === this.options.value) &&
                (this.options.scroll === undefined ||
                    (this.options.scroll === "bottom"
                        ? Math.abs(el.scrollHeight - el.clientHeight - el.scrollTop) <= 1
                        : Math.abs(el.scrollTop - this.options.scroll) <= 1));
            if (condition && this.options.text !== undefined) {
                if (
                    el.textContent.trim() !== this.options.text &&
                    [...el.querySelectorAll("*")].every(
                        (el) => el.textContent.trim() !== this.options.text
                    )
                ) {
                    condition = false;
                }
            }
            if (condition && this.options.contains) {
                for (const param of this.options.contains) {
                    const childContains = new Contains(param[0], { ...param[1], target: el });
                    if (
                        !childContains.runOnce(`as child of el ${currentIndex + 1})`, {
                            executeOnSuccess: false,
                        })
                    ) {
                        condition = false;
                    }
                    this.childrenContains.push(childContains);
                }
            }
            if (condition && this.options.visible !== undefined) {
                if (isVisible(el) !== this.options.visible) {
                    condition = false;
                }
            }
            if (condition && this.options.after) {
                const afterContains = new Contains(this.options.after[0], {
                    ...this.options.after[1],
                    target,
                });
                const afterEl = afterContains.runOnce(`as "after"`, {
                    executeOnSuccess: false,
                })?.[0];
                if (
                    !afterEl ||
                    !(el.compareDocumentPosition(afterEl) & Node.DOCUMENT_POSITION_PRECEDING)
                ) {
                    condition = false;
                }
                this.childrenContains.push(afterContains);
            }
            if (condition && this.options.before) {
                const beforeContains = new Contains(this.options.before[0], {
                    ...this.options.before[1],
                    target,
                });
                const beforeEl = beforeContains.runOnce(`as "before"`, {
                    executeOnSuccess: false,
                })?.[0];
                if (
                    !beforeEl ||
                    !(el.compareDocumentPosition(beforeEl) & Node.DOCUMENT_POSITION_FOLLOWING)
                ) {
                    condition = false;
                }
                this.childrenContains.push(beforeContains);
            }
            return condition;
        });
        if (
            this.options.scroll !== undefined &&
            this.scrollListeners &&
            baseRes.length === this.options.count &&
            res.length !== this.options.count
        ) {
            for (const el of baseRes) {
                if (!this.scrollListeners.has(el)) {
                    this.scrollListeners.add(el);
                    el.addEventListener("scroll", this.onScroll);
                }
            }
        }
        return res;
    }

    /**
     * Returns the found element that should act as the target (parent) for the
     * main selector.
     * If undefined is returned it means the parent cannot be found.
     *
     * @returns {HTMLElement|undefined}
     */
    selectParent() {
        if (this.options.parent) {
            this.parentContains = new Contains(this.options.parent[0], {
                ...this.options.parent[1],
                target: this.options.target,
            });
            return this.parentContains.runOnce(`as parent`, { executeOnSuccess: false })?.[0];
        }
        return this.options.target;
    }
}

/**
 * Waits until `count` elements matching the given `selector` are present in
 * `options.target`.
 *
 * @param {string} selector
 * @param {ContainsOptions} [options]
 * @returns {Promise}
 */
__exports.contains = contains; async function contains(selector, options) {
    await new Contains(selector, options).run();
}

const stepState = {
    expectedSteps: null,
    deferred: null,
    timeout: null,
    currentSteps: [],

    clear() {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.deferred = null;
        this.currentSteps = [];
        this.expectedSteps = null;
    },

    check({ crashOnFail = false } = {}) {
        const success =
            this.expectedSteps.length === this.currentSteps.length &&
            this.expectedSteps.every((s, i) => s === this.currentSteps[i]);
        if (!success && !crashOnFail) {
            return;
        }
        QUnit.config.current.assert.verifySteps(this.expectedSteps);
        if (success) {
            this.deferred.resolve();
        } else {
            this.deferred.reject(new Error("Steps do not match."));
        }
        this.clear();
    },
};

if (window.QUnit) {
    QUnit.testStart(() =>
        registerCleanup(() => {
            if (stepState.expectedSteps) {
                stepState.check({ crashOnFail: true });
            } else {
                stepState.clear();
            }
        })
    );
}

/**
 * Indicate the completion of a test step. This step must then be verified by
 * calling `assertSteps`.
 *
 * @param {string} step
 */
__exports.step = step; function step(step) {
    stepState.currentSteps.push(step);
    QUnit.config.current.assert.step(step);
    if (stepState.expectedSteps) {
        stepState.check();
    }
}

/**
 * Wait for the given steps to be executed or for the timeout to be reached.
 *
 * @param {string[]} steps
 */
__exports.assertSteps = assertSteps; function assertSteps(steps) {
    if (stepState.expectedSteps) {
        stepState.check({ crashOnFail: true });
    }
    stepState.expectedSteps = steps;
    stepState.deferred = makeDeferred();
    stepState.timeout = setTimeout(() => stepState.check({ crashOnFail: true }), 2000);
    stepState.check();
    return stepState.deferred;
}

return __exports;
});

odoo.define(`@web/../tests/utils`, ['@web/../tests/legacy/utils'], function (require) {
                        return require('@web/../tests/legacy/utils');
                        });
;

/******************************************************************
*  Filepath: /web/static/tests/tours/favorite_management_tour.js  *
*  Lines: 129                                                     *
******************************************************************/
odoo.define('@web/../tests/tours/favorite_management_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("test_favorite_management", {
    url: "/odoo/apps",
    steps: () => [
        {
            trigger:
                ".o_kanban_renderer:not(:has(.o_kanban_record:contains(France - Localizations)))",
        },
        {
            trigger: ".o_facet_remove",
            run: "click",
        },
        {
            trigger: ".o_kanban_renderer:has(.o_kanban_record:contains(France - Localizations))",
        },
        {
            trigger: ".o_searchview_dropdown_toggler",
            run: "click",
        },
        {
            trigger: ".o_favorite_menu .o_accordion > .o_menu_item",
            run: "click",
        },
        {
            trigger: ".o_favorite_menu .o_accordion_values .o_input",
            run: "edit Apps1",
        },
        {
            trigger: ".o_save_favorite",
            run: "click",
        },
        {
            trigger: ".o_searchview_facet .o_facet_value:contains(Apps1)",
        },
        {
            trigger: ".o_group_by_menu > .o-dropdown-item:contains(Category)",
            run: "click",
        },
        {
            trigger: ".o_kanban_header:contains(Account Charts)",
        },
        {
            trigger: ".o_favorite_menu .o_accordion_values .o_input",
            run: "edit Apps2",
        },
        {
            trigger: ".o_save_favorite",
            run: "click",
        },
        {
            trigger: ".o_favorite_menu .o-dropdown-item:contains(Apps2)",
        },
        {
            trigger: ".o_favorite_menu .o-dropdown-item:contains(Apps1) i:not(:visible)",
            run: "click",
        },
        {
            trigger: ".o_field_domain > div > div",
            run: "click",
        },
        {
            trigger: ".o_tree_editor_row:contains(New Rule) > a",
            run: "click",
        },
        {
            trigger: ".o_form_button_save",
            run: "click",
        },
        {
            trigger: ".o_back_button > a",
            run: "click",
        },
        {
            trigger: ".o_facet_values:contains('Apps2')",
        },
        {
            trigger: ".o_kanban_header:contains(Account Charts)",
        },
        {
            trigger: ".o_searchview_dropdown_toggler",
            run: "click",
        },
        {
            trigger: ".o_favorite_menu .o-dropdown-item:contains(Apps1)",
            run: "click",
        },
        {
            trigger: ".o_kanban_record:not(.o_kanban_ghost):only",
        },
        {
            trigger: ".o_favorite_menu .o-dropdown-item:contains(Apps1) i:not(:visible)",
            run: "click",
        },
        {
            trigger: ".o_form_view .o_cp_action_menus .o-dropdown",
            run: "click",
        },
        {
            trigger: ".o_popover > .o-dropdown-item:contains(Delete)",
            run: "click",
        },
        {
            trigger: ".o_technical_modal button:contains(Delete)",
            run: "click",
        },
        {
            trigger: ".o_searchview_dropdown_toggler",
            run: "click",
        },
        {
            trigger: ".o_favorite_menu .o-dropdown-item:contains(Apps2)",
        },
        {
            content: "There should not be any facet inside the search bar",
            trigger: "body:not(:has(.o_searchview_facet))",
        },
        {
            content: "The Apps1 filter should be deleted",
            trigger: "body:not(:has(.o_favorite_menu .o-dropdown-item:contains(Apps1)))",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /web/static/tests/tours/test_user_group_settings_tour.js  *
*  Lines: 153                                                          *
***********************************************************************/
odoo.define('@web/../tests/tours/test_user_group_settings_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("test_user_group_settings", {
    url: "/odoo/settings?debug=assets,tests",
    steps: () => [
        // create new privileges
        {
            trigger: 'button[data-menu-xmlid="base.menu_users"]',
            content: "open user menu",
            run: "click",
        },
        {
            trigger: 'a[data-menu-xmlid="base.menu_action_res_groups_privilege"]',
            content: "open privilege menu",
            run: "click",
        },
        {
            trigger: 'th.o_group_name:contains("Master Data")',
        },
        {
            trigger: "button.o_list_button_add",
            content: "click on new button",
            run: "click",
        },
        {
            trigger: '.o_field_char[name="name"] input',
            content: "insert a privilege name",
            run: "edit Privi Foo",
        },
        {
            trigger: ".o_field_x2many_list_row_add a",
            content: "add groups (open modal)",
            run: "click",
        },
        {
            trigger: ".o_create_button",
            content: "create the first group",
            run: "click",
        },
        {
            trigger: '.o_field_char[name="name"] input[placeholder="Group Name"]',
            content: "insert the first group name",
            run: "edit Bar User",
        },
        {
            trigger: "footer .o_form_button_save_new",
            content: "create the second group",
            run: "click",
        },
        {
            trigger: "body .o_notebook_content:contains(bar user)",
        },
        {
            trigger: '.o_field_char[name="name"] input[placeholder="Group Name"]',
            content: "insert the second group name",
            run: "edit Bar Manager",
        },
        {
            trigger: 'a[name="inherit_groups"]',
            content: "get implied groups",
            run: "click",
        },
        {
            trigger: 'div[name="implied_ids"] .o_field_x2many_list_row_add a',
            content: "switch to implied",
            run: "click",
        },
        {
            trigger: ".o_searchview_input",
            content: "search 'Bar' groups",
            run: "edit Bar",
        },
        {
            trigger: ".o_searchview_autocomplete .o-dropdown-item.focus",
            content: "Validate search",
            run: "click",
        },
        {
            trigger: '.o_data_cell:contains("Bar User"):last',
            content: "click to implied group 'Bar User'",
            run: "click",
        },
        {
            trigger: "footer .o_form_button_save",
            content: "save group and close modal",
            run: "click",
        },
        {
            trigger:
                "body:not(:has(.modal:visible)) .o_notebook_content:contains(bar user):contains(bar manager)",
        },
        // and the new manager group to the demo user
        {
            trigger: 'button[data-menu-xmlid="base.menu_users"]',
            content: "open user menu",
            run: "click",
        },
        {
            trigger: 'a[data-menu-xmlid="base.menu_action_res_users"]',
            content: "open users & companies menu",
            run: "click",
        },
        {
            trigger: ".o_list_renderer:contains(marc demo):contains(mitchell admin)",
        },
        {
            trigger: '.o_data_row:contains(Marc Demo) .o_field_cell[name="name"]',
            content: "open users menu",
            run: "click",
        },
        {
            trigger: '.o_last_breadcrumb_item:contains("Marc Demo")',
            content: "check if is demo user",
        },
        {
            trigger:
                '.o_field_widget[name="group_ids"] .o_cell:has(label:contains("Privi Foo")) + .o_cell .o_select_menu input',
            content: "Add 'Bar Manager' access to demo user",
            run: `click`,
        },
        {
            trigger: `.o-dropdown--menu .o_select_menu_item:contains("Bar Manager")`,
            run: "click",
        },
        // open group information button (popover)
        {
            trigger:
                '.o_field_widget[name="group_ids"] .o_cell:has(label:contains("Privi Foo")) + .o_cell .o_group_info_button',
            content: "open group information for the new group",
            run: "click",
        },
        {
            trigger: '.o_popover:contains("Privi Foo") a:contains("Bar Manager")',
            content: "open the group from the info button",
            run: "click",
        },
        // check if demo user has this group
        {
            trigger: '.o_last_breadcrumb_item:contains("Bar Manager")',
            content: "check if is Bar Manager group",
        },
        {
            trigger: '.o_field_many2many[name="user_ids"] .o_data_cell:contains("Marc Demo")',
            content: "check if demo user has this group",
        },
    ],
});

return __exports;
});
;

/**********************************************************
*  Filepath: /web/static/tests/tours/user_switch_tour.js  *
*  Lines: 179                                             *
**********************************************************/
odoo.define('@web/../tests/tours/user_switch_tour', ['@web/core/registry', '@bus/workers/websocket_worker', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { WORKER_STATE } = require("@bus/workers/websocket_worker");
const { whenReady } = require("@odoo/owl");

function logout() {
    return [
        {
            trigger: ".o_web_client .o_navbar",
            async run() {
                await whenReady();
                await new Promise((resolve) => requestAnimationFrame(resolve));
                await new Promise((resolve) => {
                    const bus = odoo.__WOWL_DEBUG__.root.env.services.bus_service;
                    bus.addEventListener("BUS:CONNECT", resolve, { once: true });
                    if (bus.workerState === WORKER_STATE.CONNECTED) {
                        resolve();
                    }
                });
            },
        },
        {
            content: "check we're logged in",
            trigger: ".o_user_menu .dropdown-toggle",
            run: "click",
        },
        {
            content: "click the Log out button",
            trigger: ".dropdown-item[data-menu=logout]",
            run: "click",
            expectUnloadPage: true,
        },
        {
            // Wait and check we are logged out
            // o_database_list is used in the case website is not installed and only portal is.
            trigger: ".oe_website_login_container, .o_database_list",
        },
    ];
}

registry.category("web_tour.tours").add("test_user_switch", {
    url: "/odoo",
    steps: () => [
        ...logout(),
        {
            content: "check if the login input is empty",
            trigger: "input#login:empty",
        },
        {
            content: "check if the password input is empty",
            trigger: "input#password:empty",
        },
        {
            content: "Should contains the user switch button",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Click on Marc Demo on the quick login page",
            trigger:
                ".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')",
            run: "click",
        },
        {
            content: "Check user choice button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Display the login form",
            trigger: ".o_user_switch .fa-user-circle-o",
            run: "click",
        },
        {
            content: "fill the login",
            trigger: "input#login",
            run: "edit admin",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit admin",
        },
        {
            content: "click on login button",
            trigger: 'button:contains("Log in")',
            run: "click",
            expectUnloadPage: true,
        },
        ...logout(),
        {
            content: "Check if there is Mitchell Admin in user list selection",
            trigger: ".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')",
        },
        {
            content: "Check if there is Marc Demo in user list selection",
            trigger: ".o_user_switch .list-group-item:nth-child(2):contains('Marc Demo')",
        },
        {
            content: "Choice demo",
            trigger: ".o_user_switch .list-group-item:contains('Marc Demo')",
            run: "click",
        },
        {
            content: "check the login for demo",
            trigger: "input#login:value('demo')",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit demo",
        },
        {
            content: "Check back button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Check have 2 users",
            trigger: ".o_user_switch .list-group-item:nth-child(2)",
        },
        {
            content: "Click on Mitchell Admin",
            trigger: ".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')",
            run: "click",
        },
        {
            content: "check the login for admin",
            trigger: "input#login:value('admin')",
        },
        {
            content: "fill the password",
            trigger: "input#password",
            run: "edit admin",
        },
        {
            content: "Check back button to back on the quick login page",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Display the login form",
            trigger: ".o_user_switch .fa-user-circle-o",
            run: "click",
        },
        {
            content: "the login form is display",
            trigger: "form.oe_login_form:not(.d-none)",
        },
        {
            content: "check if the login input is empty",
            trigger: "input#login:empty",
        },
        {
            content: "check if the password input is empty",
            trigger: "input#password:empty",
        },
        {
            content: "Back to user switch",
            trigger: ".oe_login_form .o_user_switch_btn",
            run: "click",
        },
        {
            content: "Remove the admin user from page",
            trigger: ".o_user_switch .d-flex:first-child .fa-times",
            run: "click",
        },
        {
            content: "only one user is left on quick login",
            trigger:
                ".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')",
        },
    ],
});

return __exports;
});
;

/*********************************************************************
*  Filepath: /web_tour/static/src/js/tour_automatic/tour_helpers.js  *
*  Lines: 21                                                         *
*********************************************************************/
odoo.define('@web_tour/js/tour_automatic/tour_helpers', [], function (require) {
'use strict';
let __exports = {};
const TourHelpers = __exports.TourHelpers = class TourHelpers {
    constructor(anchor) {
        this.anchor = anchor;
        this.delay = 20;
        return new Proxy(this, {
            get(target, prop, receiver) {
                const value = Reflect.get(target, prop, receiver);
                if (typeof value === "function" && prop !== "constructor") {
                    return value.bind(target);
                }
                return value;
            },
        });
    }
}

return __exports;
});
;

/******************************************************
*  Filepath: /web/static/lib/hoot-dom/helpers/dom.js  *
*  Lines: 2186                                        *
******************************************************/
odoo.define('@web/../lib/hoot-dom/helpers/dom', ['@web/../lib/hoot-dom/hoot_dom_utils', '@web/../lib/hoot-dom/helpers/time'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { getTag, isFirefox, isInstanceOf, isIterable, parseRegExp } = require("@web/../lib/hoot-dom/hoot_dom_utils");
const { waitUntil } = require("@web/../lib/hoot-dom/helpers/time");

/**
 * @typedef {number | [number, number] | {
 *  w?: number;
 *  h?: number;
 *  width?: number;
 *  height?: number;
 * }} Dimensions
 *
 * @typedef {{
 *  root?: Target;
 *  tabbable?: boolean;
 * }} FocusableOptions
 *
 * @typedef {{
 *  keepInlineTextNodes?: boolean;
 *  tabSize?: number;
 *  type?: "html" | "xml";
 * }} FormatXmlOptions
 *
 * @typedef {{
 *  inline: boolean;
 *  level: number;
 *  value: MarkupLayerValue;
 * }} MarkupLayer
 *
 * @typedef {{
 *  close?: string;
 *  open?: string;
 *  textContent?: string;
 * }} MarkupLayerValue
 *
 * @typedef {(node: Node, index: number, nodes: Node[]) => boolean | Node} NodeFilter
 *
 * @typedef {(node: Node, selector: string) => Node[]} NodeGetter
 *
 * @typedef {string | string[] | number | boolean | File[]} NodeValue
 *
 * @typedef {number | [number, number] | {
 *  x?: number;
 *  y?: number;
 *  left?: number;
 *  top?: number,
 *  clientX?: number;
 *  clientY?: number;
 *  pageX?: number;
 *  pageY?: number;
 *  screenX?: number;
 *  screenY?: number;
 * }} Position
 *
 * @typedef {(content: string) => QueryFilter} PseudoClassPredicateBuilder
 *
 * @typedef {string | number | NodeFilter} QueryFilter
 *
 * @typedef {{
 *  contains?: string;
 *  count?: number;
 *  displayed?: boolean;
 *  empty?: boolean;
 *  eq?: number;
 *  first?: boolean;
 *  focusable?: boolean;
 *  has?: boolean;
 *  hidden?: boolean;
 *  iframe?: boolean;
 *  interactive?: boolean;
 *  last?: boolean;
 *  not?: boolean;
 *  only?: boolean;
 *  root?: HTMLElement;
 *  scrollable?: ScrollAxis;
 *  selected?: boolean;
 *  shadow?: boolean;
 *  value?: boolean;
 *  viewPort?: boolean;
 *  visible?: boolean;
 * }} QueryOptions
 *
 * @typedef {{
 *  trimPadding?: boolean;
 * }} QueryRectOptions
 *
 * @typedef {{
 *  inline?: boolean;
 *  raw?: boolean;
 * }} QueryTextOptions
 *
 * @typedef {"both" | "x" | "y"} ScrollAxis
 *
 * @typedef {import("./time").WaitOptions} WaitOptions
 */

/**
 * @template T
 * @typedef {T | Iterable<T>} MaybeIterable
 */

/**
 * @template [T=Node]
 * @typedef {MaybeIterable<T> | string | null | undefined | false} Target
 */

//-----------------------------------------------------------------------------
// Global
//-----------------------------------------------------------------------------

const {
    document,
    DOMParser,
    Error,
    innerWidth,
    innerHeight,
    Map,
    MutationObserver,
    Number: { isInteger: $isInteger, isNaN: $isNaN, parseInt: $parseInt, parseFloat: $parseFloat },
    Object: { entries: $entries, keys: $keys, values: $values },
    RegExp,
    Set,
    String: { raw: $raw },
    window,
} = globalThis;

//-----------------------------------------------------------------------------
// Internal
//-----------------------------------------------------------------------------

/**
 * @param {Iterable<QueryFilter>} filters
 * @param {Node[]} nodes
 */
function applyFilters(filters, nodes) {
    for (const filter of filters) {
        const filteredGroupNodes = [];
        for (let i = 0; i < nodes.length; i++) {
            const result = matchFilter(filter, nodes, i);
            if (result === true) {
                filteredGroupNodes.push(nodes[i]);
            } else if (result) {
                filteredGroupNodes.push(result);
            }
        }
        nodes = filteredGroupNodes;
        if (globalFilterDescriptors.has(filter)) {
            globalFilterDescriptors.get(filter).push(nodes.length);
        } else if (selectorFilterDescriptors.has(filter)) {
            selectorFilterDescriptors.get(filter).push(nodes.length);
        }
    }
    return nodes;
}

function compilePseudoClassRegex() {
    const customKeys = [...customPseudoClasses.keys()].filter((k) => k !== "has" && k !== "not");
    return new RegExp(`:(${customKeys.join("|")})`);
}

/**
 * @param {Element[]} elements
 * @param {string} selector
 */
function elementsMatch(elements, selector) {
    if (!elements.length) {
        return false;
    }
    return parseSelector(selector).some((selectorParts) => {
        const [baseSelector, ...filters] = selectorParts.at(-1);
        for (let i = 0; i < elements.length; i++) {
            if (baseSelector && !elements[i].matches(baseSelector)) {
                return false;
            }
            if (!filters.every((filter) => matchFilter(filter, elements, i))) {
                return false;
            }
        }
        return true;
    });
}

/**
 * @param {QueryOptions} options
 */
function ensureCount(options) {
    options = { ...options };
    if (!("eq" in options || "first" in options || "last" in options)) {
        options.first = true;
    }
    return options;
}

/**
 * @param {Node} node
 * @returns {Element | null}
 */
function ensureElement(node) {
    if (node) {
        if (isDocument(node)) {
            return node.documentElement;
        }
        if (isWindow(node)) {
            return node.document.documentElement;
        }
        if (isElement(node)) {
            return node;
        }
    }
    return null;
}

/**
 * @param {Iterable<Node>} nodes
 * @param {number} level
 * @param {boolean} [keepInlineTextNodes]
 */
function extractLayers(nodes, level, keepInlineTextNodes) {
    /** @type {MarkupLayer[]} */
    const layers = [];
    for (const node of nodes) {
        if (node.nodeType === Node.COMMENT_NODE) {
            continue;
        }
        if (node.nodeType === Node.TEXT_NODE) {
            const textContent = node.nodeValue.replaceAll(/\n/g, "");
            const trimmedTextContent = textContent.trim();
            if (trimmedTextContent) {
                const inline = textContent === trimmedTextContent;
                layers.push({ inline, level, value: { textContent: trimmedTextContent } });
            }
            continue;
        }
        const [open, close] = node.outerHTML.replace(`>${node.innerHTML}<`, ">\n<").split("\n");
        const layer = { inline: false, level, value: { open, close } };
        layers.push(layer);
        const childLayers = extractLayers(node.childNodes, level + 1, false);
        if (keepInlineTextNodes && childLayers.length === 1 && childLayers[0].inline) {
            layer.value.textContent = childLayers[0].value.textContent;
        } else {
            layers.push(...childLayers);
        }
    }
    return layers;
}

/**
 * @param {Iterable<Node>} nodesToFilter
 */
function filterUniqueNodes(nodesToFilter) {
    /** @type {Node[]} */
    const nodes = [];
    for (const node of nodesToFilter) {
        if (isQueryableNode(node) && !nodes.includes(node)) {
            nodes.push(node);
        }
    }
    return nodes;
}

/**
 * @param {MarkupLayer[]} layers
 * @param {number} tabSize
 */
function generateStringFromLayers(layers, tabSize) {
    const result = [];
    let layerIndex = 0;
    while (layers.length > 0) {
        const layer = layers[layerIndex];
        const { level, value } = layer;
        const pad = " ".repeat(tabSize * level);
        let nextLayerIndex = layerIndex + 1;
        if (value.open) {
            if (value.textContent) {
                // node with inline textContent (no wrapping white-spaces)
                result.push(`${pad}${value.open}${value.textContent}${value.close}`);
                layers.splice(layerIndex, 1);
                nextLayerIndex--;
            } else {
                result.push(`${pad}${value.open}`);
                delete value.open;
            }
        } else {
            if (value.close) {
                result.push(`${pad}${value.close}`);
            } else if (value.textContent) {
                result.push(`${pad}${value.textContent}`);
            }
            layers.splice(layerIndex, 1);
            nextLayerIndex--;
        }
        if (nextLayerIndex >= layers.length) {
            layerIndex = nextLayerIndex - 1;
            continue;
        }
        const nextLayer = layers[nextLayerIndex];
        if (nextLayerIndex === 0 || nextLayer.level > layers[nextLayerIndex - 1].level) {
            layerIndex = nextLayerIndex;
        } else {
            layerIndex = nextLayerIndex - 1;
        }
    }
    return result.join("\n");
}

/**
 * @param {[string, string, number][]} modifierInfo
 */
function getFiltersDescription(modifierInfo) {
    const description = [];
    for (const [modifier, content, count = 0] of modifierInfo) {
        const makeLabel = MODIFIER_SUFFIX_LABELS[modifier];
        const elements = plural("element", count);
        if (typeof makeLabel === "function") {
            description.push(`${count} ${elements} ${makeLabel(content)}`);
        } else {
            description.push(`${count} ${modifier} ${elements}`);
        }
        if (!count) {
            // Stop at first null count to avoid situations like:
            // "found 0 elements, including 0 visible elements, including 0 ..."
            break;
        }
    }
    return description;
}

/**
 * @param {Node} node
 */
function getInlineNodeText(node) {
    return getNodeText(node, { inline: true });
}

/**
 * @param {Node} node
 * @returns {NodeValue}
 */
function getNodeContent(node) {
    switch (getTag(node)) {
        case "input":
        case "option":
        case "textarea":
            return getNodeValue(node);
        case "select":
            return [...node.selectedOptions].map(getNodeValue).join(",");
    }
    return getNodeText(node);
}

/** @type {NodeFilter} */
function getNodeIframe(node) {
    // Note: should only apply on `iframe` elements
    /** @see parseSelector */
    const doc = node.contentDocument;
    return doc && doc.readyState !== "loading" ? doc : false;
}

/** @type {NodeFilter} */
function getNodeShadowRoot(node) {
    return node.shadowRoot;
}

/**
 * @param {string} pseudoClass
 */
function getQueryFilter(pseudoClass, content) {
    const makeQueryFilter = customPseudoClasses.get(pseudoClass);
    try {
        return makeQueryFilter(content);
    } catch (err) {
        let message = `error while parsing pseudo-class ':${pseudoClass}'`;
        const cause = String(err?.message || err);
        if (cause) {
            message += `: ${cause}`;
        }
        throw new HootDomError(message);
    }
}

/**
 * @param {string} string
 */
function getStringContent(string) {
    return string.match(R_QUOTE_CONTENT)?.[2] || string;
}

function getWaitForMessage() {
    const message = `expected at least 1 element after %timeout%ms and ${lastQueryMessage}`;
    lastQueryMessage = "";
    return message;
}

function getWaitForNoneMessage() {
    const message = `expected 0 elements after %timeout%ms and ${lastQueryMessage}`;
    lastQueryMessage = "";
    return message;
}

/**
 *
 * @param {number} count
 * @param {Parameters<NodeFilter>[0]} _node
 * @param {Parameters<NodeFilter>[1]} _i
 * @param {Parameters<NodeFilter>[2]} nodes
 */
function hasNodeCount(count, _node, _i, nodes) {
    return count === nodes.length;
}

/**
 * @param {string} [char]
 */
function isChar(char) {
    return !!char && R_CHAR.test(char);
}

/**
 * @template T
 * @param {T} object
 * @returns {T extends Document ? true : false}
 */
function isDocument(object) {
    return object?.nodeType === Node.DOCUMENT_NODE;
}

/**
 * @template T
 * @param {T} object
 * @returns {T extends Element ? true: false}
 */
function isElement(object) {
    return object?.nodeType === Node.ELEMENT_NODE;
}

/**
 * @param {string} selector
 * @param {Node} node
 */
function isNodeHaving(selector, node) {
    return !!_queryAll(selector, { root: node }).length;
}

/** @type {NodeFilter} */
function isNodeHidden(node) {
    return !isNodeVisible(node);
}

/** @type {NodeFilter} */
function isNodeInteractive(node) {
    return (
        getStyle(node).pointerEvents !== "none" &&
        !node.closest?.("[inert]") &&
        !getParentFrame(node)?.inert
    );
}

/**
 * @param {string} selector
 * @param {Node} node
 */
function isNodeNotMatching(selector, node) {
    return !matches(node, selector);
}

/** @type {NodeFilter} */
function isNodeSelected(node) {
    return !!node.selected;
}

/** @type {NodeFilter} */
function isOnlyNode(_node, _i, nodes) {
    return nodes.length === 1;
}

/**
 * @param {Node} node
 */
function isQueryableNode(node) {
    return QUERYABLE_NODE_TYPES.includes(node.nodeType);
}

/**
 * @param {Element} [el]
 */
function isRootElement(el) {
    return el && R_ROOT_ELEMENT.test(el.nodeName || "");
}

/**
 * @param {Element} el
 */
function isShadowRoot(el) {
    return el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !!el.host;
}

/**
 * @template T
 * @param {T} object
 * @returns {T extends Window ? true : false}
 */
function isWindow(object) {
    return object?.window === object && object.constructor.name === "Window";
}

/**
 * @param {string} [char]
 */
function isWhiteSpace(char) {
    return !!char && R_HORIZONTAL_WHITESPACE.test(char);
}

/**
 * @param {(node: Node) => NodeValue} getContent
 * @param {boolean} exact
 */
function makePseudoClassMatcher(getContent, exact) {
    return function makePartialMatcher(content) {
        const regex = parseRegExp(content);
        if (isInstanceOf(regex, RegExp)) {
            return function stringMatches(node) {
                return regex.test(String(getContent(node)));
            };
        } else {
            const lowerContent = content.toLowerCase();
            if (exact) {
                return function stringEquals(node) {
                    return String(getContent(node)).toLowerCase() === lowerContent;
                };
            } else {
                return function stringContains(node) {
                    return String(getContent(node)).toLowerCase().includes(lowerContent);
                };
            }
        }
    };
}

/**
 *
 * @param {QueryFilter} filter
 * @param {Node[]} nodes
 * @param {number} index
 */
function matchFilter(filter, nodes, index) {
    if (typeof filter === "number") {
        if (filter < 0) {
            return filter + nodes.length === index;
        } else {
            return filter === index;
        }
    }
    const node = nodes[index];
    if (typeof filter === "function") {
        return filter(node, index, nodes);
    } else {
        return !!node.matches?.(String(filter));
    }
}

/**
 * flatMap implementation supporting NodeList iterables.
 *
 * @param {Iterable<Node>} nodes
 * @param {(node: Node) => Node | Iterable<Node> | null | undefined} flatMapFn
 */
function nodeFlatMap(nodes, flatMapFn) {
    /** @type {Node[]} */
    const result = [];
    for (const node of nodes) {
        const nodeList = flatMapFn(node);
        if (isNode(nodeList)) {
            result.push(nodeList);
        } else if (isIterable(nodeList)) {
            result.push(...nodeList);
        }
    }
    return result;
}

/**
 * @template T
 * @param {T} value
 * @param {(keyof T)[]} propsA
 * @param {(keyof T)[]} propsB
 * @returns {[number, number]}
 */
function parseNumberTuple(value, propsA, propsB) {
    let result = [];
    if (value && typeof value === "object") {
        if (isIterable(value)) {
            [result[0], result[1]] = [...value];
        } else {
            for (const prop of propsA) {
                result[0] ??= value[prop];
            }
            for (const prop of propsB) {
                result[1] ??= value[prop];
            }
        }
    } else {
        result = [value, value];
    }
    return result.map($parseFloat);
}

/**
 * @template {any[]} T
 * @param {T} args
 * @returns {string | T}
 */
function parseRawArgs(args) {
    return args[0]?.raw ? [$raw(...args)] : args;
}

/**
 * Parses a given selector string into a list of selector groups.
 *
 * - the return value is a list of selector `group` objects (representing comma-separated
 *  selectors);
 * - a `group` is composed of one or more `part` objects (representing space-separated
 *  selector parts inside of a group);
 * - a `part` is composed of a base selector (string) and zero or more 'filters' (predicates).
 *
 * @param {string} selector
 */
function parseSelector(selector) {
    /**
     * @param {string} selector
     */
    function addToSelector(selector) {
        registerChar = false;
        const index = currentPart.length - 1;
        if (typeof currentPart[index] === "string") {
            currentPart[index] += selector;
        } else {
            currentPart.push(selector);
        }
    }

    /** @type {(string | ReturnType<PseudoClassPredicateBuilder>)[]} */
    const firstPart = [""];
    const firstGroup = [firstPart];
    const groups = [firstGroup];
    const parens = [0, 0];

    let currentGroup = groups.at(-1);
    let currentPart = currentGroup.at(-1);
    let currentPseudo = null;
    let currentQuote = null;
    let registerChar = true;

    for (let i = 0; i < selector.length; i++) {
        const char = selector[i];
        registerChar = true;
        switch (char) {
            // Group separator (comma)
            case ",": {
                if (!currentQuote && !currentPseudo) {
                    groups.push([[""]]);
                    currentGroup = groups.at(-1);
                    currentPart = currentGroup.at(-1);
                    registerChar = false;
                }
                break;
            }
            // Part separator (white space)
            case " ":
            case "\t":
            case "\n":
            case "\r":
            case "\f":
            case "\v": {
                if (!currentQuote && !currentPseudo) {
                    if (currentPart[0] || currentPart.length > 1) {
                        // Only push new part if the current one is not empty
                        // (has at least 1 character OR 1 pseudo-class filter)
                        currentGroup.push([""]);
                        currentPart = currentGroup.at(-1);
                    }
                    registerChar = false;
                }
                break;
            }
            // Quote delimiters
            case `'`:
            case `"`: {
                if (char === currentQuote) {
                    currentQuote = null;
                } else if (!currentQuote) {
                    currentQuote = char;
                }
                break;
            }
            // Combinators
            case ">":
            case "+":
            case "~": {
                if (!currentQuote && !currentPseudo) {
                    while (isWhiteSpace(selector[i + 1])) {
                        i++;
                    }
                    addToSelector(char);
                }
                break;
            }
            // Pseudo classes
            case ":": {
                if (!currentQuote && !currentPseudo) {
                    let pseudo = "";
                    while (isChar(selector[i + 1])) {
                        pseudo += selector[++i];
                    }
                    if (customPseudoClasses.has(pseudo)) {
                        if (selector[i + 1] === "(") {
                            parens[0]++;
                            i++;
                            registerChar = false;
                        }
                        currentPseudo = [pseudo, ""];
                    } else {
                        addToSelector(char + pseudo);
                    }
                }
                break;
            }
            // Parentheses
            case "(": {
                if (!currentQuote) {
                    parens[0]++;
                }
                break;
            }
            case ")": {
                if (!currentQuote) {
                    parens[1]++;
                }
                break;
            }
        }

        if (currentPseudo) {
            if (parens[0] === parens[1]) {
                const [pseudo, content] = currentPseudo;
                if (pseudo === "iframe" && !currentPart[0].startsWith("iframe")) {
                    // Special case: to optimise the ":iframe" pseudo class, we
                    // always select actual `iframe` elements.
                    // Note that this may create "impossible" tag names (like "iframediv")
                    // but this pseudo won't work on non-iframe elements anyway.
                    currentPart[0] = `iframe${currentPart[0]}`;
                }
                const filter = getQueryFilter(pseudo, getStringContent(content));
                selectorFilterDescriptors.set(filter, [pseudo, content]);
                currentPart.push(filter);
                currentPseudo = null;
            } else if (registerChar) {
                currentPseudo[1] += selector[i];
            }
        } else if (registerChar) {
            addToSelector(selector[i]);
        }
    }

    return groups;
}

/**
 * @param {string} xmlString
 * @param {"html" | "xml"} type
 */
function parseXml(xmlString, type) {
    const wrapperTag = type === "html" ? "body" : "templates";
    const doc = parser.parseFromString(
        `<${wrapperTag}>${xmlString}</${wrapperTag}>`,
        `text/${type}`
    );
    if (doc.getElementsByTagName("parsererror").length) {
        const trimmed = xmlString.length > 80 ? xmlString.slice(0, 80) + "" : xmlString;
        throw new HootDomError(
            `error while parsing ${trimmed}: ${getNodeText(
                doc.getElementsByTagName("parsererror")[0]
            )}`
        );
    }
    return doc.getElementsByTagName(wrapperTag)[0].childNodes;
}

/**
 * Converts a CSS pixel value to a number, removing the 'px' part.
 *
 * @param {string} val
 */
function pixelValueToNumber(val) {
    return $parseFloat(val.endsWith("px") ? val.slice(0, -2) : val);
}

/**
 * @param {string} word
 * @param {number} count
 */
function plural(word, count) {
    return count === 1 ? word : `${word}s`;
}

/**
 * @param {Node[]} nodes (assumed not empty)
 * @param {string} selector
 */
function queryWithCustomSelector(nodes, selector) {
    const selectorGroups = parseSelector(selector);
    const foundNodes = [];
    for (const selectorParts of selectorGroups) {
        let groupNodes = nodes;
        for (const selectorPart of selectorParts) {
            let baseSelector = selectorPart[0];
            let nodeGetter;
            switch (baseSelector[0]) {
                case "+": {
                    nodeGetter = NEXT_SIBLING;
                    break;
                }
                case ">": {
                    nodeGetter = DIRECT_CHILDREN;
                    break;
                }
                case "~": {
                    nodeGetter = NEXT_SIBLINGS;
                    break;
                }
            }

            // Slices modifier (if any)
            if (nodeGetter) {
                baseSelector = baseSelector.slice(1);
            }
            nodeGetter ||= DESCENDANTS;

            // Retrieve nodes from current group nodes
            const currentGroupNodes = nodeFlatMap(groupNodes, (node) =>
                nodeGetter(node, baseSelector)
            );

            // Filter/replace nodes based on custom pseudo-classes
            groupNodes = applyFilters(selectorPart.slice(1), currentGroupNodes);
        }

        foundNodes.push(...groupNodes);
    }

    return filterUniqueNodes(foundNodes);
}

/**
 * Creates a query message if needed, with all the information available used to
 * gather the given nodes (base selector and count of nodes matching it, then each
 * modifier applied as a filter with each associated count).
 *
 * Returns the resulting message only if the final count of nodes doesn't match
 * the given expected count.
 *
 * @param {Node[]} filteredNodes
 * @param {number} [expectedCount]
 */
function registerQueryMessage(filteredNodes, expectedCount) {
    lastQueryMessage = "";
    const filteredCount = filteredNodes.length;
    const invalidCount = $isInteger(expectedCount) && filteredCount !== expectedCount;
    if (shouldRegisterQueryMessage || invalidCount) {
        const globalModifierInfo = [...globalFilterDescriptors.values()];

        // First message part: final count
        lastQueryMessage += `found ${filteredCount} ${plural("element", filteredCount)}`;
        if (invalidCount) {
            lastQueryMessage += ` instead of ${expectedCount}`;
        }

        // Next message part: initial element count (with selector if string)
        const rootModifierInfo = globalModifierInfo.shift();
        const [, rootContent, initialCount = 0] = rootModifierInfo;
        if (typeof rootContent === "string") {
            lastQueryMessage += `: ${initialCount} matching ${JSON.stringify(rootContent)}`;
            if (selectorFilterDescriptors.size) {
                // Selector filters will only be available with a custom selector
                const selectorModifierInfo = [...selectorFilterDescriptors.values()];
                lastQueryMessage += ` (${getFiltersDescription(selectorModifierInfo).join(" > ")})`;
            }
        } else if (filteredCount !== initialCount) {
            // Do not report count if same as announced initially
            lastQueryMessage += `: ${initialCount} ${plural("element", initialCount)}`;
        }
        if (initialCount) {
            // Next message parts: each count associated with each modifier
            lastQueryMessage += getFiltersDescription(globalModifierInfo)
                .map((part) => `, including ${part}`)
                .join("");
        }
    } else {
        lastQueryMessage = "";
    }
    if (queryAllLevel <= 1) {
        globalFilterDescriptors.clear();
        selectorFilterDescriptors.clear();
    }
    return invalidCount ? lastQueryMessage : "";
}

/**
 * Wrapper around '_queryAll' calls to ensure global variables are properly cleaned
 * up on any thrown error.
 *
 * @param {Target} target
 * @param {QueryOptions} options
 */
function _guardedQueryAll(target, options) {
    try {
        return _queryAll(target, options);
    } catch (error) {
        queryAllLevel = 0;
        shouldRegisterQueryMessage = false;
        globalFilterDescriptors.clear();
        selectorFilterDescriptors.clear();
        throw error;
    }
}

/**
 * @param {Target} target
 * @param {QueryOptions} options
 */
function _queryAll(target, options) {
    queryAllLevel++;

    const { count, root, ...modifiers } = options || {};
    if (count !== null && count !== undefined && (!$isInteger(count) || count <= 0)) {
        throw new HootDomError(`invalid 'count' option: should be a positive integer`);
    }

    /** @type {Node[]} */
    let nodes = [];
    let selector;

    if (typeof target === "string") {
        if (target) {
            nodes = root ? _queryAll(root) : [getDefaultRoot()];
        }
        selector = target.trim();
        // HTMLSelectElement is iterable \_()_/
    } else if (isIterable(target) && !isNode(target)) {
        nodes = filterUniqueNodes(target);
    } else if (target) {
        nodes = filterUniqueNodes([target]);
    }

    globalFilterDescriptors.set("root", ["", target]);
    if (selector && nodes.length) {
        if (rCustomPseudoClass.test(selector)) {
            nodes = queryWithCustomSelector(nodes, selector);
        } else {
            nodes = filterUniqueNodes(nodeFlatMap(nodes, (node) => DESCENDANTS(node, selector)));
        }
    }
    globalFilterDescriptors.get("root").push(nodes.length);

    if (modifiers.visible && modifiers.displayed) {
        throw new HootDomError(
            `cannot use more than one visibility modifier ('visible' implies 'displayed')`
        );
    }

    // Apply option modifiers on matching nodes
    const modifierFilters = [];
    for (const [modifier, content] of $entries(modifiers)) {
        if (content === false || !customPseudoClasses.has(modifier)) {
            continue;
        }
        const filter = getQueryFilter(modifier, content);
        modifierFilters.push(filter);
        globalFilterDescriptors.set(filter, [modifier, content]);
    }
    const filteredNodes = applyFilters(modifierFilters, nodes);

    // Register query message (if needed), and/or throw an error accordingly
    const message = registerQueryMessage(filteredNodes, count);
    if (message) {
        throw new HootDomError(message);
    }

    queryAllLevel--;

    return filteredNodes;
}

/**
 * @param {Target} target
 * @param {QueryOptions} options
 */
function _queryOne(target, options) {
    return _guardedQueryAll(target, { ...options, count: 1 })[0];
}

/**
 * @param {Target} target
 * @param {QueryOptions} options
 * @param {boolean} isLast
 */
function _waitForFirst(target, options, isLast) {
    shouldRegisterQueryMessage = isLast;
    const result = _guardedQueryAll(target, options)[0];
    shouldRegisterQueryMessage = false;
    return result;
}

/**
 * @param {Target} target
 * @param {QueryOptions} options
 * @param {boolean} isLast
 */
function _waitForNone(target, options, isLast) {
    shouldRegisterQueryMessage = isLast;
    const result = _guardedQueryAll(target, options).length === 0;
    shouldRegisterQueryMessage = false;
    return result;
}

class HootDomError extends Error {
    name = "HootDomError";
}

// Regexes
const R_CHAR = /[\w-]/;
/** \s without \n and \v */
const R_HORIZONTAL_WHITESPACE =
    /[\r\t\f \u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/g;
const R_LINEBREAK = /\s*\n+\s*/g;
const R_QUOTE_CONTENT = /^\s*(['"])?([^]*?)\1\s*$/;
const R_ROOT_ELEMENT = /^(HTML|HEAD|BODY)$/;
const R_SCROLLABLE_OVERFLOW = /\bauto\b|\bscroll\b/;

const MODIFIER_SUFFIX_LABELS = {
    contains: (content) => `with text "${content}"`,
    eq: (content) => `at index ${content}`,
    has: (content) => `containing selector "${content}"`,
    not: (content) => `not matching "${content}"`,
    value: (content) => `with value "${content}"`,
    viewPort: () => "in viewport",
};

const QUERYABLE_NODE_TYPES = [Node.ELEMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE];

const parser = new DOMParser();

// Node getters

/** @type {NodeGetter} */
function DIRECT_CHILDREN(node, selector) {
    const children = [];
    for (const childNode of node.childNodes) {
        if (childNode.matches?.(selector)) {
            children.push(childNode);
        }
    }
    return children;
}

/** @type {NodeGetter} */
function DESCENDANTS(node, selector) {
    return node.querySelectorAll?.(selector || "*");
}

/** @type {NodeGetter} */
function NEXT_SIBLING(node, selector) {
    const sibling = node.nextElementSibling;
    return sibling?.matches?.(selector) && sibling;
}

/** @type {NodeGetter} */
function NEXT_SIBLINGS(node, selector) {
    const siblings = [];
    while ((node = node.nextElementSibling)) {
        if (node.matches?.(selector)) {
            siblings.push(node);
        }
    }
    return siblings;
}

/** @type {Map<QueryFilter, [string, string | null, number]>} */
const globalFilterDescriptors = new Map();
/** @type {Map<QueryFilter, [string, string | null, number]>} */
const selectorFilterDescriptors = new Map();
/** @type {Map<HTMLElement, { callbacks: Set<MutationCallback>, observer: MutationObserver }>} */
const observers = new Map();
const currentDimensions = {
    width: innerWidth,
    height: innerHeight,
};
let getDefaultRoot = () => document;
let lastQueryMessage = "";
let shouldRegisterQueryMessage = false;
let queryAllLevel = 0;

//-----------------------------------------------------------------------------
// Pseudo classes
//-----------------------------------------------------------------------------

/** @type {Map<string, PseudoClassPredicateBuilder>} */
const customPseudoClasses = new Map();

customPseudoClasses
    .set("contains", makePseudoClassMatcher(getInlineNodeText, false))
    .set("count", (strCount) => {
        const count = $parseInt(strCount);
        if (!$isInteger(count) || count <= 0) {
            throw new HootDomError(`expected count to be a positive integer (got "${strCount}")`);
        }
        return hasNodeCount.bind(null, count);
    })
    .set("displayed", () => isNodeDisplayed)
    .set("empty", () => isEmpty)
    .set("eq", (strIndex) => {
        const index = $parseInt(strIndex);
        if (!$isInteger(index)) {
            throw new HootDomError(`expected index to be an integer (got "${strIndex}")`);
        }
        return index;
    })
    .set("first", () => 0)
    .set("focusable", () => isNodeFocusable)
    .set("has", (selector) => isNodeHaving.bind(null, selector))
    .set("hidden", () => isNodeHidden)
    .set("iframe", () => getNodeIframe)
    .set("interactive", () => isNodeInteractive)
    .set("last", () => -1)
    .set("not", (selector) => isNodeNotMatching.bind(null, selector))
    .set("only", () => isOnlyNode)
    .set("scrollable", (axis) => isNodeScrollable.bind(null, axis))
    .set("selected", () => isNodeSelected)
    .set("shadow", () => getNodeShadowRoot)
    .set("text", makePseudoClassMatcher(getInlineNodeText, true))
    .set("value", makePseudoClassMatcher(getNodeValue, false))
    .set("viewPort", () => isNodeInViewPort)
    .set("visible", () => isNodeVisible);

const rCustomPseudoClass = compilePseudoClassRegex();

//-----------------------------------------------------------------------------
// Internal exports (inside Hoot/Hoot-DOM)
//-----------------------------------------------------------------------------

__exports.cleanupDOM = cleanupDOM; function cleanupDOM() {
    // Dimensions
    currentDimensions.width = innerWidth;
    currentDimensions.height = innerHeight;

    // Observers
    const remainingObservers = observers.size;
    if (remainingObservers) {
        for (const { observer } of observers.values()) {
            observer.disconnect();
        }
        observers.clear();
    }
}

/**
 * @param {Node | () => Node} node
 */
__exports.defineRootNode = defineRootNode; function defineRootNode(node) {
    if (typeof node === "function") {
        getDefaultRoot = node;
    } else if (node) {
        getDefaultRoot = () => node;
    } else {
        getDefaultRoot = () => document;
    }
}

__exports.getCurrentDimensions = getCurrentDimensions; function getCurrentDimensions() {
    return currentDimensions;
}

/**
 * @param {Node} [node]
 * @returns {Document}
 */
__exports.getDocument = getDocument; function getDocument(node) {
    if (!node) {
        return document;
    }
    return isDocument(node) ? node : node.ownerDocument || document;
}

/**
 * @param {Node} node
 * @param {string} attribute
 * @returns {string | null}
 */
__exports.getNodeAttribute = getNodeAttribute; function getNodeAttribute(node, attribute) {
    return node.getAttribute?.(attribute) ?? null;
}

/**
 * @param {Node} node
 * @returns {NodeValue}
 */
__exports.getNodeValue = getNodeValue; function getNodeValue(node) {
    switch (node.type) {
        case "checkbox":
        case "radio":
            return node.checked;
        case "file":
            return [...node.files];
        case "number":
        case "range":
            return node.valueAsNumber;
        case "date":
        case "datetime-local":
        case "month":
        case "time":
        case "week":
            return node.valueAsDate.toISOString();
    }
    return node.value;
}

/**
 * @param {Node} node
 * @param {QueryRectOptions} [options]
 */
__exports.getNodeRect = getNodeRect; function getNodeRect(node, options) {
    if (!isElement(node)) {
        return new DOMRect();
    }

    /** @type {DOMRect} */
    const rect = node.getBoundingClientRect();
    const parentFrame = getParentFrame(node);
    if (parentFrame) {
        const parentRect = getNodeRect(parentFrame);
        rect.x -= parentRect.x;
        rect.y -= parentRect.y;
    }

    if (!options?.trimPadding) {
        return rect;
    }

    const style = getStyle(node);
    const { x, y, width, height } = rect;
    const [pl, pr, pt, pb] = ["left", "right", "top", "bottom"].map((side) =>
        pixelValueToNumber(style.getPropertyValue(`padding-${side}`))
    );

    return new DOMRect(x + pl, y + pt, width - (pl + pr), height - (pt + pb));
}

/**
 * @param {Node} node
 * @param {QueryTextOptions} [options]
 * @returns {string}
 */
__exports.getNodeText = getNodeText; function getNodeText(node, options) {
    let content;
    if (typeof node.innerText === "string") {
        content = node.innerText;
    } else {
        content = node.textContent;
    }
    if (!options?.raw) {
        content = content.replace(R_HORIZONTAL_WHITESPACE, " ").trim();
    }
    if (options?.inline) {
        content = content.replace(R_LINEBREAK, " ");
    }
    return content;
}

/**
 * @param {Node} node
 * @returns {Node | null}
 */
__exports.getInteractiveNode = getInteractiveNode; function getInteractiveNode(node) {
    let currentEl = ensureElement(node);
    if (!currentEl) {
        return null;
    }
    while (currentEl && !isNodeInteractive(currentEl)) {
        currentEl = currentEl.parentElement;
    }
    return currentEl;
}

/**
 * @template {Node} T
 * @param {T} node
 * @returns {T extends Element ? CSSStyleDeclaration : null}
 */
__exports.getStyle = getStyle; function getStyle(node) {
    return isElement(node) ? getComputedStyle(node) : null;
}

/**
 * @param {Node} [node]
 * @returns {Window}
 */
__exports.getWindow = getWindow; function getWindow(node) {
    if (!node) {
        return window;
    }
    return isWindow(node) ? node : getDocument(node).defaultView;
}

/**
 * @param {Node} node
 * @returns {boolean}
 */
__exports.isCheckable = isCheckable; function isCheckable(node) {
    switch (getTag(node)) {
        case "input":
            return node.type === "checkbox" || node.type === "radio";
        case "label":
            return isCheckable(node.control);
        default:
            return false;
    }
}

/**
 * @param {unknown} value
 * @returns {boolean}
 */
__exports.isEmpty = isEmpty; function isEmpty(value) {
    if (!value) {
        return true;
    }
    if (typeof value === "object") {
        if (isNode(value)) {
            return isEmpty(getNodeContent(value));
        }
        if (!isIterable(value)) {
            value = $keys(value);
        }
        return [...value].length === 0;
    }
    return false;
}

/**
 * Returns whether the given object is an {@link EventTarget}.
 *
 * @template T
 * @param {T} object
 * @returns {T extends EventTarget ? true : false}
 * @example
 *  isEventTarget(window); // true
 * @example
 *  isEventTarget(new App()); // false
 */
__exports.isEventTarget = isEventTarget; function isEventTarget(object) {
    return object && typeof object.addEventListener === "function";
}

/**
 * Returns whether the given object is a {@link Node} object.
 * Note that it is independant from the {@link Node} class itself to support
 * cross-window checks.
 *
 * @template T
 * @param {T} object
 * @returns {T extends Node ? true : false}
 */
__exports.isNode = isNode; function isNode(object) {
    return object && typeof object.nodeType === "number" && typeof object.nodeName === "string";
}

/**
 * @param {Node} node
 */
__exports.isNodeCssVisible = isNodeCssVisible; function isNodeCssVisible(node) {
    const element = ensureElement(node);
    if (element === getDefaultRoot() || isRootElement(element)) {
        return true;
    }
    const style = getStyle(element);
    if (style?.visibility === "hidden" || style?.opacity === "0") {
        return false;
    }
    const parent = element.parentNode;
    return !parent || isNodeCssVisible(isShadowRoot(parent) ? parent.host : parent);
}

/**
 * @param {Window | Node} node
 */
__exports.isNodeDisplayed = isNodeDisplayed; function isNodeDisplayed(node) {
    const element = ensureElement(node);
    if (!isInDOM(element)) {
        return false;
    }
    if (isRootElement(element) || element.offsetParent || element.closest("svg")) {
        return true;
    }
    // `position=fixed` elements in Chrome do not have an `offsetParent`
    return !isFirefox() && getStyle(element)?.position === "fixed";
}

/**
 * @param {Node} node
 * @param {FocusableOptions} [options]
 */
__exports.isNodeFocusable = isNodeFocusable; function isNodeFocusable(node, options) {
    return (
        isNodeDisplayed(node) &&
        node.matches?.(FOCUSABLE_SELECTOR) &&
        (!options?.tabbable || node.tabIndex >= 0)
    );
}

/**
 * @param {Window | Node} node
 */
__exports.isNodeInViewPort = isNodeInViewPort; function isNodeInViewPort(node) {
    const element = ensureElement(node);
    const { x, y } = getNodeRect(element);

    return y > 0 && y < currentDimensions.height && x > 0 && x < currentDimensions.width;
}

/**
 * @param {ScrollAxis} axis
 * @param {Window | Node} node
 */
__exports.isNodeScrollable = isNodeScrollable; function isNodeScrollable(axis, node) {
    if (!isElement(node)) {
        return false;
    }
    const isScrollableX = node.clientWidth < node.scrollWidth;
    const isScrollableY = node.clientHeight < node.scrollHeight;
    switch (axis) {
        case "both": {
            if (!isScrollableX || !isScrollableY) {
                return false;
            }
            break;
        }
        case "x": {
            if (!isScrollableX) {
                return false;
            }
            break;
        }
        case "y": {
            if (!isScrollableY) {
                return false;
            }
            break;
        }
        default: {
            // Check for any scrollable axis
            if (!isScrollableX && !isScrollableY) {
                return false;
            }
        }
    }
    const overflow = getStyle(node).getPropertyValue("overflow");
    if (R_SCROLLABLE_OVERFLOW.test(overflow)) {
        return true;
    }
    return false;
}

/**
 * @param {Window | Node} node
 */
__exports.isNodeVisible = isNodeVisible; function isNodeVisible(node) {
    const element = ensureElement(node);

    // Must be displayed and not hidden by CSS
    if (!isNodeDisplayed(element) || !isNodeCssVisible(element)) {
        return false;
    }

    let visible = false;

    // Check size (width & height)
    const { width, height } = getNodeRect(element);
    visible = width > 0 && height > 0;

    // Check content (if display=contents)
    if (!visible && getStyle(element)?.display === "contents") {
        for (const child of element.childNodes) {
            if (isNodeVisible(child)) {
                return true;
            }
        }
    }

    return visible;
}

/**
 * @param {Dimensions} dimensions
 * @returns {[number, number]}
 */
__exports.parseDimensions = parseDimensions; function parseDimensions(dimensions) {
    return parseNumberTuple(dimensions, ["width", "w"], ["height", "h"]);
}

/**
 * @param {Position} position
 * @returns {[number, number]}
 */
__exports.parsePosition = parsePosition; function parsePosition(position) {
    return parseNumberTuple(
        position,
        ["x", "left", "clientX", "pageX", "screenX"],
        ["y", "top", "clientY", "pageY", "screenY"]
    );
}

/**
 * @param {number} width
 * @param {number} height
 */
__exports.setDimensions = setDimensions; function setDimensions(width, height) {
    const defaultRoot = getDefaultRoot();
    if (!$isNaN(width)) {
        currentDimensions.width = width;
        defaultRoot.style?.setProperty("width", `${width}px`, "important");
    }
    if (!$isNaN(height)) {
        currentDimensions.height = height;
        defaultRoot.style?.setProperty("height", `${height}px`, "important");
    }
}

/**
 * @param {Node} node
 * @param {{ object?: boolean }} [options]
 * @returns {string | string[]}
 */
__exports.toSelector = toSelector; function toSelector(node, options) {
    const parts = {
        tag: node.nodeName.toLowerCase(),
    };
    if (node.id) {
        parts.id = `#${node.id}`;
    }
    if (node.classList?.length) {
        parts.class = `.${[...node.classList].join(".")}`;
    }
    return options?.object ? parts : $values(parts).join("");
}

// Following selector is based on this spec:
// https://html.spec.whatwg.org/multipage/interaction.html#dom-tabindex
const FOCUSABLE_SELECTOR = __exports.FOCUSABLE_SELECTOR = [
    "a[href]",
    "area[href]",
    "button:enabled",
    "details > summary:first-of-type",
    "iframe",
    "input:enabled",
    "select:enabled",
    "textarea:enabled",
    "[tabindex]",
    "[contenteditable=true]",
].join(",");

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * Returns a standardized representation of the given `string` value as a human-readable
 * XML string template (or HTML if the `type` option is `"html"`).
 *
 * @param {string} value
 * @param {FormatXmlOptions} [options]
 * @returns {string}
 */
__exports.formatXml = formatXml; function formatXml(value, options) {
    const nodes = parseXml(value, options?.type || "xml");
    const layers = extractLayers(nodes, 0, options?.keepInlineTextNodes ?? false);
    return generateStringFromLayers(layers, options?.tabSize ?? 4);
}

/**
 * Returns the active element in the given document. Further checks are performed
 * in the following cases:
 * - the given node is an iframe (checks in its content document);
 * - the given node has a shadow root (checks in that shadow root document);
 * - the given node is the body of an iframe (checks in the parent document).
 *
 * @param {Node} [node]
 */
__exports.getActiveElement = getActiveElement; function getActiveElement(node) {
    const doc = getDocument(node);
    const view = doc.defaultView;
    const { activeElement } = doc;
    const { contentDocument, shadowRoot } = activeElement;

    if (contentDocument && contentDocument.activeElement !== contentDocument.body) {
        // Active element is an "iframe" element (with an active element other than its own body):
        if (contentDocument.activeElement === contentDocument.body) {
            // Active element is the body of the iframe:
            // -> returns that element
            return contentDocument.activeElement;
        } else {
            // Active element is something else than the body:
            // -> get the active element inside the iframe document
            return getActiveElement(contentDocument);
        }
    }

    if (shadowRoot) {
        // Active element has a shadow root:
        // -> get the active element inside its root
        return shadowRoot.activeElement;
    }

    if (activeElement === doc.body && view !== view.parent) {
        // Active element is the body of an iframe:
        // -> get the active element of its parent frame (recursively)
        return getActiveElement(view.parent.document);
    }

    return activeElement;
}

/**
 * Returns the list of focusable elements in the given parent, sorted by their `tabIndex`
 * property.
 *
 * @see {@link isFocusable} for more information
 * @param {FocusableOptions} [options]
 * @returns {Element[]}
 * @example
 *  getFocusableElements();
 */
__exports.getFocusableElements = getFocusableElements; function getFocusableElements(options) {
    const parent = _queryOne(options?.root || getDefaultRoot());
    if (typeof parent.querySelectorAll !== "function") {
        return [];
    }
    const byTabIndex = {};
    for (const element of parent.querySelectorAll(FOCUSABLE_SELECTOR)) {
        const { tabIndex } = element;
        if ((options?.tabbable && tabIndex < 0) || !isNodeDisplayed(element)) {
            continue;
        }
        if (!byTabIndex[tabIndex]) {
            byTabIndex[tabIndex] = [];
        }
        byTabIndex[tabIndex].push(element);
    }
    const withTabIndexZero = byTabIndex[0] || [];
    delete byTabIndex[0];
    return [...$values(byTabIndex).flat(), ...withTabIndexZero];
}

/**
 * Returns the next focusable element after the current active element if it is
 * contained in the given parent.
 *
 * @see {@link getFocusableElements}
 * @param {FocusableOptions} [options]
 * @returns {Element | null}
 * @example
 *  getPreviousFocusableElement();
 */
__exports.getNextFocusableElement = getNextFocusableElement; function getNextFocusableElement(options) {
    const parent = _queryOne(options?.root || getDefaultRoot());
    const focusableEls = getFocusableElements({ ...options, parent });
    const index = focusableEls.indexOf(getActiveElement(parent));
    return focusableEls[index + 1] || null;
}

/**
 * Returns the parent `<iframe>` of a given node (if any).
 *
 * @param {Node} node
 * @returns {HTMLIFrameElement | null}
 */
__exports.getParentFrame = getParentFrame; function getParentFrame(node) {
    const doc = getDocument(node);
    if (!doc) {
        return null;
    }
    const view = doc.defaultView;
    if (view !== view.parent) {
        for (const iframe of view.parent.document.getElementsByTagName("iframe")) {
            if (iframe.contentWindow === view) {
                return iframe;
            }
        }
    }
    return null;
}

/**
 * Returns the previous focusable element before the current active element if it is
 * contained in the given parent.
 *
 * @see {@link getFocusableElements}
 * @param {FocusableOptions} [options]
 * @returns {Element | null}
 * @example
 *  getPreviousFocusableElement();
 */
__exports.getPreviousFocusableElement = getPreviousFocusableElement; function getPreviousFocusableElement(options) {
    const parent = _queryOne(options?.root || getDefaultRoot());
    const focusableEls = getFocusableElements({ ...options, parent });
    const index = focusableEls.indexOf(getActiveElement(parent));
    return index < 0 ? focusableEls.at(-1) : focusableEls[index - 1] || null;
}

/**
 * Checks whether a target is displayed, meaning that it has an offset parent and
 * is contained in the current document.
 *
 * Note that it does not mean that the target is "visible" (it can still be hidden
 * by CSS properties such as `width`, `opacity`, `visiblity`, etc.).
 *
 * @param {Target} target
 * @returns {boolean}
 */
__exports.isDisplayed = isDisplayed; function isDisplayed(target) {
    return _guardedQueryAll(target, { displayed: true }).length > 0;
}

/**
 * Returns whether the given node is editable, meaning that it is an `":enabled"`
 * `<input>` or `<textarea>` {@link Element};
 *
 * Note: this does **NOT** support elements with `contenteditable="true"`.
 *
 * @param {Node} node
 * @returns {boolean}
 * @example
 *  isEditable(document.querySelector("input")); // true
 * @example
 *  isEditable(document.body); // false
 */
__exports.isEditable = isEditable; function isEditable(node) {
    return (
        isElement(node) &&
        !node.matches?.(":disabled") &&
        ["input", "textarea"].includes(getTag(node))
    );
}

/**
 * Returns whether an element is focusable. Focusable elements are either:
 * - `<a>` or `<area>` elements with an `href` attribute;
 * - *enabled* `<button>`, `<input>`, `<select>` and `<textarea>` elements;
 * - `<iframe>` elements;
 * - any element with its `contenteditable` attribute set to `"true"`.
 *
 * A focusable element must also not have a `tabIndex` property set to less than 0.
 *
 * @see {@link FOCUSABLE_SELECTOR}
 * @param {Target} target
 * @returns {boolean}
 */
__exports.isFocusable = isFocusable; function isFocusable(target) {
    return _guardedQueryAll(target, { focusable: true }).length > 0;
}

/**
 * Returns whether the given target is contained in the current root document.
 *
 * @param {Window | Node} target
 * @returns {boolean}
 * @example
 *  isInDOM(queryFirst("div")); // true
 * @example
 *  isInDOM(document.createElement("div")); // Not attached -> false
 */
__exports.isInDOM = isInDOM; function isInDOM(target) {
    return ensureElement(target)?.isConnected;
}

/**
 * Checks whether a target is *at least partially* visible in the current viewport.
 *
 * @param {Target} target
 * @returns {boolean}
 */
__exports.isInViewPort = isInViewPort; function isInViewPort(target) {
    return _guardedQueryAll(target, { viewPort: true }).length > 0;
}

/**
 * Returns whether an element is scrollable.
 *
 * @param {Target} target
 * @param {ScrollAxis} [axis]
 * @returns {boolean}
 */
__exports.isScrollable = isScrollable; function isScrollable(target, axis) {
    return _guardedQueryAll(target, { scrollable: axis }).length > 0;
}

/**
 * Checks whether a target is visible, meaning that it is "displayed" (see {@link isDisplayed}),
 * has a non-zero width and height, and is not hidden by "opacity" or "visibility"
 * CSS properties.
 *
 * Note that it does not account for:
 *  - the position of the target in the viewport (e.g. negative x/y coordinates)
 *  - the color of the target (e.g. transparent text with no background).
 *
 * @param {Target} target
 * @returns {boolean}
 */
__exports.isVisible = isVisible; function isVisible(target) {
    return _guardedQueryAll(target, { visible: true }).length > 0;
}

/**
 * Equivalent to the native `node.matches(selector)`, with a few differences:
 * - it can take any {@link Target} (strings, nodes and iterable of nodes);
 * - it supports custom pseudo-classes, such as ":contains" or ":visible".
 *
 * @param {Target} target
 * @param {string} selector
 * @returns {boolean}
 * @example
 *  matches("input[name=surname]", ":value(John)");
 * @example
 *  matches(buttonEl, ":contains(Submit)");
 */
__exports.matches = matches; function matches(target, selector) {
    return elementsMatch(_guardedQueryAll(target), selector);
}

/**
 * Listens for DOM mutations on a given target.
 *
 * This helper has 2 main advantages over directly calling the native MutationObserver:
 * - it ensures a single observer is created for a given target, even if multiple
 *  callbacks are registered;
 * - it keeps track of these observers, which allows to check whether an observer
 *  is still running while it should not, and to disconnect all running observers
 *  at once.
 *
 * @param {HTMLElement} target
 * @param {MutationCallback} callback
 */
__exports.observe = observe; function observe(target, callback) {
    if (observers.has(target)) {
        observers.get(target).callbacks.add(callback);
    } else {
        const callbacks = new Set([callback]);
        const observer = new MutationObserver((mutations, observer) => {
            for (const callback of callbacks) {
                callback(mutations, observer);
            }
        });
        observer.observe(target, {
            attributes: true,
            characterData: true,
            childList: true,
            subtree: true,
        });
        observers.set(target, { callbacks, observer });
    }

    return function disconnect() {
        if (!observers.has(target)) {
            return;
        }
        const { callbacks, observer } = observers.get(target);
        callbacks.delete(callback);
        if (!callbacks.size) {
            observer.disconnect();
            observers.delete(target);
        }
    };
}

/**
 * Returns a list of nodes matching the given {@link Target}.
 * This function can either be used as a **template literal tag** (only supports
 * string selector without options) or invoked the usual way.
 *
 * The target can be:
 * - a {@link Node} (or an iterable of nodes), or {@link Window} object;
 * - a {@link Document} object (which will be converted to its body);
 * - a string representing a *custom selector* (which will be queried in the `root` option);
 *
 * This function allows all string selectors supported by the native {@link Element.querySelector}
 * along with some additional custom pseudo-classes:
 *
 * - `:contains(text)`: matches nodes whose *text content* includes the given *text*.
 *      * The match is **partial** and **case-insensitive**;
 *      * Given *text* also supports regular expressions (e.g. `:contains(/^foo.+/)`).
 * - `:count`: return nodes if their count match the given *count*.
 *      If not matching, an error is thrown;
 * - `:displayed`: matches nodes that are "displayed" (see {@link isDisplayed});
 * - `:empty`: matches nodes that have an empty *content* (**value** or **inner text**);
 * - `:eq(n)`: matches the *nth* node (0-based index);
 * - `:first`: matches the first node matching the selector (regardless of its actual
 *  DOM siblings);
 * - `:focusable`: matches nodes that can be focused (see {@link isFocusable});
 * - `:hidden`: matches nodes that are **not** "visible" (see {@link isVisible});
 * - `:interactive`: matches nodes that are not affected by 'pointer-events: none'
 * - `:iframe`: matches nodes that are `<iframe>` elements, and returns their `body`
 *  if it is ready;
 * - `:last`: matches the last node matching the selector (regardless of its actual
 *  DOM siblings);
 * - `:selected`: matches nodes that are selected (e.g. `<option>` elements);
 * - `:shadow`: matches nodes that have shadow roots, and returns their shadow root;
 * - `:scrollable(axis)`: matches nodes that are scrollable (see {@link isScrollable});
 * - `:text(text)`: matches nodes whose *content* is strictly equal to the given *text*;
 *      * The match is **exact**, and **case-insensitive**;
 *      * Given *text* also supports regular expressions (e.g. `:text(/^foo.+/)`).
 * - `:value(value)`: matches nodes whose *value* is strictly equal to the given *value*;
 *      * The match is **partial**, and **case-insensitive**;
 *      * Given *value* also supports regular expressions (e.g. `:value(/^foo.+/)`).
 * - `:viewPort`: matches nodes that are contained in the current view port (see
 *  {@link isInViewPort});
 * - `:visible`: matches nodes that are "visible" (see {@link isVisible});
 *
 * An `options` object can be specified to filter[1] the results:
 * - `root`: the root node to query the selector in (defaults to the current fixture);
 * - any of the *custom pseudo-classes* can be given as an option, with the value
 *  being a boolean for standalone pseudo-classes (e.g. `{ empty: true }`), or a
 *  string for the others (e.g. `{ contains: "text" }`).
 *
 * [1] these filters (except for `count` and `root`) achieve the same result as
 *  using their homonym pseudo-classes on the final group of the given selector
 *  string (e.g. ```queryAll`ul > li:visible`;``` = ```queryAll("ul > li", { visible: true })```).
 *
 * @param {Target} target
 * @param {QueryOptions} [options]
 * @returns {Element[]}
 * @example
 *  // regular selectors
 *  queryAll`window`; // -> []
 *  queryAll`input#name`; // -> [input]
 *  queryAll`div`; // -> [div, div, ...]
 *  queryAll`ul > li`; // -> [li, li, ...]
 * @example
 *  // custom selectors
 *  queryAll`div:visible:contains(Lorem ipsum)`; // -> [div, div, ...]
 *  queryAll`div:visible:contains(${/^L\w+\si.*m$/})`; // -> [div, div, ...]
 *  queryAll`:focusable`; // -> [a, button, input, ...]
 *  queryAll`.o_iframe:iframe p`; // -> [p, p, ...] (inside iframe)
 *  queryAll`#editor:shadow div`; // -> [div, div, ...] (inside shadow DOM)
 * @example
 *  // with options
 *  queryAll(`div:first`, { count: 1 }); // -> [div]
 *  queryAll(`div`, { root: queryOne`iframe` }); // -> [div, div, ...]
 *  // the next 2 queries will return the same results
 *  queryAll(`button:visible`); // -> [button, button, ...]
 *  queryAll(`button`, { visible: true }); // -> [button, button, ...]
 */
__exports.queryAll = queryAll; function queryAll(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _guardedQueryAll(target, options);
}

/**
 * Performs a {@link queryAll} with the given arguments and returns a list of the
 * *attribute values* of the matching nodes.
 *
 * @param {Target} target
 * @param {string} attribute
 * @param {QueryOptions} [options]
 * @returns {string[]}
 */
__exports.queryAllAttributes = queryAllAttributes; function queryAllAttributes(target, attribute, options) {
    return _guardedQueryAll(target, options).map((node) => getNodeAttribute(node, attribute));
}

/**
 * Performs a {@link queryAll} with the given arguments and returns a list of the
 * *properties* of the matching nodes.
 *
 * @param {Target} target
 * @param {string} property
 * @param {QueryOptions} [options]
 * @returns {any[]}
 */
__exports.queryAllProperties = queryAllProperties; function queryAllProperties(target, property, options) {
    return _guardedQueryAll(target, options).map((node) => node[property]);
}

/**
 * Performs a {@link queryAll} with the given arguments and returns a list of the
 * {@link DOMRect} of the matching nodes.
 *
 * There are a few differences with the native {@link Element.getBoundingClientRect}:
 * - rects take their positions relative to the top window element (instead of their
 *  parent `<iframe>` if any);
 * - they can be trimmed to remove padding with the `trimPadding` option.
 *
 * @param {Target} target
 * @param {QueryOptions & QueryRectOptions} [options]
 * @returns {DOMRect[]}
 */
__exports.queryAllRects = queryAllRects; function queryAllRects(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _guardedQueryAll(target, options).map(getNodeRect);
}

/**
 * Performs a {@link queryAll} with the given arguments and returns a list of the
 * *texts* of the matching nodes.
 *
 * @param {Target} target
 * @param {QueryOptions & QueryTextOptions} [options]
 * @returns {string[]}
 */
__exports.queryAllTexts = queryAllTexts; function queryAllTexts(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _guardedQueryAll(target, options).map((node) => getNodeText(node, options));
}

/**
 * Performs a {@link queryAll} with the given arguments and returns a list of the
 * *values* of the matching nodes.
 *
 * @param {Target} target
 * @param {QueryOptions} [options]
 * @returns {NodeValue[]}
 */
__exports.queryAllValues = queryAllValues; function queryAllValues(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _guardedQueryAll(target, options).map(getNodeValue);
}

/**
 * Performs a {@link queryOne} with the given arguments, with a default 'first'
 * option, to ensure that *at least* one element is returned.
 *
 * 'first' can be overridden by 'last' or 'eq' if needed.
 *
 * @param {Target} target
 * @param {QueryOptions} [options]
 * @returns {Node}
 */
__exports.queryAny = queryAny; function queryAny(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _queryOne(target, ensureCount(options));
}

/**
 * Performs a {@link queryOne} with the given arguments and returns the value of
 * the given *attribute* of the matching node.
 *
 * @param {Target} target
 * @param {string} attribute
 * @param {QueryOptions} [options]
 * @returns {string | null}
 */
__exports.queryAttribute = queryAttribute; function queryAttribute(target, attribute, options) {
    return getNodeAttribute(_queryOne(target, options), attribute);
}

/**
 * Performs a {@link queryAll} with the given arguments and returns the first result
 * or `null`.
 *
 * @param {Target} target
 * @param {QueryOptions} options
 * @returns {Element | null}
 */
__exports.queryFirst = queryFirst; function queryFirst(target, options) {
    [target, options] = parseRawArgs(arguments);
    return _guardedQueryAll(target, options)[0] || null;
}

/**
 * Performs a {@link queryAll} with the given arguments, along with a forced `count: 1`
 * option to ensure only one node matches the given {@link Target}.
 *
 * The returned value is a single node instead of a list of nodes.
 *
 * @param {Target} target
 * @param {Omit<QueryOptions, "count">} [options]
 * @returns {Element}
 */
__exports.queryOne = queryOne; function queryOne(target, options) {
    [target, options] = parseRawArgs(arguments);
    if ($isInteger(options?.count)) {
        throw new HootDomError(
            `cannot call \`queryOne\` with 'count'=${options.count}: did you mean to use \`queryAll\`?`
        );
    }
    return _queryOne(target, options);
}

/**
 * Performs a {@link queryOne} with the given arguments and returns the {@link DOMRect}
 * of the matching node.
 *
 * There are a few differences with the native {@link Element.getBoundingClientRect}:
 * - rects take their positions relative to the top window element (instead of their
 *  parent `<iframe>` if any);
 * - they can be trimmed to remove padding with the `trimPadding` option.
 *
 * @param {Target} target
 * @param {QueryOptions & QueryRectOptions} [options]
 * @returns {DOMRect}
 */
__exports.queryRect = queryRect; function queryRect(target, options) {
    [target, options] = parseRawArgs(arguments);
    return getNodeRect(_queryOne(target, options), options);
}

/**
 * Performs a {@link queryOne} with the given arguments and returns the *text* of
 * the matching node.
 *
 * @param {Target} target
 * @param {QueryOptions & QueryTextOptions} [options]
 * @returns {string}
 */
__exports.queryText = queryText; function queryText(target, options) {
    [target, options] = parseRawArgs(arguments);
    return getNodeText(_queryOne(target, options), options);
}

/**
 * Performs a {@link queryOne} with the given arguments and returns the *value* of
 * the matching node.
 *
 * @param {Target} target
 * @param {QueryOptions} [options]
 * @returns {NodeValue}
 */
__exports.queryValue = queryValue; function queryValue(target, options) {
    [target, options] = parseRawArgs(arguments);
    return getNodeValue(_queryOne(target, options));
}

/**
 * Combination of {@link queryAll} and {@link waitUntil}: waits for a given target
 * to match elements in the DOM and returns the first matching node when it appears
 * (or immediately if it is already present).
 *
 * @see {@link queryAll}
 * @see {@link waitUntil}
 * @param {Target} target
 * @param {QueryOptions & WaitOptions} [options]
 * @returns {Promise<Element>}
 * @example
 *  const button = await waitFor(`button`);
 *  button.click();
 */
__exports.waitFor = waitFor; function waitFor(target, options) {
    [target, options] = parseRawArgs(arguments);
    return waitUntil(_waitForFirst.bind(null, target, options), {
        message: getWaitForMessage,
        ...options,
    });
}

/**
 * Opposite of {@link waitFor}: waits for a given target to disappear from the DOM
 * (resolves instantly if the selector is already missing).
 *
 * @see {@link waitFor}
 * @param {Target} target
 * @param {QueryOptions & WaitOptions} [options]
 * @returns {Promise<number>}
 * @example
 *  await waitForNone(`button`);
 */
__exports.waitForNone = waitForNone; function waitForNone(target, options) {
    [target, options] = parseRawArgs(arguments);
    return waitUntil(_waitForNone.bind(null, target, options), {
        message: getWaitForNoneMessage,
        ...options,
    });
}

return __exports;
});
;

/*********************************************************
*  Filepath: /web/static/lib/hoot-dom/helpers/events.js  *
*  Lines: 2950                                           *
*********************************************************/
odoo.define('@web/../lib/hoot-dom/helpers/events', ['@web/../lib/hoot-dom/hoot_dom_utils', '@web/../lib/hoot-dom/helpers/dom', '@web/../lib/hoot-dom/helpers/time'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { getColorHex, getTag, isFirefox, isInstanceOf, isIterable } = require("@web/../lib/hoot-dom/hoot_dom_utils");
const {
    getActiveElement,
    getDocument,
    getInteractiveNode,
    getNextFocusableElement,
    getNodeRect,
    getNodeValue,
    getParentFrame,
    getPreviousFocusableElement,
    getStyle,
    getWindow,
    isCheckable,
    isEditable,
    isEventTarget,
    isNode,
    isNodeFocusable,
    parseDimensions,
    parsePosition,
    queryAll,
    queryAny,
    setDimensions,
    toSelector,
} = require("@web/../lib/hoot-dom/helpers/dom");
const { microTick } = require("@web/../lib/hoot-dom/helpers/time");

/**
 * @typedef {Target | Promise<Target>} AsyncTarget
 *
 * @typedef {"auto" | "blur" | "enter" | "tab" | false} ConfirmAction
 *
 * @typedef {{
 *  dataTransfer?: DataTransfer;
 *  dropEffect: "none" | "copy" | "link" | "move";
 *  effectAllowed?: "none" | "copy" | "copyLink" | "copyMove" | "link" | "linkMove" | "move" | "all" | "uninitialized";
 *  files?: File[];
 *  items?: [string, string][];
 * }} DataTransferOptions
 *
 * @typedef {{
 *  cancel: (options?: EventOptions) => Promise<EventList>;
 *  drop: (to?: AsyncTarget | DragOptions, options?: DragOptions) => Promise<EventList>;
 *  moveTo: (to?: AsyncTarget | DragOptions, options?: DragOptions) => Promise<DragHelpers>;
 * }} DragHelpers
 *
 * @typedef {PointerOptions & DataTransferOptions} DragOptions
 *
 * @typedef {import("./dom").Position} Position
 *
 * @typedef {import("./dom").Dimensions} Dimensions
 *
 * @typedef {((ev: Event) => boolean) | EventType} EventListPredicate
 *
 * @typedef {{
 *  eventInit?: EventInit;
 * }} EventOptions generic event options
 *
 * @typedef {{
 *  clientX: number;
 *  clientY: number;
 *  pageX: number;
 *  pageY: number;
 *  screenX: number;
 *  screenY: number;
 * }} EventPosition
 *
 * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType
 *
 * @typedef {EventOptions & {
 *  confirm?: ConfirmAction;
 *  composition?: boolean;
 *  instantly?: boolean;
 * }} FillOptions
 *
 * @typedef {string | number | MaybeIterable<File>} InputValue
 *
 * @typedef {EventOptions & KeyboardEventInit} KeyboardOptions
 *
 * @typedef {string | string[]} KeyStrokes
 *
 * @typedef {EventOptions & QueryOptions & {
 *  button?: number,
 *  position?: Side | `${Side}-${Side}` | Position;
 *  relative?: boolean;
 * }} PointerOptions
 *
 * @typedef {import("./dom").QueryOptions} QueryOptions
 *
 * @typedef {EventOptions & QueryOptions & {
 *  force?: boolean;
 *  initiator?: "keyboard" | "scrollbar" | "wheel" | null;
 *  relative?: boolean;
 * }} ScrollOptions
 *
 * @typedef {EventOptions & {
 *  target: AsyncTarget;
 * }} SelectOptions
 *
 * @typedef {"bottom" | "left" | "right" | "top"} Side
 */

/**
 * @template [T=EventInit]
 * @typedef {T & {
 *  target: EventTarget;
 *  type: EventType;
 * }} FullEventInit
 */

/**
 * @template T
 * @typedef {T | Iterable<T>} MaybeIterable
 */

/**
 * @template [T=Node]
 * @typedef {import("./dom").Target<T>} Target
 */

//-----------------------------------------------------------------------------
// Global
//-----------------------------------------------------------------------------

const {
    AnimationEvent,
    ClipboardEvent,
    CompositionEvent,
    console: { dir: $dir, groupCollapsed: $groupCollapsed, groupEnd: $groupEnd, log: $log },
    DataTransfer,
    document,
    DragEvent,
    Error,
    ErrorEvent,
    Event,
    File,
    FocusEvent,
    HashChangeEvent,
    KeyboardEvent,
    Math: { ceil: $ceil, max: $max, min: $min },
    MouseEvent,
    Number: { isInteger: $isInteger, isNaN: $isNaN, parseFloat: $parseFloat },
    Object: {
        assign: $assign,
        create: $create,
        defineProperties: $defineProperties,
        values: $values,
    },
    PointerEvent,
    PromiseRejectionEvent,
    String,
    SubmitEvent,
    Touch,
    TouchEvent,
    TypeError,
    WheelEvent,
} = globalThis;
/** @type {Document["createRange"]} */
const $createRange = document.createRange.bind(document);
const $toString = Object.prototype.toString;

//-----------------------------------------------------------------------------
// Internal
//-----------------------------------------------------------------------------

/**
 * @param {Event} ev
 */
function cancelTrustedEvent(ev) {
    if (ev.isTrusted && runTime.eventsToIgnore.includes(ev.type)) {
        runTime.eventsToIgnore.splice(runTime.eventsToIgnore.indexOf(ev.type), 1);
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        ev.preventDefault();
    }
}

/**
 * @param {HTMLElement} target
 * @param {number} start
 * @param {number} end
 */
async function changeSelection(target, start, end) {
    if (!isNil(start) && !isNil(target.selectionStart)) {
        target.selectionStart = start;
    }
    if (!isNil(end) && !isNil(target.selectionEnd)) {
        target.selectionEnd = end;
    }
}

/**
 * @param {HTMLElement} target
 * @param {number} x
 */
function constrainScrollX(target, x) {
    let { offsetWidth, scrollWidth } = target;
    const document = getDocument(target);
    if (target === document || target === document.documentElement) {
        // <html> elements in iframes consider the width of the <iframe> element
        const iframe = getParentFrame(target);
        if (iframe) {
            ({ offsetWidth } = iframe);
        }
    }
    const maxScrollLeft = scrollWidth - offsetWidth;
    const { direction } = getStyle(target);
    const [min, max] = direction === "rtl" ? [-maxScrollLeft, 0] : [0, maxScrollLeft];
    return $min($max(x, min), max);
}

/**
 * @param {HTMLElement} target
 * @param {number} y
 */
function constrainScrollY(target, y) {
    let { offsetHeight, scrollHeight } = target;
    const document = getDocument(target);
    if (target === document || target === document.documentElement) {
        // <html> elements in iframes consider the height of the <iframe> element
        const iframe = getParentFrame(target);
        if (iframe) {
            ({ offsetHeight } = iframe);
        }
    }
    return $min($max(y, 0), scrollHeight - offsetHeight);
}

/**
 * @param {DataTransferOptions} options
 */
function createDataTransfer(options) {
    const dataTransfer = isInstanceOf(options?.dataTransfer, DataTransfer)
        ? options.dataTransfer
        : new DataTransfer();
    for (const file of options?.files || []) {
        if (!isInstanceOf(file, File)) {
            throw new TypeError(`'DataTransfer.files' list only accepts 'File' objects`);
        }
        dataTransfer.items.add(file);
    }
    for (const [data, type] of options?.items || []) {
        dataTransfer.items.add(data, type);
    }

    $defineProperties(dataTransfer, {
        dropEffect: { value: options?.dropEffect || "none", writable: true },
        effectAllowed: { value: options?.effectAllowed || "all", writable: true },
    });

    return dataTransfer;
}

/**
 * @param {HTMLInputElement | HTMLTextAreaElement} target
 */
function deleteSelection(target) {
    const { selectionStart, selectionEnd, value } = target;
    return value.slice(0, selectionStart) + value.slice(selectionEnd);
}

/**
 * @template {EventTarget} T
 * @param {{
 *  target: T;
 *  events: EventType[];
 *  additionalEvents?: EventType[];
 *  callback?: (target: T) => any;
 *  options?: EventInit;
 * }} params
 */
async function dispatchAndIgnore({ target, events, additionalEvents = [], callback, options }) {
    for (const eventType of [...events, ...additionalEvents]) {
        runTime.eventsToIgnore.push(eventType);
    }
    if (callback) {
        callback(target);
    }
    for (const eventType of events) {
        await _dispatch(target, eventType, options);
    }
}

/**
 *
 * @param {EventTarget} target
 * @param {EventType} eventType
 * @param {PointerEventInit} eventInit
 * @param {{
 *  mouse?: [EventType, MouseEventInit];
 *  touch?: [EventType, TouchEventInit];
 * }} additionalEvents
 */
async function dispatchPointerEvent(target, eventType, eventInit, { mouse, touch }) {
    const pointerEvent = await _dispatch(target, eventType, eventInit);
    let prevented = isPrevented(pointerEvent);
    if (hasTouch()) {
        if (touch && runTime.pointerDownTarget) {
            const [touchEventType, touchEventInit] = touch;
            await _dispatch(runTime.pointerDownTarget, touchEventType, touchEventInit || eventInit);
        }
    } else {
        if (mouse && !prevented) {
            const [mouseEventType, mouseEventInit] = mouse;
            const mouseEvent = await _dispatch(target, mouseEventType, mouseEventInit || eventInit);
            prevented = isPrevented(mouseEvent);
        }
    }
    return prevented;
}

/**
 * @param {Iterable<Event>} events
 * @param {EventType} eventType
 * @param {EventInit} eventInit
 */
async function dispatchRelatedEvents(events, eventType, eventInit) {
    for (const event of events) {
        if (!event.target || isPrevented(event)) {
            break;
        }
        await _dispatch(event.target, eventType, eventInit);
    }
}

/**
 * @template T
 * @param {MaybeIterable<T>} value
 * @returns {T[]}
 */
function ensureArray(value) {
    return isIterable(value) ? [...value] : [value];
}

function getCurrentEvents() {
    const eventType = currentEventTypes.at(-1);
    if (!eventType) {
        return [];
    }
    currentEvents[eventType] ||= [];
    return currentEvents[eventType];
}

function getDefaultRunTimeValue() {
    return {
        isComposing: false,

        // Data transfers
        /** @type {DataTransfer | null} */
        clipboardData: null,
        /** @type {DataTransfer | null} */
        dataTransfer: null,

        // Drag & drop
        canStartDrag: false,
        isDragging: false,
        lastDragOverCancelled: false,

        // Pointer
        clickCount: 0,
        key: null,
        /** @type {HTMLElement | null} */
        pointerDownTarget: null,
        pointerDownTimeout: 0,
        /** @type {HTMLElement | null} */
        pointerTarget: null,
        /** @type {EventPosition | {}} */
        position: {},
        /** @type {HTMLElement | null} */
        previousPointerDownTarget: null,
        /** @type {EventPosition | {}} */
        touchStartPosition: {},

        // File
        fileInput: null,

        // Buttons
        buttons: 0,

        // Modifier keys
        modifierKeys: {},

        /**
         * Ignored events ("select" by default since it is sometimes dispatched by
         * focusing an input).
         * @type {EventType[]}
         */
        eventsToIgnore: [],
    };
}

/**
 * Returns the list of nodes containing n2 (included) that do not contain n1.
 *
 * @param {Element} [el1]
 * @param {Element} [el2]
 */
function getDifferentParents(el1, el2) {
    if (!el1 && !el2) {
        // No given elements => no parents
        return [];
    } else if (!el1 && el2) {
        // No first element => only parents of second element
        [el1, el2] = [el2, el1];
    }
    const parents = [el2 || el1];
    while (parents[0].parentElement) {
        const parent = parents[0].parentElement;
        if (el2 && parent.contains(el1)) {
            break;
        }
        parents.unshift(parent);
    }
    return parents;
}

/**
 * @template {typeof Event} T
 * @param {EventType} eventType
 * @returns {[T, ((attrs: FullEventInit) => EventInit), number]}
 */
function getEventConstructor(eventType) {
    switch (eventType) {
        // Mouse events
        case "dblclick":
        case "mousedown":
        case "mouseup":
        case "mousemove":
        case "mouseover":
        case "mouseout":
            return [MouseEvent, mapMouseEvent, BUBBLES | CANCELABLE | VIEW];
        case "mouseenter":
        case "mouseleave":
            return [MouseEvent, mapMouseEvent, VIEW];

        // Pointer events
        case "auxclick":
        case "click":
        case "contextmenu":
        case "pointerdown":
        case "pointerup":
        case "pointermove":
        case "pointerover":
        case "pointerout":
            return [PointerEvent, mapPointerEvent, BUBBLES | CANCELABLE | VIEW];
        case "pointerenter":
        case "pointerleave":
        case "pointercancel":
            return [PointerEvent, mapPointerEvent, VIEW];

        // Focus events
        case "blur":
        case "focus":
            return [FocusEvent, mapEvent];
        case "focusin":
        case "focusout":
            return [FocusEvent, mapEvent, BUBBLES];

        // Clipboard events
        case "cut":
        case "copy":
        case "paste":
            return [ClipboardEvent, mapEvent, BUBBLES];

        // Keyboard events
        case "keydown":
        case "keyup":
            return [KeyboardEvent, mapKeyboardEvent, BUBBLES | CANCELABLE | VIEW];

        // Drag events
        case "drag":
        case "dragend":
        case "dragenter":
        case "dragstart":
        case "dragleave":
        case "dragover":
        case "drop":
            return [DragEvent, mapEvent, BUBBLES | CANCELABLE];

        // Input events
        case "beforeinput":
            return [InputEvent, mapInputEvent, BUBBLES | CANCELABLE | VIEW];
        case "input":
            return [InputEvent, mapInputEvent, BUBBLES | VIEW];

        // Composition events
        case "compositionstart":
        case "compositionend":
            return [CompositionEvent, mapEvent, BUBBLES];

        // Selection events
        case "select":
        case "selectionchange":
            return [Event, mapEvent, BUBBLES];

        // Touch events
        case "touchstart":
        case "touchend":
        case "touchmove":
            return [TouchEvent, mapTouchEvent, BUBBLES | CANCELABLE | VIEW];
        case "touchcancel":
            return [TouchEvent, mapTouchEvent, BUBBLES | VIEW];

        // Resize events
        case "resize":
            return [Event, mapEvent];

        // Submit events
        case "submit":
            return [SubmitEvent, mapEvent, BUBBLES | CANCELABLE];

        // Wheel events
        case "wheel":
            return [WheelEvent, mapWheelEvent, BUBBLES | VIEW];

        // Animation events
        case "animationcancel":
        case "animationend":
        case "animationiteration":
        case "animationstart": {
            return [AnimationEvent, mapEvent, BUBBLES | CANCELABLE];
        }

        // Error events
        case "error":
            return [ErrorEvent, mapEvent];
        case "unhandledrejection":
            return [PromiseRejectionEvent, mapEvent, CANCELABLE];

        // Unload events (BeforeUnloadEvent cannot be constructed)
        case "beforeunload":
            return [Event, mapEvent, CANCELABLE];
        case "unload":
            return [Event, mapEvent];

        // URL events
        case "hashchange":
            return [HashChangeEvent, mapEvent];

        // Default: base Event constructor
        default:
            return [Event, mapEvent, BUBBLES];
    }
}

/**
 * @param {Node} [a]
 * @param {Node} [b]
 */
function getFirstCommonParent(a, b) {
    if (!a || !b || a.ownerDocument !== b.ownerDocument) {
        return null;
    }

    const range = document.createRange();
    range.setStart(a, 0);
    range.setEnd(b, 0);

    if (range.collapsed) {
        // Re-arranges range if the first node comes after the second
        range.setStart(b, 0);
        range.setEnd(a, 0);
    }

    return range.commonAncestorContainer;
}

/**
 * Returns the interactive pointer target from a given element, unless the element
 * is falsy, or the 'interactive' option is set to `false`.
 *
 * If an 'originalTarget' is given, the helper will deliberately throw an error if
 * no interactive elements are found.
 *
 * @param {HTMLElement} element
 * @param {QueryOptions} options
 * @param {AsyncTarget} [originalTarget]
 */
function getPointerTarget(element, options, originalTarget) {
    if (!element || options?.interactive === false) {
        return element;
    }
    const interactiveElement = getInteractiveNode(element);
    if (!interactiveElement && originalTarget) {
        queryAny(originalTarget, { ...options, interactive: true }); // Will throw if no elements are found
    }
    return interactiveElement;
}

/**
 * @param {HTMLElement} element
 * @param {PointerOptions} [options]
 */
function getPosition(element, options) {
    const { position, relative } = options || {};
    const isString = typeof position === "string";
    const [posX, posY] = parsePosition(position);

    if (!isString && !relative && !$isNaN(posX) && !$isNaN(posY)) {
        // Absolute position
        return toEventPosition(posX, posY, position);
    }

    const { x, y, width, height } = getNodeRect(element);
    let clientX = x;
    let clientY = y;

    if (isString) {
        const positions = position.split("-");

        // X position
        if (positions.includes("left")) {
            clientX -= 1;
        } else if (positions.includes("right")) {
            clientX += $ceil(width) + 1;
        } else {
            clientX += width / 2;
        }

        // Y position
        if (positions.includes("top")) {
            clientY -= 1;
        } else if (positions.includes("bottom")) {
            clientY += $ceil(height) + 1;
        } else {
            clientY += height / 2;
        }
    } else {
        // X position
        if ($isNaN(posX)) {
            clientX += width / 2;
        } else {
            if (relative) {
                clientX += posX || 0;
            } else {
                clientX = posX || 0;
            }
        }

        // Y position
        if ($isNaN(posY)) {
            clientY += height / 2;
        } else {
            if (relative) {
                clientY += posY || 0;
            } else {
                clientY = posY || 0;
            }
        }
    }

    return toEventPosition(clientX, clientY, position);
}

/**
 * @param {HTMLInputElement | HTMLTextAreaElement} target
 */
function getStringSelection(target) {
    return (
        $isInteger(target.selectionStart) &&
        $isInteger(target.selectionEnd) &&
        [target.selectionStart, target.selectionEnd].join(",")
    );
}

/**
 * @param {Node} node
 * @param {...string} tagNames
 */
function hasTagName(node, ...tagNames) {
    return tagNames.includes(getTag(node));
}

function hasTouch() {
    return (
        globalThis.ontouchstart !== undefined || globalThis.matchMedia("(pointer:coarse)").matches
    );
}

/**
 * @param {Position | null} position
 */
function isDifferentPosition(position) {
    if (!runTime.position || !position) {
        return runTime.position !== position;
    }
    for (const key in position) {
        if (runTime.position[key] !== position[key]) {
            return true;
        }
    }
    return false;
}

/**
 * @param {unknown} object
 */
function isDictionary(object) {
    return $toString.call(object) === "[object Object]";
}

/**
 * @param {unknown} value
 */
function isNil(value) {
    return value === null || value === undefined;
}

/**
 * @param {Event} event
 */
function isPrevented(event) {
    return event && event.defaultPrevented;
}

/**
 * @param {KeyStrokes} keyStrokes
 * @param {KeyboardEventInit} [options]
 * @returns {KeyboardEventInit}
 */
function parseKeyStrokes(keyStrokes, options) {
    return (isIterable(keyStrokes) ? [...keyStrokes] : [keyStrokes]).map((key) => {
        const lower = key.toLowerCase();
        return {
            ...options,
            key: lower.length === 1 ? key : KEY_ALIASES[lower] || key,
        };
    });
}

/**
 * Redirects all 'submit' events to explicit network requests.
 *
 * This allows the `mockFetch` helper to take control over submit requests.
 *
 * @param {SubmitEvent} ev
 */
function redirectSubmit(ev) {
    if (isPrevented(ev)) {
        return;
    }

    ev.preventDefault();

    /** @type {HTMLFormElement} */
    const form = ev.target;

    globalThis.fetch(form.action, {
        method: form.method,
        body: new FormData(form, ev.submitter),
    });
}

/**
 * @param {PointerEventInit} eventInit
 * @param {boolean} toggle
 */
function registerButton(eventInit, toggle) {
    let value = 0;
    switch (eventInit.button) {
        case btn.LEFT: {
            // Main button (left button)
            value = 1;
            break;
        }
        case btn.MIDDLE: {
            // Auxiliary button (middle button)
            value = 4;
            break;
        }
        case btn.RIGHT: {
            // Secondary button (right button)
            value = 2;
            break;
        }
        case btn.BACK: {
            // Fourth button (Browser Back)
            value = 8;
            break;
        }
        case btn.FORWARD: {
            // Fifth button (Browser Forward)
            value = 16;
            break;
        }
    }

    runTime.buttons = $max(runTime.buttons + (toggle ? value : -value), 0);
}

/**
 * @param {Event} ev
 */
function registerFileInput({ target }) {
    const actualTarget = target.shadowRoot ? target.shadowRoot.activeElement : target;
    if (getTag(actualTarget) === "input" && actualTarget.type === "file") {
        runTime.fileInput = actualTarget;
    } else {
        runTime.fileInput = null;
    }
}

/**
 * @param {EventTarget} target
 * @param {string} initialValue
 * @param {ConfirmAction} confirmAction
 */
async function registerForChange(target, initialValue, confirmAction) {
    function dispatchChange() {
        return target.value !== initialValue && _dispatch(target, "change");
    }

    confirmAction &&= confirmAction.toLowerCase();
    if (confirmAction === "auto") {
        confirmAction = getTag(target) === "input" ? "enter" : "blur";
    }
    if (getTag(target) === "input") {
        changeTargetListeners.push(
            on(target, "keydown", (ev) => {
                if (isPrevented(ev) || ev.key !== "Enter") {
                    return;
                }
                removeChangeTargetListeners();
                afterNextDispatch = dispatchChange;
            })
        );
    } else if (confirmAction === "enter") {
        throw new HootInteractionError(
            `"enter" confirm action is only supported on <input/> elements`
        );
    }

    changeTargetListeners.push(
        on(target, "blur", () => {
            removeChangeTargetListeners();
            dispatchChange();
        }),
        on(target, "change", removeChangeTargetListeners)
    );

    switch (confirmAction) {
        case "blur": {
            await _hover(
                getDocument(target).body,
                { position: { x: 0, y: 0 } },
                { originalTarget: target }
            );
            await _click();
            break;
        }
        case "enter": {
            await _press(target, { key: "Enter" });
            break;
        }
        case "tab": {
            await _press(target, { key: "Tab" });
            break;
        }
    }
}

/**
 * @param {KeyboardEventInit} eventInit
 * @param {boolean} toggle
 */
function registerSpecialKey(eventInit, toggle) {
    switch (eventInit.key) {
        case "Alt": {
            runTime.modifierKeys.altKey = toggle;
            break;
        }
        case "Control": {
            runTime.modifierKeys.ctrlKey = toggle;
            break;
        }
        case "Meta": {
            runTime.modifierKeys.metaKey = toggle;
            break;
        }
        case "Shift": {
            runTime.modifierKeys.shiftKey = toggle;
            break;
        }
    }
}

function removeChangeTargetListeners() {
    while (changeTargetListeners.length) {
        changeTargetListeners.pop()();
    }
}

/**
 * @param {HTMLElement | null} target
 * @param {QueryOptions} [options]
 */
function setPointerDownTarget(target, options) {
    if (runTime.pointerDownTarget) {
        runTime.previousPointerDownTarget = runTime.pointerDownTarget;
    }
    runTime.pointerDownTarget = getPointerTarget(target, options);
    runTime.canStartDrag = false;
}

/**
 * @param {string} type
 * @param {EventOptions} type
 */
function setupEvents(type, options) {
    currentEventTypes.push(type);
    $assign(currentEventInit, options?.eventInit);

    return function finalizeEvents() {
        for (const eventType in currentEventInit) {
            delete currentEventInit[eventType];
        }
        const events = new EventList(getCurrentEvents());
        const currentType = currentEventTypes.pop();
        delete currentEvents[currentType];
        if (!allowLogs) {
            return events;
        }
        const groupName = [
            `%c[${type}]%c dispatched`,
            `color: ${getColorHex("purple")}`,
            "",
            events.length,
            `events`,
        ];
        $groupCollapsed(...groupName);
        for (const event of events) {
            /** @type {string[]} */
            const colors = [getColorHex("text-report-html-tag")];

            const typeList = [event.type];
            if (event.key) {
                typeList.push(event.key);
            } else if (event.button) {
                typeList.push(event.button);
            }
            [...Array(typeList.length)].forEach(() =>
                colors.push(getColorHex("text-report-string"))
            );

            const typeString = typeList.map((t) => `%c"${t}"%c`).join(", ");
            let message = `%c${event.constructor.name}%c<${typeString}>`;
            if (event.__bubbleCount) {
                message += ` (${event.__bubbleCount})`;
            }
            const target = event.__originalTarget || event.target;
            if (isNode(target)) {
                const targetParts = toSelector(target, { object: true });
                colors.push(getColorHex("text-report-html-tag"));
                if (targetParts.id) {
                    colors.push(getColorHex("text-report-html-id"));
                }
                if (targetParts.class) {
                    colors.push(getColorHex("text-report-html-class"));
                }
                const targetString = $values(targetParts)
                    .map((part) => `%c${part}%c`)
                    .join("");
                message += ` @${targetString}`;
            }
            const messageColors = colors.flatMap((color) => [
                `color: ${color}; font-weight: normal`,
                "",
            ]);

            $groupCollapsed(message, ...messageColors);
            $dir(event);
            $log(target);
            $groupEnd();
        }
        $groupEnd();

        return events;
    };
}

/**
 * @param {number} clientX
 * @param {number} clientY
 * @param {Partial<EventPosition>} [position]
 */
function toEventPosition(clientX, clientY, position) {
    clientX ||= 0;
    clientY ||= 0;
    return {
        clientX,
        clientY,
        pageX: position?.pageX ?? clientX,
        pageY: position?.pageY ?? clientY,
        screenX: position?.screenX ?? clientX,
        screenY: position?.screenY ?? clientY,
    };
}

/**
 * @param {EventTarget} target
 * @param {PointerEventInit} pointerInit
 */
async function triggerClick(target, pointerInit) {
    if (target.disabled) {
        return;
    }
    const eventType = (pointerInit.button ?? 0) === btn.LEFT ? "click" : "auxclick";
    const clickEvent = await _dispatch(target, eventType, pointerInit);
    if (isPrevented(clickEvent)) {
        return;
    }
    if (isFirefox()) {
        // Thanks Firefox
        switch (getTag(target)) {
            case "label": {
                /**
                 * @firefox
                 * Special action: label 'Click'
                 *  On: unprevented 'click' on a <label/>
                 *  Do: triggers a 'click' event on the first <input/> descendant
                 */
                target = target.control;
                if (target) {
                    await triggerClick(target, pointerInit);
                }
                break;
            }
            case "option": {
                /**
                 * @firefox
                 * Special action: option 'Click'
                 *  On: unprevented 'click' on an <option/>
                 *  Do: triggers a 'change' event on the parent <select/>
                 */
                const parent = target.parentElement;
                if (parent && getTag(parent) === "select") {
                    await _dispatch(parent, "change");
                }
                break;
            }
        }
    }
}

/**
 * @param {EventTarget} target
 * @param {DragEventInit} eventInit
 */
async function triggerDrag(target, eventInit) {
    await _dispatch(target, "drag", eventInit);
    // Only "dragover" being prevented is taken into account for "drop" events
    const dragOverEvent = await _dispatch(target, "dragover", eventInit);
    return isPrevented(dragOverEvent);
}

/**
 * @param {EventTarget} target
 */
async function triggerFocus(target) {
    const previous = getActiveElement(target);
    if (previous === target) {
        return;
    }
    if (previous !== target.ownerDocument.body) {
        await dispatchAndIgnore({
            target: previous,
            events: ["blur", "focusout"],
            callback: (el) => el.blur(),
            options: { relatedTarget: target },
        });
    }
    if (isNodeFocusable(target)) {
        const previousSelection = getStringSelection(target);
        await dispatchAndIgnore({
            target,
            events: ["focus", "focusin"],
            additionalEvents: ["select"],
            callback: (el) => el.focus(),
            options: { relatedTarget: previous },
        });
        if (previousSelection && previousSelection === getStringSelection(target)) {
            changeSelection(target, target.value.length, target.value.length);
        }
    }
}

/**
 * @param {EventTarget} target
 * @param {FillOptions} [options]
 */
async function _clear(target, options) {
    // Inputs and text areas
    const initialValue = target.value;

    // Simulates 2 key presses:
    // - Control + A: selects all the text
    // - Backspace: deletes the text
    fullClear = true;
    await _press(target, { ctrlKey: true, key: "a" });
    await _press(target, { key: "Backspace" });
    fullClear = false;

    await registerForChange(target, initialValue, options?.confirm);
}

/**
 * @param {PointerOptions} [options]
 */
async function _click(options) {
    await _pointerDown(options);
    await _pointerUp(options);
}

/**
 * @template {EventType} T
 * @template {HTMLBodyElementEventMap[T]} I
 * @param {EventTarget} target
 * @param {T} type
 * @param {Partial<I> | { eventInit: Record<T, Partial<I>> }} [eventInit]
 * @returns {Promise<I>}
 */
async function _dispatch(target, type, eventInit) {
    eventInit = { ...eventInit, ...currentEventInit[type] };
    for (const key in eventInit) {
        if (key in DEPRECATED_EVENT_PROPERTIES) {
            throw new HootInteractionError(
                `cannot dispatch "${type}" event: property "${key}" is deprecated, use "${DEPRECATED_EVENT_PROPERTIES[key]}" instead`
            );
        }
    }

    const [Constructor, processParams, flags] = getEventConstructor(type);
    const params = processParams({
        composed: true,
        ...eventInit,
        target,
        type,
    });
    if (flags & BUBBLES) {
        params.bubbles = true;
    }
    if (flags & CANCELABLE) {
        params.cancelable = true;
    }
    if (flags & VIEW) {
        params.view ||= getWindow(target);
    }
    const event = new Constructor(type, params);

    target.dispatchEvent(event);
    await Promise.resolve();

    getCurrentEvents().push(event);

    if (afterNextDispatch) {
        const callback = afterNextDispatch;
        afterNextDispatch = null;
        await microTick().then(callback);
    }

    return event;
}

/**
 * @param {EventTarget} target
 * @param {InputValue} value
 * @param {FillOptions} [options]
 */
async function _fill(target, value, options) {
    const initialValue = target.value;

    if (getTag(target) === "input") {
        switch (target.type) {
            case "color": {
                target.value = String(value);
                await _dispatch(target, "input");
                await _dispatch(target, "change");
                return;
            }
            case "file": {
                const files = ensureArray(value);
                if (files.length > 1 && !target.multiple) {
                    throw new HootInteractionError(
                        `input[type="file"] does not support multiple files`
                    );
                }
                target.files = createDataTransfer({ files }).files;

                await _dispatch(target, "change");
                return;
            }
            case "range": {
                const numberValue = $parseFloat(value);
                if ($isNaN(numberValue)) {
                    throw new TypeError(`input[type="range"] only accept 'number' values`);
                }

                target.value = String(numberValue);
                await _dispatch(target, "input");
                await _dispatch(target, "change");
                return;
            }
        }
    }

    if (options?.instantly) {
        // Simulates filling the clipboard with the value (can be from external source)
        globalThis.navigator.clipboard.writeText(value).catch();
        await _press(target, { ctrlKey: true, key: "v" });
    } else {
        if (options?.composition) {
            runTime.isComposing = true;
            // Simulates the start of a composition
            await _dispatch(target, "compositionstart");
        }
        for (const char of String(value)) {
            const key = char.toLowerCase();
            await _press(target, { key, shiftKey: key !== char });
        }
        if (options?.composition) {
            runTime.isComposing = false;
            // Simulates the end of a composition
            await _dispatch(target, "compositionend");
        }
    }

    await registerForChange(target, initialValue, options?.confirm);
}

/**
 * @param {EventTarget | null} target
 * @param {PointerOptions | null} options
 * @param {{ implicit?: boolean, originalTarget: AsyncTarget }} hoverOptions
 */
async function _hover(target, options, hoverOptions) {
    const pointerTarget = getPointerTarget(target, options, hoverOptions.originalTarget);
    const position = target && getPosition(target, options);

    const previousPT = runTime.pointerTarget;
    const previousPosition = runTime.position;

    const isDifferentTarget = previousPT !== pointerTarget;

    if (hoverOptions?.implicit && !isDifferentTarget && !isDifferentPosition(position)) {
        // Implicit hover: do not perform hover if the pointer target is the same
        // and the position didn't change.
        return;
    }
    if (runTime.canStartDrag) {
        /**
         * Special action: drag start
         *  On: unprevented 'pointerdown' on a draggable element (DESKTOP ONLY)
         *  Do: triggers a 'dragstart' event
         */
        const dragStartEvent = await _dispatch(previousPT, "dragstart", {
            dataTransfer: runTime.dataTransfer,
        });

        runTime.isDragging = !isPrevented(dragStartEvent);
        runTime.canStartDrag = false;
    }

    runTime.pointerTarget = pointerTarget;
    runTime.position = position;

    if (
        isDifferentTarget &&
        previousPT &&
        (!pointerTarget || !previousPT.contains(pointerTarget))
    ) {
        // Leaves previous target
        const leaveEventInit = {
            ...previousPosition,
            relatedTarget: pointerTarget,
            button: options?.button || 0,
        };

        if (runTime.isDragging) {
            // If dragging, only drag events are triggered
            const leaveEventInitWithDT = { ...leaveEventInit, dataTransfer: runTime.dataTransfer };
            runTime.lastDragOverCancelled = await triggerDrag(previousPT, leaveEventInitWithDT);
            await _dispatch(previousPT, "dragleave", leaveEventInitWithDT);
        } else {
            // Regular case: pointer events are triggered
            await dispatchPointerEvent(previousPT, "pointermove", leaveEventInit, {
                mouse: ["mousemove"],
                touch: ["touchmove"],
            });
            await dispatchPointerEvent(previousPT, "pointerout", leaveEventInit, {
                mouse: ["mouseout"],
            });
            const leaveEvents = await Promise.all(
                getDifferentParents(pointerTarget, previousPT).map((element) =>
                    _dispatch(element, "pointerleave", leaveEventInit)
                )
            );
            if (!hasTouch()) {
                await dispatchRelatedEvents(leaveEvents, "mouseleave", leaveEventInit);
            }
        }
    }

    if (!pointerTarget) {
        return;
    }

    const enterEventInit = {
        ...runTime.position,
        relatedTarget: previousPT,
        button: options?.button || 0,
    };
    if (runTime.isDragging) {
        // If dragging, only drag events are triggered
        const enterEventInitWithDT = { ...enterEventInit, dataTransfer: runTime.dataTransfer };
        runTime.lastDragOverCancelled = false;
        if (isDifferentTarget) {
            const dragEnterEvent = await _dispatch(
                pointerTarget,
                "dragenter",
                enterEventInitWithDT
            );
            runTime.lastDragOverCancelled = isPrevented(dragEnterEvent);
        }
        runTime.lastDragOverCancelled ||= await triggerDrag(pointerTarget, enterEventInitWithDT);
    } else {
        // Regular case: pointer events are triggered
        if (isDifferentTarget) {
            await dispatchPointerEvent(pointerTarget, "pointerover", enterEventInit, {
                mouse: ["mouseover"],
            });
            const enterEvents = await Promise.all(
                getDifferentParents(previousPT, pointerTarget).map((element) =>
                    _dispatch(element, "pointerenter", enterEventInit)
                )
            );
            if (!hasTouch()) {
                await dispatchRelatedEvents(enterEvents, "mouseenter", enterEventInit);
            }
        }
        await dispatchPointerEvent(pointerTarget, "pointermove", enterEventInit, {
            mouse: ["mousemove"],
            touch: ["touchmove"],
        });
    }
}

/**
 * @param {EventTarget} target
 * @param {KeyboardEventInit} eventInit
 */
async function _keyDown(target, eventInit) {
    eventInit = { ...eventInit, ...currentEventInit.keydown };
    registerSpecialKey(eventInit, true);

    const repeat =
        typeof eventInit.repeat === "boolean" ? eventInit.repeat : runTime.key === eventInit.key;
    runTime.key = eventInit.key;
    const keyDownEvent = await _dispatch(target, "keydown", { ...eventInit, repeat });

    if (isPrevented(keyDownEvent)) {
        return;
    }

    /**
     * @param {string} toInsert
     * @param {string} type
     */
    function insertValue(toInsert, type) {
        const { selectionStart, selectionEnd, value } = target;
        inputData = toInsert;
        inputType = type;
        if (isNil(selectionStart) && isNil(selectionEnd)) {
            nextValue += toInsert;
        } else {
            nextValue = value.slice(0, selectionStart) + toInsert + value.slice(selectionEnd);
            if (selectionStart === selectionEnd) {
                nextSelectionStart = nextSelectionEnd = selectionStart + 1;
            }
        }
    }

    const { ctrlKey, key, shiftKey } = keyDownEvent;
    const initialValue = target.value;
    let inputData = null;
    let inputType = null;
    let nextSelectionEnd = null;
    let nextSelectionStart = null;
    let nextValue = initialValue;
    let triggerSelect = false;

    if (isEditable(target)) {
        switch (key) {
            case "ArrowDown":
            case "ArrowLeft":
            case "ArrowUp":
            case "ArrowRight": {
                const { selectionStart, selectionEnd, value } = target;
                if (isNil(selectionStart) || isNil(selectionEnd)) {
                    break;
                }
                const start = key === "ArrowLeft" || key === "ArrowUp";
                let selectionTarget;
                if (ctrlKey) {
                    // Move to the start/end of the line
                    selectionTarget = start ? 0 : value.length;
                } else {
                    // Move the cursor left or right
                    selectionTarget = start ? selectionStart - 1 : selectionEnd + 1;
                }
                nextSelectionStart = nextSelectionEnd = $max(
                    $min(selectionTarget, value.length),
                    0
                );
                triggerSelect = shiftKey;
                break;
            }
            case "Backspace": {
                const { selectionStart, selectionEnd, value } = target;
                if (fullClear) {
                    // Remove all characters
                    nextValue = "";
                } else if (isNil(selectionStart) || isNil(selectionEnd)) {
                    // Remove last character
                    nextValue = value.slice(0, -1);
                } else if (selectionStart === selectionEnd) {
                    // Remove previous character from target value
                    nextValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);
                } else {
                    // Remove current selection from target value
                    nextValue = deleteSelection(target);
                }
                inputType = "deleteContentBackward";
                break;
            }
            case "Delete": {
                const { selectionStart, selectionEnd, value } = target;
                if (fullClear) {
                    // Remove all characters
                    nextValue = "";
                } else if (isNil(selectionStart) || isNil(selectionEnd)) {
                    // Remove first character
                    nextValue = value.slice(1);
                } else if (selectionStart === selectionEnd) {
                    // Remove next character from target value
                    nextValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);
                } else {
                    // Remove current selection from target value
                    nextValue = deleteSelection(target);
                }
                inputType = "deleteContentForward";
                break;
            }
            case "Enter": {
                if (target.tagName === "TEXTAREA") {
                    // Insert new line
                    insertValue("\n", "insertLineBreak");
                }
                break;
            }
            default: {
                if (key.length === 1 && !ctrlKey) {
                    // Character coming from the keystroke
                    // ! TODO: Doesn't work with non-roman locales
                    insertValue(
                        shiftKey ? key.toUpperCase() : key.toLowerCase(),
                        runTime.isComposing ? "insertCompositionText" : "insertText"
                    );
                }
            }
        }
    }

    switch (key) {
        case "a": {
            if (ctrlKey) {
                // Select all
                if (isEditable(target)) {
                    nextSelectionStart = 0;
                    nextSelectionEnd = target.value.length;
                    triggerSelect = true;
                } else {
                    const selection = globalThis.getSelection();
                    const range = $createRange();
                    range.selectNodeContents(target);
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            break;
        }
        /**
         * Special action: copy
         *  On: unprevented 'Control + c' keydown
         *  Do: copy current selection to clipboard
         */
        case "c": {
            if (ctrlKey) {
                // Get selection from window
                const text = globalThis.getSelection().toString();
                globalThis.navigator.clipboard.writeText(text).catch();

                runTime.clipboardData = createDataTransfer(eventInit);
                await _dispatch(target, "copy", { clipboardData: runTime.clipboardData });
            }
            break;
        }
        case "Enter": {
            const tag = getTag(target);
            const parentForm = target.closest("form");
            if (parentForm && target.type !== "button") {
                /**
                 * Special action: <form> 'Enter'
                 *  On: unprevented 'Enter' keydown on any element that
                 *      is not a <button type="button"/> in a form element
                 *  Do: triggers a 'submit' event on the form
                 */
                await _dispatch(parentForm, "submit");
            } else if (
                !keyDownEvent.repeat &&
                (tag === "a" || tag === "button" || (tag === "input" && target.type === "button"))
            ) {
                /**
                 * Special action: <a>, <button> or <input type="button"> 'Enter'
                 *  On: unprevented and unrepeated 'Enter' keydown on mentioned elements
                 *  Do: triggers a 'click' event on the element
                 */
                await _dispatch(target, "click", { button: btn.LEFT });
            }
            break;
        }
        case "Escape": {
            runTime.dataTransfer = null;
            runTime.isDragging = false;
            break;
        }
        /**
         * Special action: shift focus
         *  On: unprevented 'Tab' keydown
         *  Do: focus next (or previous with 'Shift') focusable element
         */
        case "Tab": {
            const next = shiftKey
                ? getPreviousFocusableElement({ tabbable: true })
                : getNextFocusableElement({ tabbable: true });
            if (next) {
                await triggerFocus(next);
            }
            break;
        }
        /**
         * Special action: paste
         *  On: unprevented 'Control + v' keydown on editable element
         *  Do: paste current clipboard content to current element
         */
        case "v": {
            if (ctrlKey && isEditable(target)) {
                // Set target value (if possible)
                try {
                    nextValue = await globalThis.navigator.clipboard.readText();
                } catch {
                    // Ignore clipboard errors
                }
                inputType = "insertFromPaste";

                await _dispatch(target, "paste", {
                    clipboardData: runTime.clipboardData || createDataTransfer(eventInit),
                });
                runTime.clipboardData = null;
            }
            break;
        }
        /**
         * Special action: cut
         *  On: unprevented 'Control + x' keydown on editable element
         *  Do: cut current selection to clipboard and remove selection
         */
        case "x": {
            if (ctrlKey && isEditable(target)) {
                // Get selection from window
                const text = globalThis.getSelection().toString();
                globalThis.navigator.clipboard.writeText(text).catch();

                nextValue = deleteSelection(target);
                inputType = "deleteByCut";

                runTime.clipboardData = createDataTransfer(eventInit);
                await _dispatch(target, "cut", { clipboardData: runTime.clipboardData });
            }
            break;
        }
    }

    if (initialValue !== nextValue) {
        target.value = nextValue;
        const inputEventInit = {
            data: inputData,
            inputType,
        };
        const beforeInputEvent = await _dispatch(target, "beforeinput", inputEventInit);
        if (!isPrevented(beforeInputEvent)) {
            await _dispatch(target, "input", inputEventInit);
        }
    }
    changeSelection(target, nextSelectionStart, nextSelectionEnd);
    if (triggerSelect) {
        await dispatchAndIgnore({
            target,
            events: ["select"],
        });
    }
}

/**
 * @param {EventTarget} target
 * @param {KeyboardEventInit} eventInit
 */
async function _keyUp(target, eventInit) {
    eventInit = { ...eventInit, ...currentEventInit.keyup };
    await _dispatch(target, "keyup", eventInit);

    runTime.key = null;
    registerSpecialKey(eventInit, false);

    if (eventInit.key === " " && getTag(target) === "input" && target.type === "checkbox") {
        /**
         * Special action: input[type=checkbox] 'Space'
         *  On: unprevented ' ' keydown on an <input type="checkbox"/>
         *  Do: triggers a 'click' event on the input
         */
        await triggerClick(target, { button: btn.LEFT });
    }
}

/**
 * @param {DragOptions} [options]
 */
async function _pointerDown(options) {
    setPointerDownTarget(runTime.pointerTarget, options);

    if (options?.dataTransfer || options?.files || options?.items) {
        runTime.dataTransfer = createDataTransfer(options);
    }

    const pointerDownTarget = runTime.pointerDownTarget;
    const eventInit = {
        ...runTime.position,
        ...currentEventInit.pointerdown,
        button: options?.button || btn.LEFT,
    };

    registerButton(eventInit, true);

    if (pointerDownTarget !== runTime.previousPointerDownTarget) {
        runTime.clickCount = 0;
    }

    runTime.touchStartPosition = { ...runTime.position };
    runTime.touchStartTimeOffset = globalThis.Date.now();
    const prevented = await dispatchPointerEvent(pointerDownTarget, "pointerdown", eventInit, {
        mouse: !pointerDownTarget.disabled && [
            "mousedown",
            { ...eventInit, detail: runTime.clickCount + 1 },
        ],
        touch: ["touchstart"],
    });

    if (prevented) {
        return;
    }

    // Focus the element (if focusable)
    await triggerFocus(pointerDownTarget);

    if (
        eventInit.button === btn.LEFT &&
        !hasTouch() &&
        (pointerDownTarget.draggable || runTime.dataTransfer)
    ) {
        runTime.canStartDrag = true;
    } else if (eventInit.button === btn.RIGHT) {
        /**
         * Special action: context menu
         *  On: unprevented 'pointerdown' with right click and its related
         *      event on an element
         *  Do: triggers a 'contextmenu' event
         */
        await _dispatch(pointerDownTarget, "contextmenu", eventInit);
    }
}

/**
 * @param {PointerOptions} [options]
 */
async function _pointerUp(options) {
    const target = runTime.pointerTarget;
    const isLongTap = globalThis.Date.now() - runTime.touchStartTimeOffset > LONG_TAP_DELAY;
    const pointerDownTarget = runTime.pointerDownTarget;
    const pointerUpTarget = getPointerTarget(target, options);
    const eventInit = {
        ...runTime.position,
        ...currentEventInit.pointerup,
        button: options?.button || btn.LEFT,
    };

    registerButton(eventInit, false);

    if (runTime.isDragging) {
        // If dragging, only drag events are triggered
        const eventInitWithDT = { ...eventInit, dataTransfer: runTime.dataTransfer };
        runTime.dataTransfer = null;
        runTime.isDragging = false;
        if (runTime.lastDragOverCancelled) {
            /**
             * Special action: drop
             * - On: pointer up after a prevented 'dragover' or 'dragenter'
             * - Do: triggers a 'drop' event on the target
             */
            await _dispatch(pointerUpTarget, "drop", eventInitWithDT);
        }

        await _dispatch(pointerUpTarget, "dragend", eventInitWithDT);
        return;
    }

    const mouseEventInit = {
        ...eventInit,
        detail: runTime.clickCount + 1,
    };
    await dispatchPointerEvent(pointerUpTarget, "pointerup", eventInit, {
        mouse: !pointerUpTarget.disabled && ["mouseup", mouseEventInit],
        touch: ["touchend"],
    });

    const touchStartPosition = runTime.touchStartPosition;
    runTime.touchStartPosition = {};

    if (hasTouch() && (isDifferentPosition(touchStartPosition) || isLongTap)) {
        // No further event is triggered:
        // there was a swiping motion since the "touchstart" event
        // or a long press was detected.
        return;
    }

    let clickTarget;
    if (hasTouch()) {
        clickTarget = pointerDownTarget === pointerUpTarget && pointerUpTarget;
    } else {
        clickTarget = getFirstCommonParent(pointerUpTarget, pointerDownTarget);
    }
    if (clickTarget) {
        await triggerClick(clickTarget, mouseEventInit);
        if (mouseEventInit.button === btn.LEFT) {
            runTime.clickCount++;
            if (!hasTouch() && runTime.clickCount % 2 === 0) {
                await _dispatch(clickTarget, "dblclick", mouseEventInit);
            }
        }
    }

    setPointerDownTarget(null, options);
    if (runTime.pointerDownTimeout) {
        globalThis.clearTimeout(runTime.pointerDownTimeout);
    }
    runTime.pointerDownTimeout = globalThis.setTimeout(() => {
        // Use `globalThis.setTimeout` to potentially make use of the mock timeouts
        // since the events run in the same temporal context as the tests
        runTime.clickCount = 0;
        runTime.pointerDownTimeout = 0;
    }, DOUBLE_CLICK_DELAY);
}

/**
 * @param {EventTarget} target
 * @param {KeyboardEventInit} eventInit
 */
async function _press(target, eventInit) {
    await _keyDown(target, eventInit);
    await _keyUp(target, eventInit);
}

/**
 * @param {EventTarget} target
 * @param {string | number | (string | number)[]} value
 */
async function _select(target, value) {
    const values = ensureArray(value).map(String);
    let found = false;
    for (const option of target.options) {
        option.selected = values.includes(option.value);
        found ||= option.selected;
    }
    if (!value) {
        target.selectedIndex = -1;
    } else if (!found) {
        throw new HootInteractionError(
            `error when calling \`select()\`: no option found with value "${values.join(", ")}"`
        );
    }
    await _dispatch(target, "change");
}

class HootInteractionError extends Error {
    name = "HootInteractionError";
}

const btn = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    BACK: 3,
    FORWARD: 4,
};
const CAPTURE = { capture: true };
const DEPRECATED_EVENT_PROPERTIES = {
    keyCode: "key",
    which: "key",
};
const DEPRECATED_EVENTS = {
    keypress: "keydown",
    mousewheel: "wheel",
};
const DOUBLE_CLICK_DELAY = 500;

/**
 * Ignore certain trusted events (dispatched by `focus()`, `scroll()`, etc.)
 * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}
 */
const GLOBAL_TRUSTED_EVENTS_CANCELERS = [
    ["blur", cancelTrustedEvent, CAPTURE],
    ["focus", cancelTrustedEvent, CAPTURE],
    ["focusin", cancelTrustedEvent, CAPTURE],
    ["focusout", cancelTrustedEvent, CAPTURE],
    ["scroll", cancelTrustedEvent, CAPTURE],
    ["scrollend", cancelTrustedEvent, CAPTURE],
    ["select", cancelTrustedEvent, CAPTURE],
];
/**
 * Register file input on click & focus events
 * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}
 */
const GLOBAL_FILE_INPUT_REGISTERERS = [
    ["click", registerFileInput, CAPTURE],
    ["focus", registerFileInput, CAPTURE],
];
/**
 * Redirect events to other features
 * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}
 */
const GLOBAL_SUBMIT_FORWARDERS = [["submit", redirectSubmit]];

const KEY_ALIASES = {
    // case insensitive aliases
    alt: "Alt",
    arrowdown: "ArrowDown",
    arrowleft: "ArrowLeft",
    arrowright: "ArrowRight",
    arrowup: "ArrowUp",
    backspace: "Backspace",
    control: "Control",
    delete: "Delete",
    enter: "Enter",
    escape: "Escape",
    meta: "Meta",
    shift: "Shift",
    tab: "Tab",

    // Other aliases
    caps: "Shift",
    cmd: "Meta",
    command: "Meta",
    ctrl: "Control",
    del: "Delete",
    down: "ArrowDown",
    esc: "Escape",
    left: "ArrowLeft",
    right: "ArrowRight",
    space: " ",
    up: "ArrowUp",
    win: "Meta",
};
const LONG_TAP_DELAY = 500;

/** @type {Record<string, Event[]>} */
const currentEvents = $create(null);
/** @type {Record<EventType, EventInit>} */
const currentEventInit = $create(null);
/** @type {string[]} */
const currentEventTypes = [];
/** @type {(() => Promise<void>) | null} */
let afterNextDispatch = null;
let allowLogs = false;
let fullClear = false;

// Keyboard global variables
const changeTargetListeners = [];

// Other global variables
const runTime = getDefaultRunTimeValue();

//-----------------------------------------------------------------------------
// Event init attributes mappers
//-----------------------------------------------------------------------------

const BUBBLES = 0b1;
const CANCELABLE = 0b10;
const VIEW = 0b100;

// Generic mappers
// ---------------

/**
 * - does not bubble
 * - cannot be canceled
 * @param {FullEventInit} eventInit
 */
function mapEvent(eventInit) {
    return eventInit;
}

// Pointer, mouse & wheel event mappers
// ------------------------------------

/**
 * @param {FullEventInit<MouseEventInit>} eventInit
 */
function mapMouseEvent(eventInit) {
    return {
        button: -1,
        buttons: runTime.buttons,
        clientX: eventInit.clientX ?? eventInit.pageX ?? eventInit.screenX ?? 0,
        clientY: eventInit.clientY ?? eventInit.pageY ?? eventInit.screenY ?? 0,
        ...runTime.modifierKeys,
        ...eventInit,
    };
}

/**
 * @param {FullEventInit<PointerEventInit>} eventInit
 */
function mapPointerEvent(eventInit) {
    return {
        ...mapMouseEvent(eventInit),
        button: btn.LEFT,
        isPrimary: eventInit?.btn ? eventInit.btn === btn.LEFT : true,
        pointerId: 1,
        pointerType: hasTouch() ? "touch" : "mouse",
        ...eventInit,
    };
}

/**
 * @param {FullEventInit<WheelEventInit>} eventInit
 */
function mapWheelEvent(eventInit) {
    return {
        ...mapMouseEvent(eventInit),
        button: btn.LEFT,
        ...eventInit,
    };
}

// Touch event mappers
// -------------------

/**
 * @param {FullEventInit<TouchEventInit>} eventInit
 */
function mapTouchEvent(eventInit) {
    const touches = eventInit.targetTouches ||
        eventInit.touches || [new Touch({ identifier: 0, ...eventInit })];
    return {
        ...eventInit,
        changedTouches: eventInit.changedTouches || touches,
        target: eventInit.target,
        targetTouches: eventInit.targetTouches || touches,
        touches: eventInit.touches || (eventInit.type === "touchend" ? [] : touches),
    };
}

// Keyboard & input event mappers
// ------------------------------

/**
 * @param {FullEventInit<InputEventInit>} eventInit
 */
function mapInputEvent(eventInit) {
    return {
        data: null,
        isComposing: !!runTime.isComposing,
        ...eventInit,
    };
}

/**
 * @param {FullEventInit<KeyboardEventInit>} eventInit
 */
function mapKeyboardEvent(eventInit) {
    return {
        isComposing: !!runTime.isComposing,
        ...runTime.modifierKeys,
        ...eventInit,
    };
}

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * Ensures that the given {@link AsyncTarget} is checked.
 *
 * If it is not checked, a click is simulated on the input.
 * If the input is still not checked after the click, an error is thrown.
 *
 * @see {@link click}
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  check("input[type=checkbox]"); // Checks the first <input> checkbox element
 */
__exports.check = check; async function check(target, options) {
    const finalizeEvents = setupEvents("check", options);
    const element = queryAny(await target, options);
    if (!isCheckable(element)) {
        throw new HootInteractionError(
            `cannot call \`check()\`: target should be a checkbox or radio input`
        );
    }

    const checkTarget = getTag(element) === "label" ? element.control : element;
    if (!checkTarget.checked) {
        await _hover(element, options, { implicit: true, originalTarget: target });
        await _click(options);

        if (!checkTarget.checked) {
            throw new HootInteractionError(
                `error when calling \`check()\`: target is not checked after interaction`
            );
        }
    }

    return finalizeEvents();
}

__exports.cleanupEvents = cleanupEvents; function cleanupEvents() {
    if (runTime.pointerDownTimeout) {
        globalThis.clearTimeout(runTime.pointerDownTimeout);
    }

    removeChangeTargetListeners();

    // Runtime global variables
    $assign(runTime, getDefaultRunTimeValue());
}

/**
 * Clears the **value** of the current **active element**.
 *
 * This is done using the following sequence:
 * - pressing "Control" + "A" to select the whole value;
 * - pressing "Backspace" to delete the value;
 * - (optional) triggering a "change" event by pressing "Enter".
 *
 * @param {FillOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  clear(); // Clears the value of the current active element
 */
__exports.clear = clear; async function clear(options) {
    const finalizeEvents = setupEvents("clear", options);
    const element = getActiveElement();

    if (!hasTagName(element, "select") && !isEditable(element)) {
        throw new HootInteractionError(
            `cannot call \`clear()\`: target should be editable or a <select> element`
        );
    }

    if (isEditable(element)) {
        await _clear(element, options);
    } else {
        // Selects
        await _select(element, "");
    }

    return finalizeEvents();
}

/**
 * Performs a click sequence on the given {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 *  - `pointerdown`
 *  - [desktop] `mousedown`
 *  - [touch] `touchstart`
 *  - [target is not active element] `blur`
 *  - [target is focusable] `focus`
 *  - `pointerup`
 *  - [desktop] `mouseup`
 *  - [touch] `touchend`
 *  - `click`
 *  - `dblclick` if click is not prevented & current click count is even
 *
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  click("button"); // Clicks on the first <button> element
 */
__exports.click = click; async function click(target, options) {
    const finalizeEvents = setupEvents("click", options);
    const element = queryAny(await target, options);

    await _hover(element, options, { implicit: true, originalTarget: target });
    await _click(options);

    return finalizeEvents();
}

/**
 * Performs two click sequences on the given {@link AsyncTarget}.
 *
 * @see {@link click}
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  dblclick("button"); // Double-clicks on the first <button> element
 */
__exports.dblclick = dblclick; async function dblclick(target, options) {
    const finalizeEvents = setupEvents("dblclick", options);
    const element = queryAny(await target, options);

    options = { ...options, button: btn.LEFT };
    await _hover(element, options, { implicit: true, originalTarget: target });
    await _click(options);
    await _click(options);

    return finalizeEvents();
}

/**
 * Disclaimer: avoid using this method; it is meant to support niche event sequences,
 * or as a temporary fix for unsupported use cases. Prefer using other 'hoot-dom'
 * helpers such as {@link click}, {@link press} or {@link edit}.
 *
 * Creates a new DOM {@link Event} of the given type and dispatches it on the given
 * {@link Target}.
 *
 * Note that this function is free of side-effects and does not trigger any other
 * event or special action. It also only supports standard DOM events, and will
 * crash when trying to dispatch a non-standard or deprecated event.
 *
 * @template {EventType} T
 * @template {HTMLBodyElementEventMap[T]} I
 * @param {EventTarget} target
 * @param {T} type
 * @param {Partial<I> | { eventInit: Record<T, Partial<I>> }} [eventInit]
 * @example
 *  await manuallyDispatchProgrammaticEvent("input", "paste"); // Dispatches a "paste" event on the given <input>
 * @returns {Promise<EventList>}
 */
__exports.dispatch = dispatch; async function dispatch(target, type, eventInit) {
    const finalizeEvents = setupEvents("dispatch");

    if (!isEventTarget(target)) {
        throw new HootInteractionError(
            `cannot dispatch "${type}" event: expected target to be an 'EventTarget', got: ${target}`
        );
    }
    if (type in DEPRECATED_EVENTS) {
        throw new HootInteractionError(
            `cannot dispatch "${type}" event: this event type is deprecated, use "${DEPRECATED_EVENTS[type]}" instead`
        );
    }
    if (type !== type.toLowerCase()) {
        throw new HootInteractionError(
            `cannot dispatch "${type}" event: this event type is either non-standard or deprecated`
        );
    }

    await _dispatch(target, type, eventInit);

    return finalizeEvents();
}

/**
 * Starts a drag sequence on the given {@link AsyncTarget}.
 *
 * Returns a set of helper functions to direct the sequence:
 * - `moveTo`: moves the pointer to the given target;
 * - `drop`: drops the dragged element on the given target (if any);
 * - `cancel`: cancels the drag sequence.
 *
 * @param {AsyncTarget} target
 * @param {DragOptions} [options]
 * @returns {Promise<DragHelpers>}
 * @example
 *  drag(".card:first").drop(".card:last"); // Drags the first card onto the last one
 * @example
 *  drag(".card:first").moveTo(".card:last").drop(); // Same as above
 * @example
 *  const { cancel, moveTo } = await drag(".card:first"); // Starts the drag sequence
 *  moveTo(".card:eq(3)"); // Moves the dragged card to the 4th card
 *  cancel(); // Cancels the drag sequence
 */
__exports.drag = drag; async function drag(target, options) {
    /**
     * @template T
     * @param {T} fn
     * @param {boolean} endDrag
     * @returns {T}
     */
    function expectIsDragging(fn, endDrag) {
        return {
            async [fn.name](...args) {
                if (dragEndReason) {
                    throw new HootInteractionError(
                        `cannot execute drag helper \`${fn.name}\`: drag sequence has been ended by \`${dragEndReason}\``
                    );
                }
                const result = await fn(...args);
                if (endDrag) {
                    dragEndReason = fn.name;
                }
                return result;
            },
        }[fn.name];
    }

    const cancel = expectIsDragging(
        /** @type {DragHelpers["cancel"]} */
        async function cancel(options) {
            const finalizeEvents = setupEvents("drag & drop: cancel", options);
            const bodyElement = getDocument(runTime.pointerTarget).body;

            // Reset buttons
            runTime.buttons = 0;

            await _press(bodyElement, { key: "Escape" });

            dragEvents.push(...finalizeEvents());

            return dragEvents;
        },
        true
    );

    const drop = expectIsDragging(
        /** @type {DragHelpers["drop"]} */
        async function drop(to, options) {
            if (to) {
                await moveTo(to, options);

                if (isDictionary(to)) {
                    options = to;
                }
            }

            const finalizeEvents = setupEvents("drag & drop: drop", options);

            await _pointerUp(options);

            dragEvents.push(...finalizeEvents());

            return dragEvents;
        },
        true
    );

    const moveTo = expectIsDragging(
        /** @type {DragHelpers["moveTo"]} */
        async function moveTo(to, options) {
            if (isDictionary(to)) {
                [to, options] = [null, to];
            }
            const finalizeEvents = setupEvents("drag & drop: move", options);

            const nextElement = to ? queryAny(await to, options) : runTime.pointerTarget;
            await _hover(nextElement, options, { originalTarget: to });

            dragEvents.push(...finalizeEvents());

            return dragHelpers;
        },
        false
    );

    const finalizeEvents = setupEvents("drag & drop: start", options);
    const dragHelpers = { cancel, drop, moveTo };
    const dragStartTarget = queryAny(await target, options);
    let dragEndReason = null;

    // Pointer down on main target
    await _hover(dragStartTarget, options, { implicit: true, originalTarget: target });
    await _pointerDown(options);

    const dragEvents = finalizeEvents();

    return dragHelpers;
}

/**
 * Combination of {@link clear} and {@link fill}:
 * - first, clears the input value (if any)
 * - then fills the input with the given value
 *
 * @see {@link clear}
 * @see {@link fill}
 * @param {InputValue} value
 * @param {FillOptions} options
 * @returns {Promise<EventList>}
 * @example
 *  fill("foo"); // Types "foo" in the active element
 *  edit("Hello World"); // Replaces "foo" by "Hello World"
 */
__exports.edit = edit; async function edit(value, options) {
    const finalizeEvents = setupEvents("edit", options);
    const element = getActiveElement();
    if (!isEditable(element)) {
        throw new HootInteractionError(`cannot call \`edit()\`: target should be editable`);
    }

    if (getNodeValue(element)) {
        await _clear(element);
    }
    await _fill(element, value, options);

    return finalizeEvents();
}

/**
 * @param {boolean} toggle
 */
__exports.enableEventLogs = enableEventLogs; function enableEventLogs(toggle) {
    allowLogs = toggle ?? true;
}

/**
 * Fills the current **active element** with the given `value`. This helper is intended
 * for `<input>` and `<textarea>` elements, with the exception of `"checkbox"` and
 * `"radio"` types, which should be selected using the {@link check} helper.
 *
 * If the target is an editable input, its string `value` will be input one character
 * at a time, each generating its corresponding keyboard event sequence. This behavior
 * can be overriden by passing the `instantly` option, which will instead simulate
 * a `control` + `v` keyboard sequence, resulting in the whole text being pasted.
 *
 * Note that the given value is **appended** to the current value of the element.
 *
 * If the active element is a `<input type="file"/>`, the `value` should be a
 * `File`/list of `File` object(s).
 *
 * @param {InputValue} value
 * @param {FillOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  fill("Hello World"); // Types "Hello World" in the active element
 * @example
 *  fill("Hello World", { instantly: true }); // Pastes "Hello World" in the active element
 * @example
 *  fill(new File(["Hello World"], "hello.txt")); // Uploads a file named "hello.txt" with "Hello World" as content
 */
__exports.fill = fill; async function fill(value, options) {
    const finalizeEvents = setupEvents("fill", options);
    const element = getActiveElement();

    if (!isEditable(element)) {
        throw new HootInteractionError(`cannot call \`fill()\`: target should be editable`);
    }

    await _fill(element, value, options);

    return finalizeEvents();
}

/**
 * Performs a hover sequence on the given {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 *  - `pointerover`
 *  - [desktop] `mouseover`
 *  - `pointerenter`
 *  - [desktop] `mouseenter`
 *  - `pointermove`
 *  - [desktop] `mousemove`
 *  - [touch] `touchmove`
 *
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  hover("button"); // Hovers the first <button> element
 */
__exports.hover = hover; async function hover(target, options) {
    const finalizeEvents = setupEvents("hover", options);
    const element = queryAny(await target, options);

    await _hover(element, options, { originalTarget: target });

    return finalizeEvents();
}

/**
 * Performs a key down sequence on the current **active element**.
 *
 * The event sequence is as follows:
 *  - `keydown`
 *
 * Additional actions will be performed depending on the key pressed:
 * - `Tab`: focus next (or previous with `shift`) focusable element;
 * - `c`: copy current selection to clipboard;
 * - `v`: paste current clipboard content to current element;
 * - `Enter`: submit the form if the target is a `<button type="button">` or
 *  a `<form>` element, or trigger a `change` event on the target if it is
 *  an `<input>` element;
 * - `Space`: trigger a `click` event on the target if it is an `<input type="checkbox">`
 *  element.
 *
 * @param {KeyStrokes} keyStrokes
 * @param {KeyboardOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  keyDown(" "); // Space key
 */
__exports.keyDown = keyDown; async function keyDown(keyStrokes, options) {
    const finalizeEvents = setupEvents("keyDown", options);
    const eventInits = parseKeyStrokes(keyStrokes, options);
    for (const eventInit of eventInits) {
        await _keyDown(getActiveElement(), eventInit);
    }

    return finalizeEvents();
}

/**
 * Performs a key up sequence on the current **active element**.
 *
 * The event sequence is as follows:
 *  - `keyup`
 *
 * @param {KeyStrokes} keyStrokes
 * @param {KeyboardOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  keyUp("Enter");
 */
__exports.keyUp = keyUp; async function keyUp(keyStrokes, options) {
    const finalizeEvents = setupEvents("keyUp", options);
    const eventInits = parseKeyStrokes(keyStrokes, options);
    for (const eventInit of eventInits) {
        await _keyUp(getActiveElement(), eventInit);
    }

    return finalizeEvents();
}

/**
 * Performs a leave sequence on the current **window**.
 *
 * The event sequence is as follows:
 *  - `pointermove`
 *  - [desktop] `mousemove`
 *  - [touch] `touchmove`
 *  - `pointerout`
 *  - [desktop] `mouseout`
 *  - `pointerleave`
 *  - [desktop] `mouseleave`
 *
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  leave("button"); // Moves out of <button>
 */
__exports.leave = leave; async function leave(options) {
    const finalizeEvents = setupEvents("leave", options);

    await _hover(null, options, { originalTarget: window });

    return finalizeEvents();
}

/**
 * Performs a middle-click sequence on the given {@link AsyncTarget}.
 *
 * @see {@link click}
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  middleClick("button"); // Middle-clicks on the first <button> element
 */
__exports.middleClick = middleClick; async function middleClick(target, options) {
    const finalizeEvents = setupEvents("middleClick", options);
    const element = queryAny(await target, options);

    options = { ...options, button: btn.MIDDLE };
    await _hover(element, options, { implicit: true, originalTarget: target });
    await _click(options);

    return finalizeEvents();
}

/**
 * Shorthand helper to attach an event listener to the given {@link Target}, and
 * returning a function to remove the listener.
 *
 * @template {EventType} T
 * @param {Target<EventTarget>} target
 * @param {T} type
 * @param {(event: GlobalEventHandlersEventMap[T]) => any} listener
 * @param {boolean | AddEventListenerOptions} [options]
 * @returns {() => void}
 * @example
 *  const off = on("button", "click", onClick);
 *  after(off);
 */
__exports.on = on; function on(target, type, listener, options) {
    const targets = isEventTarget(target) ? [target] : queryAll(target);
    if (!targets.length) {
        throw new HootInteractionError(`expected at least 1 event target, got none`);
    }
    for (const eventTarget of targets) {
        eventTarget.addEventListener(type, listener, options);
    }

    return function off() {
        for (const eventTarget of targets) {
            eventTarget.removeEventListener(type, listener, options);
        }
    };
}

/**
 * Performs a pointer down on the given {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 *  - `pointerdown`
 *  - [desktop] `mousedown`
 *  - [touch] `touchstart`
 *  - [target is not active element] `blur`
 *  - [target is focusable] `focus`
 *
 * @param {AsyncTarget} target
 * @param {PointerOptions | DragOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  pointerDown("button"); // Focuses to the first <button> element
 */
__exports.pointerDown = pointerDown; async function pointerDown(target, options) {
    const finalizeEvents = setupEvents("pointerDown", options);
    const element = queryAny(await target, options);

    await _hover(element, options, { implicit: true, originalTarget: target });
    await _pointerDown(options);

    return finalizeEvents();
}

/**
 * Performs a pointer up on the given {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 * - `pointerup`
 * - [desktop] `mouseup`
 * - [touch] `touchend`
 *
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  pointerUp("body"); // Triggers a pointer up on the <body> element
 */
__exports.pointerUp = pointerUp; async function pointerUp(target, options) {
    const finalizeEvents = setupEvents("pointerUp", options);
    const element = queryAny(await target, options);

    await _hover(element, options, { implicit: true, originalTarget: target });
    await _pointerUp(options);

    return finalizeEvents();
}

/**
 * Performs a keyboard event sequence on the current **active element**.
 *
 * The event sequence is as follows:
 *  - `keydown`
 *  - `keyup`
 *
 * @param {KeyStrokes} keyStrokes
 * @param {KeyboardOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  pointerDown("button[type=submit]"); // Moves focus to <button>
 *  keyDown("Enter"); // Submits the form
 * @example
 *  keyDown("Shift+Tab"); // Focuses previous focusable element
 * @example
 *  keyDown(["ctrl", "v"]); // Pastes current clipboard content
 */
__exports.press = press; async function press(keyStrokes, options) {
    const finalizeEvents = setupEvents("press", options);
    const eventInits = parseKeyStrokes(keyStrokes, options);
    const activeElement = getActiveElement();

    for (const eventInit of eventInits) {
        await _keyDown(activeElement, eventInit);
    }
    for (const eventInit of eventInits.reverse()) {
        await _keyUp(activeElement, eventInit);
    }

    return finalizeEvents();
}

/**
 * Performs a resize event sequence on the current **window**.
 *
 * The event sequence is as follows:
 *  - `resize`
 *
 * The target will be resized to the given dimensions, enforced by `!important` style
 * attributes.
 *
 * @param {Dimensions} dimensions
 * @param {EventOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  resize("body", { width: 1000, height: 500 }); // Resizes <body> to 1000x500
 */
__exports.resize = resize; async function resize(dimensions, options) {
    const finalizeEvents = setupEvents("resize", options);
    const [width, height] = parseDimensions(dimensions);

    setDimensions(width, height);

    await _dispatch(getWindow(), "resize");

    return finalizeEvents();
}

/**
 * Performs a right-click sequence on the given {@link AsyncTarget}.
 *
 * @see {@link click}
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  rightClick("button"); // Middle-clicks on the first <button> element
 */
__exports.rightClick = rightClick; async function rightClick(target, options) {
    const finalizeEvents = setupEvents("rightClick", options);
    const element = queryAny(await target, options);

    options = { ...options, button: btn.RIGHT };
    await _hover(element, options, { implicit: true, originalTarget: target });
    await _click(options);

    return finalizeEvents();
}

/**
 * Performs a scroll event sequence on the given {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 *  - [desktop] `wheel`
 *  - `scroll`
 *
 * @param {AsyncTarget} target
 * @param {Position} position
 * @param {ScrollOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  scroll("body", { y: 0 }); // Scrolls to the top of <body>
 */
__exports.scroll = scroll; async function scroll(target, position, options) {
    const finalizeEvents = setupEvents("scroll", options);

    // Parse position and assign default options
    let [x, y] = parsePosition(position);
    options = {
        initiator: "wheel",
        scrollable: x && y ? "both" : x ? "x" : y ? "y" : true,
        ...options,
    };

    const { force, initiator, relative } = options;
    /** @type {ScrollToOptions} */
    const scrollTopOptions = {};
    const element = queryAny(await target, options);
    if (relative) {
        x += element.scrollLeft;
        y += element.scrollTop;
    }
    if (!$isNaN(x)) {
        const targetX = force ? x : constrainScrollX(element, x);
        if (targetX !== element.scrollLeft) {
            scrollTopOptions.left = targetX;
        }
    }
    if (!$isNaN(y)) {
        const targetY = force ? y : constrainScrollY(element, y);
        if (targetY !== element.scrollTop) {
            scrollTopOptions.top = targetY;
        }
    }
    const keys = [];
    if (initiator === "keyboard") {
        if (x < element.scrollLeft) {
            keys.push("ArrowRight");
        } else if (x > element.scrollLeft) {
            keys.push("ArrowLeft");
        }
        if (y < element.scrollTop) {
            keys.push("ArrowDown");
        } else if (y > element.scrollTop) {
            keys.push("ArrowUp");
        }
        await Promise.all(keys.map((key) => _keyDown(key)));
    } else if (!hasTouch() && initiator === "wheel") {
        /** @type {WheelEventInit} */
        const wheelEventInit = {};
        if (!$isNaN(x)) {
            wheelEventInit.deltaX = x - element.scrollLeft;
        }
        if (!$isNaN(y)) {
            wheelEventInit.deltaY = y - element.scrollTop;
        }
        await _dispatch(element, "wheel", wheelEventInit);
    }
    if (force || $values(scrollTopOptions).length) {
        await dispatchAndIgnore({
            target: element,
            events: ["scroll", "scrollend"],
            callback: (el) => el.scrollTo(scrollTopOptions),
        });
    }
    if (initiator === "keyboard") {
        await Promise.all(keys.map((key) => _keyUp(key)));
    }

    return finalizeEvents();
}

/**
 * Performs a selection event sequence on the current **active element**. This helper
 * is intended for `<select>` elements only.
 *
 * The event sequence is as follows:
 *  - `change`
 *
 * @param {string | number | (string | number)[]} value
 * @param {SelectOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  click("select[name=country]"); // Focuses <select> element
 *  select("belgium"); // Selects the <option value="belgium"> element
 */
__exports.select = select; async function select(value, options) {
    const finalizeEvents = setupEvents("select", options);
    const target = options?.target || getActiveElement();
    const element = queryAny(await target);

    if (!hasTagName(element, "select")) {
        throw new HootInteractionError(
            `cannot call \`select()\`: target should be a <select> element`
        );
    }

    if (options?.target) {
        await _hover(element, null, { implicit: true, originalTarget: target });
        await _pointerDown();
    }
    await _select(element, value);
    if (options?.target) {
        await _pointerUp();
    }

    return finalizeEvents();
}

/**
 * Gives the given {@link File} list to the current file input. This helper only
 * works if a file input has been previously interacted with (by clicking on it).
 *
 * @param {MaybeIterable<File>} files
 * @param {EventOptions} [options]
 * @returns {Promise<EventList>}
 */
__exports.setInputFiles = setInputFiles; async function setInputFiles(files, options) {
    if (!runTime.fileInput) {
        throw new HootInteractionError(
            `cannot call \`setInputFiles()\`: no file input has been interacted with`
        );
    }

    const finalizeEvents = setupEvents("setInputFiles", options);

    await _fill(runTime.fileInput, files, options);

    runTime.fileInput = null;

    return finalizeEvents();
}

/**
 * Sets the given value to the given "input[type=range]" {@link AsyncTarget}.
 *
 * The event sequence is as follows:
 *  - `pointerdown`
 *  - `input`
 *  - `change`
 *  - `pointerup`
 *
 * @param {AsyncTarget} target
 * @param {number} value
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 */
__exports.setInputRange = setInputRange; async function setInputRange(target, value, options) {
    const finalizeEvents = setupEvents("setInputRange", options);
    const element = queryAny(await target, options);

    await _hover(element, options, { implicit: true, originalTarget: target });
    await _pointerDown(options);
    await _fill(element, value, options);
    await _pointerUp(options);

    return finalizeEvents();
}

/**
 * @param {HTMLElement} target
 * @param {{
 *  allowSubmit?: boolean;
 *  allowTrustedEvents?: boolean;
 *  noFileInputRegistration?: boolean;
 * }} [options]
 */
__exports.setupEventActions = setupEventActions; function setupEventActions(target, options) {
    const eventHandlers = [];
    if (!options?.allowTrustedEvents) {
        eventHandlers.push(...GLOBAL_TRUSTED_EVENTS_CANCELERS);
    }
    if (!options?.noFileInputRegistration) {
        eventHandlers.push(...GLOBAL_FILE_INPUT_REGISTERERS);
    }
    if (!options?.allowSubmit) {
        eventHandlers.push(...GLOBAL_SUBMIT_FORWARDERS);
    }

    const view = getWindow(target);
    for (const [eventType, handler, options] of eventHandlers) {
        view.addEventListener(eventType, handler, options);
    }

    return function cleanupEventActions() {
        for (const [eventType, handler, options] of eventHandlers) {
            view.removeEventListener(eventType, handler, options);
        }
    };
}

/**
 * Ensures that the given {@link AsyncTarget} is unchecked.
 *
 * If it is checked, a click is triggered on the input.
 * If the input is still checked after the click, an error is thrown.
 *
 * @see {@link click}
 * @param {AsyncTarget} target
 * @param {PointerOptions} [options]
 * @returns {Promise<EventList>}
 * @example
 *  uncheck("input[type=checkbox]"); // Unchecks the first <input> checkbox element
 */
__exports.uncheck = uncheck; async function uncheck(target, options) {
    const finalizeEvents = setupEvents("uncheck", options);
    const element = queryAny(await target, options);
    if (!isCheckable(element)) {
        throw new HootInteractionError(
            `cannot call \`uncheck()\`: target should be a checkbox or radio input`
        );
    }

    const checkTarget = getTag(element) === "label" ? element.control : element;
    if (checkTarget.checked) {
        await _hover(element, options, { implicit: true, originalTarget: target });
        await _click(options);

        if (checkTarget.checked) {
            throw new HootInteractionError(
                `error when calling \`uncheck()\`: target is still checked after interaction`
            );
        }
    }

    return finalizeEvents();
}

/**
 * Triggers a "beforeunload" event on the current **window**.
 *
 * @param {EventOptions} [options]
 * @returns {Promise<EventList>}
 */
__exports.unload = unload; async function unload(options) {
    const finalizeEvents = setupEvents("unload", options);

    await _dispatch(getWindow(), "beforeunload");

    return finalizeEvents();
}

/** @extends {Array<Event>} */
const EventList = __exports.EventList = class EventList extends Array {
    constructor(...args) {
        super(...args.flat());
    }

    /**
     * @param {EventListPredicate} predicate
     */
    get(predicate) {
        return this.getAll(predicate)[0] || null;
    }

    /**
     * @param {EventListPredicate} predicate
     */
    getAll(predicate) {
        if (typeof predicate !== "function") {
            const type = predicate;
            predicate = function isSameType(ev) {
                return ev.type === type;
            };
        }
        return this.filter(predicate);
    }
}

return __exports;
});
;

/*******************************************************
*  Filepath: /web/static/lib/hoot-dom/helpers/time.js  *
*  Lines: 501                                          *
*******************************************************/
odoo.define('@web/../lib/hoot-dom/helpers/time', ['@web/../lib/hoot-dom/hoot_dom_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { isInstanceOf } = require("@web/../lib/hoot-dom/hoot_dom_utils");

/**
 * @typedef {{
 *  animationFrame?: boolean;
 *  blockTimers?: boolean;
 * }} AdvanceTimeOptions
 *
 * @typedef {{
 *  message?: string | () => string;
 *  timeout?: number;
 * }} WaitOptions
 */

//-----------------------------------------------------------------------------
// Global
//-----------------------------------------------------------------------------

const {
    cancelAnimationFrame,
    clearInterval,
    clearTimeout,
    Error,
    Math: { ceil: $ceil, floor: $floor, max: $max, min: $min },
    Number,
    performance,
    Promise,
    requestAnimationFrame,
    setInterval,
    setTimeout,
} = globalThis;
/** @type {Performance["now"]} */
const $performanceNow = performance.now.bind(performance);

//-----------------------------------------------------------------------------
// Internal
//-----------------------------------------------------------------------------

/**
 * @param {number} id
 */
function animationToId(id) {
    return ID_PREFIX.animation + String(id);
}

function getNextTimerValues() {
    /** @type {[number, () => any, string] | null} */
    let timerValues = null;
    for (const [internalId, [callback, init, delay]] of timers.entries()) {
        const timeout = init + delay;
        if (!timerValues || timeout < timerValues[0]) {
            timerValues = [timeout, callback, internalId];
        }
    }
    return timerValues;
}

/**
 * @param {string} id
 */
function idToAnimation(id) {
    return Number(id.slice(ID_PREFIX.animation.length));
}

/**
 * @param {string} id
 */
function idToInterval(id) {
    return Number(id.slice(ID_PREFIX.interval.length));
}

/**
 * @param {string} id
 */
function idToTimeout(id) {
    return Number(id.slice(ID_PREFIX.timeout.length));
}

/**
 * @param {number} id
 */
function intervalToId(id) {
    return ID_PREFIX.interval + String(id);
}

/**
 * Converts a given value to a **natural number** (or 0 if failing to do so).
 *
 * @param {unknown} value
 */
function parseNat(value) {
    return $max($floor(Number(value)), 0) || 0;
}

function now() {
    return (frozen ? 0 : $performanceNow()) + timeOffset;
}

/**
 * @param {number} id
 */
function timeoutToId(id) {
    return ID_PREFIX.timeout + String(id);
}

class HootTimingError extends Error {
    name = "HootTimingError";
}

const ID_PREFIX = {
    animation: "a_",
    interval: "i_",
    timeout: "t_",
};

/** @type {Map<string, [() => any, number, number]>} */
const timers = new Map();

let allowTimers = false;
let frozen = false;
let frameDelay = 1000 / 60;
let nextDummyId = 1;
let timeOffset = 0;

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * @param {number} [frameCount]
 * @param {AdvanceTimeOptions} [options]
 */
__exports.advanceFrame = advanceFrame; function advanceFrame(frameCount, options) {
    return advanceTime(frameDelay * parseNat(frameCount), options);
}

/**
 * Advances the current time by the given amount of milliseconds. This will
 * affect all timeouts, intervals, animations and date objects.
 *
 * It returns a promise resolved after all related callbacks have been executed.
 *
 * @param {number} ms
 * @param {AdvanceTimeOptions} [options]
 * @returns {Promise<number>} time consumed by timers (in ms).
 */
__exports.advanceTime = advanceTime; async function advanceTime(ms, options) {
    ms = parseNat(ms);

    if (options?.blockTimers) {
        allowTimers = false;
    }

    const targetTime = now() + ms;
    let remaining = ms;
    /** @type {ReturnType<typeof getNextTimerValues>} */
    let timerValues;
    while ((timerValues = getNextTimerValues()) && timerValues[0] <= targetTime) {
        const [timeout, handler, id] = timerValues;
        const diff = timeout - now();
        if (diff > 0) {
            timeOffset += $min(remaining, diff);
            remaining = $max(remaining - diff, 0);
        }
        if (timers.has(id)) {
            handler(timeout);
        }
    }

    if (remaining > 0) {
        timeOffset += remaining;
    }

    if (options?.animationFrame ?? true) {
        await animationFrame();
    }

    allowTimers = true;

    return ms;
}

/**
 * Returns a promise resolved after the next animation frame, typically allowing
 * Owl components to render.
 *
 * @returns {Promise<void>}
 */
__exports.animationFrame = animationFrame; function animationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => setTimeout(resolve)));
}

/**
 * Cancels all current timeouts, intervals and animations.
 */
__exports.cancelAllTimers = cancelAllTimers; function cancelAllTimers() {
    for (const id of timers.keys()) {
        if (id.startsWith(ID_PREFIX.animation)) {
            globalThis.cancelAnimationFrame(idToAnimation(id));
        } else if (id.startsWith(ID_PREFIX.interval)) {
            globalThis.clearInterval(idToInterval(id));
        } else if (id.startsWith(ID_PREFIX.timeout)) {
            globalThis.clearTimeout(idToTimeout(id));
        }
    }
}

__exports.cleanupTime = cleanupTime; function cleanupTime() {
    allowTimers = false;
    frozen = false;

    cancelAllTimers();

    // Wait for remaining async code to run
    return delay();
}

/**
 * Returns a promise resolved after a given amount of milliseconds (default to 0).
 *
 * @param {number} [duration]
 * @returns {Promise<void>}
 * @example
 *  await delay(1000); // waits for 1 second
 */
__exports.delay = delay; function delay(duration) {
    return new Promise((resolve) => setTimeout(resolve, duration));
}

__exports.freezeTime = freezeTime; function freezeTime() {
    frozen = true;
}

__exports.unfreezeTime = unfreezeTime; function unfreezeTime() {
    frozen = false;
}

__exports.getTimeOffset = getTimeOffset; function getTimeOffset() {
    return timeOffset;
}

__exports.isTimeFrozen = isTimeFrozen; function isTimeFrozen() {
    return frozen;
}

/**
 * Returns a promise resolved after the next microtask tick.
 *
 * @returns {Promise<void>}
 */
__exports.microTick = microTick; function microTick() {
    return new Promise(queueMicrotask);
}

/** @type {typeof cancelAnimationFrame} */
__exports.mockedCancelAnimationFrame = mockedCancelAnimationFrame; function mockedCancelAnimationFrame(handle) {
    if (!frozen) {
        cancelAnimationFrame(handle);
    }
    timers.delete(animationToId(handle));
}

/** @type {typeof clearInterval} */
__exports.mockedClearInterval = mockedClearInterval; function mockedClearInterval(intervalId) {
    if (!frozen) {
        clearInterval(intervalId);
    }
    timers.delete(intervalToId(intervalId));
}

/** @type {typeof clearTimeout} */
__exports.mockedClearTimeout = mockedClearTimeout; function mockedClearTimeout(timeoutId) {
    if (!frozen) {
        clearTimeout(timeoutId);
    }
    timers.delete(timeoutToId(timeoutId));
}

/** @type {typeof requestAnimationFrame} */
__exports.mockedRequestAnimationFrame = mockedRequestAnimationFrame; function mockedRequestAnimationFrame(callback) {
    if (!allowTimers) {
        return 0;
    }

    function handler() {
        mockedCancelAnimationFrame(handle);
        return callback(now());
    }

    const animationValues = [handler, now(), frameDelay];
    const handle = frozen ? nextDummyId++ : requestAnimationFrame(handler);
    const internalId = animationToId(handle);
    timers.set(internalId, animationValues);

    return handle;
}

/** @type {typeof setInterval} */
__exports.mockedSetInterval = mockedSetInterval; function mockedSetInterval(callback, ms, ...args) {
    if (!allowTimers) {
        return 0;
    }

    ms = parseNat(ms);

    function handler() {
        if (allowTimers) {
            intervalValues[1] = $max(now(), intervalValues[1] + ms);
        } else {
            mockedClearInterval(intervalId);
        }
        return callback(...args);
    }

    const intervalValues = [handler, now(), ms];
    const intervalId = frozen ? nextDummyId++ : setInterval(handler, ms);
    const internalId = intervalToId(intervalId);
    timers.set(internalId, intervalValues);

    return intervalId;
}

/** @type {typeof setTimeout} */
__exports.mockedSetTimeout = mockedSetTimeout; function mockedSetTimeout(callback, ms, ...args) {
    if (!allowTimers) {
        return 0;
    }

    ms = parseNat(ms);

    function handler() {
        mockedClearTimeout(timeoutId);
        return callback(...args);
    }

    const timeoutValues = [handler, now(), ms];
    const timeoutId = frozen ? nextDummyId++ : setTimeout(handler, ms);
    const internalId = timeoutToId(timeoutId);
    timers.set(internalId, timeoutValues);

    return timeoutId;
}

__exports.resetTimeOffset = resetTimeOffset; function resetTimeOffset() {
    timeOffset = 0;
}

/**
 * Calculates the amount of time needed to run all current timeouts, intervals and
 * animations, and then advances the current time by that amount.
 *
 * @see {@link advanceTime}
 * @param {AdvanceTimeOptions} [options]
 * @returns {Promise<number>} time consumed by timers (in ms).
 */
__exports.runAllTimers = runAllTimers; function runAllTimers(options) {
    if (!timers.size) {
        return 0;
    }

    const endts = $max(...[...timers.values()].map(([, init, delay]) => init + delay));
    return advanceTime($ceil(endts - now()), options);
}

/**
 * Sets the current frame rate (in fps) used by animation frames (default to 60fps).
 *
 * @param {number} frameRate
 */
__exports.setFrameRate = setFrameRate; function setFrameRate(frameRate) {
    frameRate = parseNat(frameRate);
    if (frameRate < 1 || frameRate > 1000) {
        throw new HootTimingError("frame rate must be an number between 1 and 1000");
    }
    frameDelay = 1000 / frameRate;
}

__exports.setupTime = setupTime; function setupTime() {
    allowTimers = true;
}

/**
 * Returns a promise resolved after the next task tick.
 *
 * @returns {Promise<void>}
 */
__exports.tick = tick; function tick() {
    return delay();
}

/**
 * Returns a promise fulfilled when the given `predicate` returns a truthy value,
 * with the value of the promise being the return value of the `predicate`.
 *
 * The `predicate` is run once initially, and then on each animation frame until
 * it succeeds or fail.
 *
 * The promise automatically rejects after a given `timeout` (defaults to 5 seconds).
 *
 * @template T
 * @param {(last: boolean) => T} predicate
 * @param {WaitOptions} [options]
 * @returns {Promise<T>}
 * @example
 *  await waitUntil(() => []); // -> []
 * @example
 *  const button = await waitUntil(() => queryOne("button:visible"));
 *  button.click();
 */
__exports.waitUntil = waitUntil; async function waitUntil(predicate, options) {
    await Promise.resolve();

    // Early check before running the loop
    const result = predicate(false);
    if (result) {
        return result;
    }

    const timeout = $floor(options?.timeout ?? 200);
    const maxFrameCount = $ceil(timeout / frameDelay);
    let frameCount = 0;
    let handle;
    return new Promise((resolve, reject) => {
        function runCheck() {
            const isLast = ++frameCount >= maxFrameCount;
            const result = predicate(isLast);
            if (result) {
                resolve(result);
            } else if (!isLast) {
                handle = requestAnimationFrame(runCheck);
            } else {
                let message =
                    options?.message || `'waitUntil' timed out after %timeout% milliseconds`;
                if (typeof message === "function") {
                    message = message();
                }
                if (isInstanceOf(message, Error)) {
                    reject(message);
                } else {
                    reject(new HootTimingError(message.replace("%timeout%", String(timeout))));
                }
            }
        }

        handle = requestAnimationFrame(runCheck);
    }).finally(() => {
        cancelAnimationFrame(handle);
    });
}

/**
 * Manually resolvable and rejectable promise. It introduces 2 new methods:
 *  - {@link reject} rejects the deferred with the given reason;
 *  - {@link resolve} resolves the deferred with the given value.
 *
 * @template [T=unknown]
 */
const Deferred = __exports.Deferred = class Deferred extends Promise {
    /** @type {typeof Promise.resolve<T>} */
    _resolve;
    /** @type {typeof Promise.reject<T>} */
    _reject;

    /**
     * @param {(resolve: (value?: T) => any, reject: (reason?: any) => any) => any} [executor]
     */
    constructor(executor) {
        let _resolve, _reject;

        super(function deferredResolver(resolve, reject) {
            _resolve = resolve;
            _reject = reject;
            executor?.(_resolve, _reject);
        });

        this._resolve = _resolve;
        this._reject = _reject;
    }

    /**
     * @param {any} [reason]
     */
    async reject(reason) {
        return this._reject(reason);
    }

    /**
     * @param {T} [value]
     */
    async resolve(value) {
        return this._resolve(value);
    }
}

return __exports;
});
;

/***************************************************
*  Filepath: /web/static/lib/hoot-dom/hoot-dom.js  *
*  Lines: 159                                      *
***************************************************/
odoo.define('@web/../lib/hoot-dom/hoot-dom', ['@web/../lib/hoot-dom/helpers/dom', '@web/../lib/hoot-dom/helpers/events', '@web/../lib/hoot-dom/helpers/time', '@web/../lib/hoot-dom/hoot_dom_utils'], function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=@odoo/hoot-dom default=false */

const dom = require("@web/../lib/hoot-dom/helpers/dom");
const events = require("@web/../lib/hoot-dom/helpers/events");
const time = require("@web/../lib/hoot-dom/helpers/time");
const { interactor } = require("@web/../lib/hoot-dom/hoot_dom_utils");

/**
 * @typedef {import("./helpers/dom").Dimensions} Dimensions
 * @typedef {import("./helpers/dom").FormatXmlOptions} FormatXmlOptions
 * @typedef {import("./helpers/dom").Position} Position
 * @typedef {import("./helpers/dom").QueryOptions} QueryOptions
 * @typedef {import("./helpers/dom").QueryRectOptions} QueryRectOptions
 * @typedef {import("./helpers/dom").QueryTextOptions} QueryTextOptions
 * @typedef {import("./helpers/dom").Target} Target
 *
 * @typedef {import("./helpers/events").DragHelpers} DragHelpers
 * @typedef {import("./helpers/events").DragOptions} DragOptions
 * @typedef {import("./helpers/events").EventType} EventType
 * @typedef {import("./helpers/events").FillOptions} FillOptions
 * @typedef {import("./helpers/events").InputValue} InputValue
 * @typedef {import("./helpers/events").KeyStrokes} KeyStrokes
 * @typedef {import("./helpers/events").PointerOptions} PointerOptions
 */

{const {
    formatXml,
    getActiveElement,
    getFocusableElements,
    getNextFocusableElement,
    getParentFrame,
    getPreviousFocusableElement,
    isDisplayed,
    isEditable,
    isFocusable,
    isInDOM,
    isInViewPort,
    isScrollable,
    isVisible,
    matches,
    queryAll,
    queryAllAttributes,
    queryAllProperties,
    queryAllRects,
    queryAllTexts,
    queryAllValues,
    queryAny,
    queryAttribute,
    queryFirst,
    queryOne,
    queryRect,
    queryText,
    queryValue,
} = require("@web/../lib/hoot-dom/helpers/dom");Object.assign(__exports, {
    formatXml, 
    getActiveElement, 
    getFocusableElements, 
    getNextFocusableElement, 
    getParentFrame, 
    getPreviousFocusableElement, 
    isDisplayed, 
    isEditable, 
    isFocusable, 
    isInDOM, 
    isInViewPort, 
    isScrollable, 
    isVisible, 
    matches, 
    queryAll, 
    queryAllAttributes, 
    queryAllProperties, 
    queryAllRects, 
    queryAllTexts, 
    queryAllValues, 
    queryAny, 
    queryAttribute, 
    queryFirst, 
    queryOne, 
    queryRect, 
    queryText, 
    queryValue, 
})};
{const { on } = require("@web/../lib/hoot-dom/helpers/events");Object.assign(__exports, { on })};
{const {
    animationFrame,
    cancelAllTimers,
    Deferred,
    delay,
    freezeTime,
    unfreezeTime,
    microTick,
    setFrameRate,
    tick,
    waitUntil,
} = require("@web/../lib/hoot-dom/helpers/time");Object.assign(__exports, {
    animationFrame, 
    cancelAllTimers, 
    Deferred, 
    delay, 
    freezeTime, 
    unfreezeTime, 
    microTick, 
    setFrameRate, 
    tick, 
    waitUntil, 
})};

//-----------------------------------------------------------------------------
// Interactors
//-----------------------------------------------------------------------------

// DOM
const observe = __exports.observe = interactor("query", dom.observe);
const waitFor = __exports.waitFor = interactor("query", dom.waitFor);
const waitForNone = __exports.waitForNone = interactor("query", dom.waitForNone);

// Events
const check = __exports.check = interactor("interaction", events.check);
const clear = __exports.clear = interactor("interaction", events.clear);
const click = __exports.click = interactor("interaction", events.click);
const dblclick = __exports.dblclick = interactor("interaction", events.dblclick);
const drag = __exports.drag = interactor("interaction", events.drag);
const edit = __exports.edit = interactor("interaction", events.edit);
const fill = __exports.fill = interactor("interaction", events.fill);
const hover = __exports.hover = interactor("interaction", events.hover);
const keyDown = __exports.keyDown = interactor("interaction", events.keyDown);
const keyUp = __exports.keyUp = interactor("interaction", events.keyUp);
const leave = __exports.leave = interactor("interaction", events.leave);
const manuallyDispatchProgrammaticEvent = __exports.manuallyDispatchProgrammaticEvent = interactor("interaction", events.dispatch);
const middleClick = __exports.middleClick = interactor("interaction", events.middleClick);
const pointerDown = __exports.pointerDown = interactor("interaction", events.pointerDown);
const pointerUp = __exports.pointerUp = interactor("interaction", events.pointerUp);
const press = __exports.press = interactor("interaction", events.press);
const resize = __exports.resize = interactor("interaction", events.resize);
const rightClick = __exports.rightClick = interactor("interaction", events.rightClick);
const scroll = __exports.scroll = interactor("interaction", events.scroll);
const select = __exports.select = interactor("interaction", events.select);
const setInputFiles = __exports.setInputFiles = interactor("interaction", events.setInputFiles);
const setInputRange = __exports.setInputRange = interactor("interaction", events.setInputRange);
const uncheck = __exports.uncheck = interactor("interaction", events.uncheck);
const unload = __exports.unload = interactor("interaction", events.unload);

// Time
const advanceFrame = __exports.advanceFrame = interactor("time", time.advanceFrame);
const advanceTime = __exports.advanceTime = interactor("time", time.advanceTime);
const runAllTimers = __exports.runAllTimers = interactor("time", time.runAllTimers);

// Debug
{const { exposeHelpers } = require("@web/../lib/hoot-dom/hoot_dom_utils");Object.assign(__exports, { exposeHelpers })};

return __exports;
});

odoo.define(`@odoo/hoot-dom`, ['@web/../lib/hoot-dom/hoot-dom'], function (require) {
                        return require('@web/../lib/hoot-dom/hoot-dom');
                        });
;

/*********************************************************
*  Filepath: /web/static/lib/hoot-dom/hoot_dom_utils.js  *
*  Lines: 434                                            *
*********************************************************/
odoo.define('@web/../lib/hoot-dom/hoot_dom_utils', [], function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

/**
 * @typedef {ArgumentPrimitive | `${ArgumentPrimitive}[]` | null} ArgumentType
 *
 * @typedef {"any"
 *  | "bigint"
 *  | "boolean"
 *  | "error"
 *  | "function"
 *  | "integer"
 *  | "node"
 *  | "number"
 *  | "object"
 *  | "regex"
 *  | "string"
 *  | "symbol"
 *  | "undefined"} ArgumentPrimitive
 *
 * @typedef {[string, string | undefined, any[], any]} InteractionDetails
 *
 * @typedef {"interaction" | "query" | "server" | "time"} InteractionType
 */

/**
 * @template T
 * @typedef {T | Iterable<T>} MaybeIterable
 */

/**
 * @template T
 * @typedef {T | PromiseLike<T>} MaybePromise
 */

//-----------------------------------------------------------------------------
// Global
//-----------------------------------------------------------------------------

const {
    Array: { isArray: $isArray },
    matchMedia,
    navigator: { userAgent: $userAgent },
    Object: { assign: $assign, getPrototypeOf: $getPrototypeOf },
    RegExp,
    SyntaxError,
} = globalThis;
const $toString = Object.prototype.toString;

//-----------------------------------------------------------------------------
// Internal
//-----------------------------------------------------------------------------

/**
 * @template {(...args: any[]) => any} T
 * @param {InteractionType} type
 * @param {T} fn
 * @param {string} name
 * @param {string} [alias]
 * @returns {T}
 */
function makeInteractorFn(type, fn, name, alias) {
    return {
        [alias || name](...args) {
            const result = fn(...args);
            if (isInstanceOf(result, Promise)) {
                for (let i = 0; i < args.length; i++) {
                    if (isInstanceOf(args[i], Promise)) {
                        // Get promise result for async arguments if possible
                        args[i].then((result) => (args[i] = result));
                    }
                }
                return result.then((promiseResult) =>
                    dispatchInteraction(type, name, alias, args, promiseResult)
                );
            } else {
                return dispatchInteraction(type, name, alias, args, result);
            }
        },
    }[alias || name];
}

function polyfillIsError(value) {
    return $toString.call(value) === "[object Error]";
}

const GRAYS = {
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
};

const COLORS = {
    default: {
        // Generic colors
        black: "#000000",
        white: "#ffffff",

        // Grays
        "gray-100": GRAYS[100],
        "gray-200": GRAYS[200],
        "gray-300": GRAYS[300],
        "gray-400": GRAYS[400],
        "gray-500": GRAYS[500],
        "gray-600": GRAYS[600],
        "gray-700": GRAYS[700],
        "gray-800": GRAYS[800],
        "gray-900": GRAYS[900],
    },
    light: {
        // Generic colors
        primary: "#714b67",
        secondary: "#74b4b9",
        amber: "#f59e0b",
        "amber-900": "#fef3c7",
        blue: "#3b82f6",
        "blue-900": "#dbeafe",
        cyan: "#0891b2",
        "cyan-900": "#e0f2fe",
        emerald: "#047857",
        "emerald-900": "#ecfdf5",
        gray: GRAYS[400],
        lime: "#84cc16",
        "lime-900": "#f7fee7",
        orange: "#ea580c",
        "orange-900": "#ffedd5",
        purple: "#581c87",
        "purple-900": "#f3e8ff",
        rose: "#9f1239",
        "rose-900": "#fecdd3",

        // App colors
        bg: GRAYS[100],
        text: GRAYS[900],
        "status-bg": GRAYS[300],
        "link-text-hover": "var(--primary)",
        "btn-bg": "#714b67",
        "btn-bg-hover": "#624159",
        "btn-text": "#ffffff",
        "bg-result": "rgba(255, 255, 255, 0.6)",
        "border-result": GRAYS[300],
        "border-search": "#d8dadd",
        "shadow-opacity": 0.1,

        // HootReporting colors
        "bg-report": "#ffffff",
        "text-report": "#202124",
        "border-report": "#f0f0f0",
        "bg-report-error": "#fff0f0",
        "text-report-error": "#ff0000",
        "border-report-error": "#ffd6d6",
        "text-report-number": "#1a1aa6",
        "text-report-string": "#c80000",
        "text-report-key": "#881280",
        "text-report-html-tag": "#881280",
        "text-report-html-id": "#1a1aa8",
        "text-report-html-class": "#994500",
    },
    dark: {
        // Generic colors
        primary: "#14b8a6",
        amber: "#fbbf24",
        "amber-900": "#422006",
        blue: "#60a5fa",
        "blue-900": "#172554",
        cyan: "#22d3ee",
        "cyan-900": "#083344",
        emerald: "#34d399",
        "emerald-900": "#064e3b",
        gray: GRAYS[500],
        lime: "#bef264",
        "lime-900": "#365314",
        orange: "#fb923c",
        "orange-900": "#431407",
        purple: "#a855f7",
        "purple-900": "#3b0764",
        rose: "#fb7185",
        "rose-900": "#4c0519",

        // App colors
        bg: GRAYS[900],
        text: GRAYS[100],
        "status-bg": GRAYS[700],
        "btn-bg": "#00dac5",
        "btn-bg-hover": "#00c1ae",
        "btn-text": "#000000",
        "bg-result": "rgba(0, 0, 0, 0.5)",
        "border-result": GRAYS[600],
        "border-search": "#3c3f4c",
        "shadow-opacity": 0.4,

        // HootReporting colors
        "bg-report": "#202124",
        "text-report": "#e8eaed",
        "border-report": "#3a3a3a",
        "bg-report-error": "#290000",
        "text-report-error": "#ff8080",
        "border-report-error": "#5c0000",
        "text-report-number": "#9980ff",
        "text-report-string": "#f28b54",
        "text-report-key": "#5db0d7",
        "text-report-html-tag": "#5db0d7",
        "text-report-html-id": "#f29364",
        "text-report-html-class": "#9bbbdc",
    },
};
const DEBUG_NAMESPACE = "hoot";

const isError = typeof Error.isError === "function" ? Error.isError : polyfillIsError;
const interactionBus = new EventTarget();
const preferredColorScheme = matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * @param {Iterable<InteractionType>} types
 * @param {(event: CustomEvent<InteractionDetails>) => any} callback
 */
__exports.addInteractionListener = addInteractionListener; function addInteractionListener(types, callback) {
    for (const type of types) {
        interactionBus.addEventListener(type, callback);
    }

    return function removeInteractionListener() {
        for (const type of types) {
            interactionBus.removeEventListener(type, callback);
        }
    };
}

/**
 * @param {InteractionType} type
 * @param {string} name
 * @param {string | undefined} alias
 * @param {any[]} args
 * @param {any} returnValue
 */
__exports.dispatchInteraction = dispatchInteraction; function dispatchInteraction(type, name, alias, args, returnValue) {
    interactionBus.dispatchEvent(
        new CustomEvent(type, {
            detail: [name, alias, args, returnValue],
        })
    );
    return returnValue;
}

/**
 * @param {...any} helpers
 */
__exports.exposeHelpers = exposeHelpers; function exposeHelpers(...helpers) {
    let nameSpaceIndex = 1;
    let nameSpace = DEBUG_NAMESPACE;
    while (nameSpace in globalThis) {
        nameSpace = `${DEBUG_NAMESPACE}${nameSpaceIndex++}`;
    }
    globalThis[nameSpace] = new HootDebugHelpers(...helpers);
    return nameSpace;
}

/**
 * @param {keyof typeof COLORS} [scheme]
 */
__exports.getAllColors = getAllColors; function getAllColors(scheme) {
    return scheme ? COLORS[scheme] : COLORS;
}

/**
 * @param {keyof typeof COLORS["light"]} varName
 */
__exports.getColorHex = getColorHex; function getColorHex(varName) {
    return COLORS[preferredColorScheme][varName];
}

__exports.getPreferredColorScheme = getPreferredColorScheme; function getPreferredColorScheme() {
    return preferredColorScheme;
}

/**
 * @param {Node} node
 */
__exports.getTag = getTag; function getTag(node) {
    return node?.nodeName?.toLowerCase() || "";
}

/**
 * @template {(...args: any[]) => any} T
 * @param {InteractionType} type
 * @param {T} fn
 * @returns {T & {
 *  as: (name: string) => T;
 *  readonly silent: T;
 * }}
 */
__exports.interactor = interactor; function interactor(type, fn) {
    return $assign(makeInteractorFn(type, fn, fn.name), {
        as(alias) {
            return makeInteractorFn(type, fn, fn.name, alias);
        },
        get silent() {
            return fn;
        },
    });
}

/**
 * @returns {boolean}
 */
__exports.isFirefox = isFirefox; function isFirefox() {
    return /firefox/i.test($userAgent);
}

/**
 * Cross-realm equivalent to 'instanceof'.
 * Can be called with multiple constructors, and will return true if the given object
 * is an instance of any of them.
 *
 * @param {unknown} instance
 * @param {...{ name: string }} classes
 */
__exports.isInstanceOf = isInstanceOf; function isInstanceOf(instance, ...classes) {
    if (!classes.length) {
        return instance instanceof classes[0];
    }
    if (!instance || Object(instance) !== instance) {
        // Object is falsy or a primitive (null, undefined and primitives cannot be the instance of anything)
        return false;
    }
    for (const cls of classes) {
        if (instance instanceof cls) {
            return true;
        }
        const targetName = cls.name;
        if (!targetName) {
            return false;
        }
        if (targetName === "Array") {
            return $isArray(instance);
        }
        if (targetName === "Error") {
            return isError(instance);
        }
        if ($toString.call(instance) === `[object ${targetName}]`) {
            return true;
        }
        let { constructor } = instance;
        while (constructor) {
            if (constructor.name === targetName) {
                return true;
            }
            constructor = $getPrototypeOf(constructor);
        }
    }
    return false;
}

/**
 * Returns whether the given object is iterable (*excluding strings*).
 *
 * @template T
 * @template {T | Iterable<T>} V
 * @param {V} object
 * @returns {V extends Iterable<T> ? true : false}
 */
__exports.isIterable = isIterable; function isIterable(object) {
    return !!(object && typeof object === "object" && object[Symbol.iterator]);
}

/**
 * @param {string} value
 * @param {{ safe?: boolean }} [options]
 * @returns {string | RegExp}
 */
__exports.parseRegExp = parseRegExp; function parseRegExp(value, options) {
    const regexParams = value.match(R_REGEX);
    if (regexParams) {
        const unified = regexParams[1].replace(R_WHITE_SPACE, "\\s+");
        const flag = regexParams[2];
        try {
            return new RegExp(unified, flag);
        } catch (error) {
            if (isInstanceOf(error, SyntaxError) && options?.safe) {
                return value;
            } else {
                throw error;
            }
        }
    }
    return value;
}

/**
 * @param {Node} node
 * @param {{ raw?: boolean }} [options]
 */
__exports.toSelector = toSelector; function toSelector(node, options) {
    const tagName = getTag(node);
    const id = node.id ? `#${node.id}` : "";
    const classNames = node.classList
        ? [...node.classList].map((className) => `.${className}`)
        : [];
    if (options?.raw) {
        return { tagName, id, classNames };
    } else {
        return [tagName, id, ...classNames].join("");
    }
}

const HootDebugHelpers = __exports.HootDebugHelpers = class HootDebugHelpers {
    /**
     * @param {...any} helpers
     */
    constructor(...helpers) {
        $assign(this, ...helpers);
    }
}

const REGEX_MARKER = __exports.REGEX_MARKER = "/";

// Common regular expressions
const R_REGEX = __exports.R_REGEX = new RegExp(`^${REGEX_MARKER}(.*)${REGEX_MARKER}([dgimsuvy]+)?$`);
const R_WHITE_SPACE = __exports.R_WHITE_SPACE = /\s+/g;

return __exports;
});
;

/***************************************************
*  Filepath: /web_tour/static/src/js/tour_step.js  *
*  Lines: 108                                      *
***************************************************/
odoo.define('@web_tour/js/tour_step', ['@web/session', '@web/core/ui/ui_service', '@odoo/hoot-dom', '@web/core/utils/objects'], function (require) {
'use strict';
let __exports = {};
const { session } = require("@web/session");
const { utils } = require("@web/core/ui/ui_service");
const hoot = require("@odoo/hoot-dom");
const { pick } = require("@web/core/utils/objects");

/**
 * @typedef TourStep
 * @property {"enterprise"|"community"|"mobile"|"desktop"|HootSelector[][]} isActive Active the step following {@link isActiveStep} filter
 * @property {string} [id]
 * @property {HootSelector} trigger The node on which the action will be executed.
 * @property {string} [content] Description of the step.
 * @property {"top" | "bottom" | "left" | "right"} [position] The position where the UI helper is shown.
 * @property {RunCommand} [run] The action to perform when trigger conditions are verified.
 * @property {number} [timeout] By default, when the trigger node isn't found after 10000 milliseconds, it throws an error.
 * You can change this value to lengthen or shorten the time before the error occurs [ms].
 */
const TourStep = __exports.TourStep = class TourStep {
    constructor(data, tour) {
        Object.assign(this, data);
        this.tour = tour;
    }

    /**
     * Check if a step is active dependant on step.isActive property
     * Note that when step.isActive is not defined, the step is active by default.
     * When a step is not active, it's just skipped and the tour continues to the next step.
     */
    get active() {
        this.checkHasTour();
        const mode = this.tour.mode;
        const isSmall = utils.isSmall();
        const standardKeyWords = ["enterprise", "community", "mobile", "desktop", "auto", "manual"];
        const isActiveArray = Array.isArray(this.isActive) ? this.isActive : [];
        if (isActiveArray.length === 0) {
            return true;
        }
        const selectors = isActiveArray.filter((key) => !standardKeyWords.includes(key));
        if (selectors.length) {
            // if one of selectors is not found, step is skipped
            for (const selector of selectors) {
                const el = hoot.queryFirst(selector);
                if (!el) {
                    return false;
                }
            }
        }
        const checkMode =
            isActiveArray.includes(mode) ||
            (!isActiveArray.includes("manual") && !isActiveArray.includes("auto"));
        const edition =
            (session.server_version_info || "").at(-1) === "e" ? "enterprise" : "community";
        const checkEdition =
            isActiveArray.includes(edition) ||
            (!isActiveArray.includes("enterprise") && !isActiveArray.includes("community"));
        const onlyForMobile = isActiveArray.includes("mobile") && isSmall;
        const onlyForDesktop = isActiveArray.includes("desktop") && !isSmall;
        const checkDevice =
            onlyForMobile ||
            onlyForDesktop ||
            (!isActiveArray.includes("mobile") && !isActiveArray.includes("desktop"));
        return checkEdition && checkDevice && checkMode;
    }

    checkHasTour() {
        if (!this.tour) {
            throw new Error(`TourStep instance must have a tour`);
        }
    }

    get describeMe() {
        this.checkHasTour();
        return (
            `[${this.index + 1}/${this.tour.steps.length}] Tour ${this.tour.name}  Step ` +
            (this.content ? `${this.content} (trigger: ${this.trigger})` : this.trigger)
        );
    }

    get stringify() {
        return (
            JSON.stringify(
                pick(
                    this,
                    "isActive",
                    "content",
                    "trigger",
                    "run",
                    "tooltipPosition",
                    "timeout",
                    "expectUnloadPage"
                ),
                (_key, value) => {
                    if (typeof value === "function") {
                        return "[function]";
                    } else {
                        return value;
                    }
                },
                2
            ) + ","
        );
    }
}

return __exports;
});
;

/***********************************************************************
*  Filepath: /web_tour/static/src/js/tour_automatic/tour_automatic.js  *
*  Lines: 227                                                          *
***********************************************************************/
odoo.define('@web_tour/js/tour_automatic/tour_automatic', ['@odoo/hoot-dom', '@web/../lib/hoot-dom/helpers/events', '@web/core/browser/browser', '@web/core/macro', '@web/core/transition', '@web_tour/js/tour_automatic/tour_step_automatic', '@web_tour/js/tour_state'], function (require) {
'use strict';
let __exports = {};
const hootDom = require("@odoo/hoot-dom");
const { enableEventLogs, setupEventActions } = require("@web/../lib/hoot-dom/helpers/events");
const { browser } = require("@web/core/browser/browser");
const { Macro } = require("@web/core/macro");
const { config: transitionConfig } = require("@web/core/transition");
const { TourStepAutomatic } = require("@web_tour/js/tour_automatic/tour_step_automatic");
const { tourState } = require("@web_tour/js/tour_state");

const TourAutomatic = __exports.TourAutomatic = class TourAutomatic {
    mode = "auto";
    allowUnload = true;
    constructor(data) {
        Object.assign(this, data);
        this.steps = this.steps.map((step, index) => new TourStepAutomatic(step, this, index));
        this.config = tourState.getCurrentConfig() || {};
    }

    get currentIndex() {
        return tourState.getCurrentIndex();
    }

    get currentStep() {
        return this.steps[this.currentIndex];
    }

    get debugMode() {
        return this.config.debug !== false;
    }

    start() {
        setupEventActions(document.createElement("div"), { allowSubmit: true });
        enableEventLogs(this.debugMode);
        const { delayToCheckUndeterminisms, stepDelay } = this.config;
        const macroSteps = this.steps
            .filter((step) => step.index >= this.currentIndex)
            .flatMap((step) => [
                {
                    action: async () => {
                        if (this.debugMode) {
                            console.groupCollapsed(step.describeMe);
                            console.log(step.stringify);
                            if (stepDelay > 0) {
                                await hootDom.delay(stepDelay);
                            }
                            if (step.break) {
                                // eslint-disable-next-line no-debugger
                                debugger;
                            }
                        } else {
                            console.log(step.describeMe);
                        }
                    },
                },
                {
                    trigger: step.trigger ? () => step.findTrigger() : null,
                    timeout:
                        step.pause && this.debugMode
                            ? 9999999
                            : step.timeout || this.timeout || 10000,
                    action: async (trigger) => {
                        if (delayToCheckUndeterminisms > 0) {
                            await step.checkForUndeterminisms(trigger, delayToCheckUndeterminisms);
                        }
                        this.allowUnload = false;
                        if (!step.skipped && step.expectUnloadPage) {
                            this.allowUnload = true;
                            setTimeout(() => {
                                const message = `
                                    The key { expectUnloadPage } is defined but page has not been unloaded within 20000 ms.
                                    You probably don't need it.
                                `.replace(/^\s+/gm, "");
                                this.throwError(message);
                            }, 20000);
                        }
                        await step.doAction();
                        if (this.debugMode) {
                            console.log(trigger);
                            if (step.skipped) {
                                console.log("This step has been skipped");
                            } else {
                                console.log("This step has run successfully");
                            }
                            console.groupEnd();
                            if (step.pause) {
                                await this.pause();
                            }
                        }
                        tourState.setCurrentIndex(step.index + 1);
                        if (this.allowUnload) {
                            return "StopTheMacro!";
                        }
                    },
                },
            ]);

        const end = () => {
            delete window[hootNameSpace];
            transitionConfig.disabled = false;
            tourState.clear();
            //No need to catch error yet.
            window.addEventListener(
                "error",
                (ev) => {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                },
                true
            );
            window.addEventListener(
                "unhandledrejection",
                (ev) => {
                    ev.preventDefault();
                    ev.stopImmediatePropagation();
                },
                true
            );
        };

        this.macro = new Macro({
            name: this.name,
            steps: macroSteps,
            onError: ({ error }) => {
                if (error.type === "Timeout") {
                    this.throwError(...this.currentStep.describeWhyIFailed, error.message);
                } else {
                    this.throwError(error.message);
                }
                end();
            },
            onComplete: () => {
                browser.console.log("tour succeeded");
                // Used to see easily in the python console and to know which tour has been succeeded in suite tours case.
                const succeeded = ` TOUR ${this.name} SUCCEEDED `;
                const msg = [succeeded];
                msg.unshift("" + "".repeat(succeeded.length - 2) + "");
                msg.push("" + "".repeat(succeeded.length - 2) + "");
                browser.console.log(`\n\n${msg.join("\n")}\n`);
                end();
            },
        });

        const beforeUnloadHandler = () => {
            if (!this.allowUnload) {
                const message = `
                    Be sure to use { expectUnloadPage: true } for any step
                    that involves firing a beforeUnload event.
                    This avoid a non-deterministic behavior by explicitly stopping
                    the tour that might continue before the page is unloaded.
                `.replace(/^\s+/gm, "");
                this.throwError(message);
            }
        };
        window.addEventListener("beforeunload", beforeUnloadHandler);

        if (this.debugMode && this.currentIndex === 0) {
            // Starts the tour with a debugger to allow you to choose devtools configuration.
            // eslint-disable-next-line no-debugger
            debugger;
        }
        transitionConfig.disabled = true;
        const hootNameSpace = hootDom.exposeHelpers(hootDom);
        console.debug(`Hoot DOM helpers available from \`window.${hootNameSpace}\``);
        this.macro.start();
    }

    get describeWhereIFailed() {
        const offset = 3;
        const start = Math.max(this.currentIndex - offset, 0);
        const end = Math.min(this.currentIndex + offset, this.steps.length - 1);
        const result = [];
        for (let i = start; i <= end; i++) {
            const step = this.steps[i];
            const stepString = step.stringify;
            const text = [stepString];
            if (i === this.currentIndex) {
                const line = "-".repeat(10);
                const failing_step = `${line} FAILED: ${step.describeMe} ${line}`;
                text.unshift(failing_step);
                text.push("-".repeat(failing_step.length));
            }
            result.push(...text);
        }
        return result.join("\n");
    }

    /**
     * @param {string} [error]
     */
    throwError(...args) {
        console.groupEnd();
        tourState.setCurrentTourOnError();
        // console.error notifies the test runner that the tour failed.
        browser.console.error([`FAILED: ${this.currentStep.describeMe}.`, ...args].join("\n"));
        // The logged text shows the relative position of the failed step.
        // Useful for finding the failed step.
        browser.console.dir(this.describeWhereIFailed);
        if (this.debugMode) {
            // eslint-disable-next-line no-debugger
            debugger;
        }
    }

    async pause() {
        const styles = [
            "background: black; color: white; font-size: 14px",
            "background: black; color: orange; font-size: 14px",
        ];
        console.log(
            `%cTour is paused. Use %cplay()%c to continue.`,
            styles[0],
            styles[1],
            styles[0]
        );
        await new Promise((resolve) => {
            window.play = () => {
                resolve();
                delete window.play;
            };
        });
    }
}

return __exports;
});
;

/**************************************************************************
*  Filepath: /web_tour/static/src/js/tour_automatic/tour_helpers_hoot.js  *
*  Lines: 377                                                             *
**************************************************************************/
odoo.define('@web_tour/js/tour_automatic/tour_helpers_hoot', ['@odoo/hoot-dom', '@web/core/utils/patch', '@web_tour/js/tour_automatic/tour_helpers'], function (require) {
'use strict';
let __exports = {};
const hoot = require("@odoo/hoot-dom");
const { patch } = require("@web/core/utils/patch");
const { TourHelpers } = require("@web_tour/js/tour_automatic/tour_helpers");

patch(TourHelpers.prototype, {
    /**
     * Ensures that the given {@link Selector} is checked.
     * @description
     * If it is not checked, a click is triggered on the input.
     * If the input is still not checked after the click, an error is thrown.
     *
     * @param {string|Node} selector
     * @example
     *  run: "check", //Checks the action element
     * @example
     *  run: "check input[type=checkbox]", // Checks the selector
     */
    async check(selector) {
        const element = this._get_action_element(selector);
        await hoot.check(element);
    },

    /**
     * Clears the **value** of the **{@link Selector}**.
     * @description
     * This is done using the following sequence:
     * - pressing "Control" + "A" to select the whole value;
     * - pressing "Backspace" to delete the value;
     * - (optional) triggering a "change" event by pressing "Enter".
     *
     * @param {Selector} selector
     * @example
     *  run: "clear", // Clears the value of the action element
     * @example
     *  run: "clear input#my_input", // Clears the value of the selector
     */
    async clear(selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        await hoot.clear();
    },

    /**
     * Performs a click sequence on the given **{@link Selector}**
     * @description Let's see more informations about click sequence here: {@link hoot.click}
     * @param {Selector} selector
     * @param {import("@odoo/hoot-dom").PointerOptions} options
     * @example
     *  run: "click", // Click on the action element
     * @example
     *  run: "click .o_rows:first", // Click on the selector
     */
    async click(selector, options = { interactive: false }) {
        const element = this._get_action_element(selector);
        // FIXME: should always target interactive element, but some tour steps are
        // targetting elements affected by 'pointer-events: none' for some reason.
        // This option should ultimately disappear, with all affected cased fixed
        // individually (no common cause found during a quick investigation).
        await hoot.click(element, options);
    },

    /**
     * Performs two click sequences on the given **{@link Selector}**.
     * @description Let's see more informations about click sequence here: {@link hoot.dblclick}
     * @param {Selector} selector
     * @example
     *  run: "dblclick", // Double click on the action element
     * @example
     *  run: "dblclick .o_rows:first", // Double click on the selector
     */
    async dblclick(selector) {
        const element = this._get_action_element(selector);
        await hoot.dblclick(element);
    },

    /**
     * Starts a drag sequence on the active element (anchor) and drop it on the given **{@link Selector}**.
     * @param {Selector} selector
     * @param {hoot.PointerOptions} options
     * @example
     *  run: "drag_and_drop .o_rows:first", // Drag the active element and drop it in the selector
     * @example
     *  async run(helpers) {
     *      await helpers.drag_and_drop(".o_rows:first", {
     *          position: {
     *              top: 40,
     *              left: 5,
     *          },
     *          relative: true,
     *      });
     *  }
     */
    async drag_and_drop(selector, options) {
        if (typeof options !== "object") {
            options = { position: "top", relative: true };
        }
        const dragEffectDelay = async () => {
            await hoot.animationFrame();
            await hoot.delay(this.delay);
        };

        const element = this.anchor;
        const { drop, moveTo } = await hoot.drag(element);
        await dragEffectDelay();
        await hoot.hover(element, {
            position: {
                top: 20,
                left: 20,
            },
            relative: true,
        });
        await dragEffectDelay();
        const target = await hoot.waitFor(selector, {
            visible: true,
            timeout: 1000,
        });
        await moveTo(target, options);
        await dragEffectDelay();
        await drop(target, options);
        await dragEffectDelay();
    },

    /**
     * Edit input or textarea given by **{@link selector}**
     * @param {string} text
     * @param {Selector} selector
     * @example
     *  run: "edit Hello Mr. Doku",
     */
    async edit(text, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        await hoot.edit(text);
    },

    /**
     * Edit only editable wysiwyg element given by **{@link Selector}**
     * @param {string} text
     * @param {Selector} selector
     */
    async editor(text, selector) {
        const element = this._get_action_element(selector);
        const InEditor = Boolean(element.closest(".odoo-editor-editable"));
        if (!InEditor) {
            throw new Error("run 'editor' always on an element in an editor");
        }
        await hoot.click(element);
        this._set_range(element, "start");
        await hoot.keyDown("_");
        element.textContent = text;
        await hoot.manuallyDispatchProgrammaticEvent(element, "input");
        this._set_range(element, "stop");
        await hoot.keyUp("_");
        await hoot.manuallyDispatchProgrammaticEvent(element, "change");
    },

    /**
     * Fills the **{@link Selector}** with the given `value`.
     * @description This helper is intended for `<input>` and `<textarea>` elements,
     * with the exception of `"checkbox"` and `"radio"` types, which should be
     * selected using the {@link check} helper.
     * In tour, it's mainly usefull for autocomplete components.
     * @param {string} value
     * @param {Selector} selector
     */
    async fill(value, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        await hoot.fill(value);
    },

    /**
     * Performs a hover sequence on the given **{@link Selector}**.
     * @param {Selector} selector
     * @param {import("@odoo/hoot-dom").PointerOptions} options
     * @example
     *  run: "hover",
     */
    async hover(selector, options) {
        const element = this._get_action_element(selector);
        await hoot.hover(element, options);
    },

    /**
     * Only for input[type="range"]
     * @param {string|number} value
     * @param {Selector} selector
     */
    async range(value, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        await hoot.setInputRange(element, value);
    },

    /**
     * Performs a keyboard event sequence.
     * @example
     *  run : "press Enter",
     */
    async press(...args) {
        await hoot.press(args.flatMap((arg) => typeof arg === "string" && arg.split("+")));
    },

    /**
     * Performs a selection event sequence on **{@link Selector}**. This helper is intended
     * for `<select>` elements only.
     * @description Select the option by its value
     * @param {string} value
     * @param {Selector} selector
     * @example
     * run(helpers) => {
     *  helpers.select("Kevin17", "select#mySelect");
     * },
     * @example
     * run: "select Foden47",
     */
    async select(value, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        await hoot.select(value, { target: element });
    },

    /**
     * Performs a selection event sequence on **{@link Selector}**
     * @description Select the option by its index
     * @param {number} index starts at 0
     * @param {Selector} selector
     * @example
     *  run: "selectByIndex 2", //Select the third option
     */
    async selectByIndex(index, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        const value = hoot.queryValue(`option:eq(${index})`, { root: element });
        if (value) {
            await hoot.select(value, { target: element });
            await hoot.manuallyDispatchProgrammaticEvent(element, "input");
        }
    },

    /**
     * Performs a selection event sequence on **{@link Selector}**
     * @description Select option(s) by there labels
     * @param {string|RegExp} contains
     * @param {Selector} selector
     * @example
     *  run: "selectByLabel Jeremy Doku", //Select all options where label contains Jeremy Doku
     */
    async selectByLabel(contains, selector) {
        const element = this._get_action_element(selector);
        await hoot.click(element);
        const values = hoot.queryAllValues(`option:contains(${contains})`, { root: element });
        await hoot.select(values, { target: element });
    },

    /**
     * Ensures that the given {@link Selector} is unchecked.
     * @description
     * If it is checked, a click is triggered on the input.
     * If the input is still checked after the click, an error is thrown.
     *
     * @param {string|Node} selector
     * @example
     *  run: "uncheck", // Unchecks the action element
     * @example
     *  run: "uncheck input[type=checkbox]", // Unchecks the selector
     */
    async uncheck(selector) {
        const element = this._get_action_element(selector);
        await hoot.uncheck(element);
    },

    /**
     * Navigate to {@link url}.
     *
     * @param {string} url
     * @example
     *  run: "goToUrl /shop", // Go to /shop
     */
    async goToUrl(url) {
        const linkEl = document.createElement("a");
        linkEl.href = url;
        await hoot.click(linkEl);
    },

    /**
     * Ensures that the given canvas selector **{@link Selector}** contains pixels.
     * @param {string|Node} selector
     */
    async canvasNotEmpty(selector) {
        const canvas = this._get_action_element(selector);
        if (canvas.tagName.toLowerCase() !== "canvas") {
            throw new Error(`canvasNotEmpty is only suitable for canvas elements.`);
        }
        await hoot.waitUntil(() => {
            const context = canvas.getContext("2d");
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = new Uint32Array(imageData.data.buffer);
            return pixels.some((pixel) => pixel !== 0); // pixel is on
        });
    },

    /**
     * Get Node for **{@link Selector}**
     * @param {Selector} selector
     * @returns {Node}
     * @default this.anchor
     */
    _get_action_element(selector) {
        if (typeof selector === "string" && selector.length) {
            const nodes = hoot.queryAll(selector);
            return nodes.find(hoot.isVisible) || nodes.at(0);
        } else if (typeof selector === "object" && Boolean(selector?.nodeType)) {
            return selector;
        }
        return this.anchor;
    },

    // Useful for wysiwyg editor.
    _set_range(element, start_or_stop) {
        function _node_length(node) {
            if (node.nodeType === Node.TEXT_NODE) {
                return node.nodeValue.length;
            } else {
                return node.childNodes.length;
            }
        }
        const selection = element.ownerDocument.getSelection();
        selection.removeAllRanges();
        const range = new Range();
        let node = element;
        let length = 0;
        if (start_or_stop === "start") {
            while (node.firstChild) {
                node = node.firstChild;
            }
        } else {
            while (node.lastChild) {
                node = node.lastChild;
            }
            length = _node_length(node);
        }
        range.setStart(node, length);
        range.setEnd(node, length);
        selection.addRange(range);
    },

    queryAll(target, options) {
        return hoot.queryAll(target, options);
    },

    queryFirst(target, options) {
        return hoot.queryFirst(target, options);
    },

    queryOne(target, options) {
        return hoot.queryOne(target, options);
    },

    waitFor(target, options) {
        return hoot.waitFor(target, options);
    },

    waitUntil(predicate, options) {
        return hoot.waitUntil(predicate, options);
    },

    animationFrame(...args) {
        return hoot.animationFrame(...args);
    },
});

return __exports;
});
;

/****************************************************************************
*  Filepath: /web_tour/static/src/js/tour_automatic/tour_step_automatic.js  *
*  Lines: 200                                                               *
****************************************************************************/
odoo.define('@web_tour/js/tour_automatic/tour_step_automatic', ['@web_tour/js/tour_state', '@odoo/hoot-dom', '@web_tour/js/utils/tour_utils', '@web_tour/js/tour_automatic/tour_helpers', '@web_tour/js/tour_step', '@web/core/utils/xml', '@web/core/macro'], function (require) {
'use strict';
let __exports = {};
const { tourState } = require("@web_tour/js/tour_state");
const hoot = require("@odoo/hoot-dom");
const { serializeChanges, serializeMutation } = require("@web_tour/js/utils/tour_utils");
const { TourHelpers } = require("@web_tour/js/tour_automatic/tour_helpers");
const { TourStep } = require("@web_tour/js/tour_step");
const { getTag } = require("@web/core/utils/xml");
const { MacroMutationObserver } = require("@web/core/macro");

async function waitForMutations(target = document, timeout = 1000 / 16) {
    return new Promise((resolve) => {
        let observer;
        let timer;
        const mutationList = [];
        function onMutation(mutations) {
            mutationList.push(...(mutations || []));
            clearTimeout(timer);
            timer = setTimeout(() => {
                observer.disconnect();
                resolve(mutationList);
            }, timeout);
        }
        observer = new MacroMutationObserver(onMutation);
        observer.observe(target);
        onMutation([]);
    });
}
const TourStepAutomatic = __exports.TourStepAutomatic = class TourStepAutomatic extends TourStep {
    skipped = false;
    error = "";
    constructor(data, tour, index) {
        super(data, tour);
        this.index = index;
        this.tourConfig = tourState.getCurrentConfig();
    }

    async checkForUndeterminisms(initialElement, delay) {
        if (delay <= 0 || !initialElement) {
            return;
        }
        const tagName = initialElement.tagName?.toLowerCase();
        if (["body", "html"].includes(tagName) || !tagName) {
            return;
        }
        const snapshot = initialElement.cloneNode(true);
        const mutations = await waitForMutations(initialElement, delay);
        let reason;
        if (!hoot.isVisible(initialElement)) {
            reason = `Initial element is no longer visible`;
        } else if (!initialElement.isEqualNode(snapshot)) {
            reason =
                `Initial element has changed:\n` +
                JSON.stringify(serializeChanges(snapshot, initialElement), null, 2);
        } else if (mutations.length) {
            const changes = [...new Set(mutations.map(serializeMutation))];
            reason =
                `Initial element has mutated ${mutations.length} times:\n` +
                JSON.stringify(changes, null, 2);
        }
        if (reason) {
            throw new Error(
                `Potential non deterministic behavior found in ${delay}ms for trigger ${this.trigger}.\n${reason}`
            );
        }
    }

    get describeWhyIFailed() {
        const errors = [];
        if (this.element) {
            errors.push(`Element has been found.`);
            if (this.isUIBlocked) {
                errors.push("BUT: DOM is blocked by UI.");
            }
            if (!this.elementIsInModal) {
                errors.push(
                    `BUT: It is not allowed to do action on an element that's below a modal.`
                );
            }
            if (!this.elementIsEnabled) {
                errors.push(
                    `BUT: Element is not enabled. TIP: You can use :enable to wait the element is enabled before doing action on it.`
                );
            }
            if (!this.parentFrameIsReady) {
                errors.push(`BUT: parent frame is not ready ([is-ready='false']).`);
            }
        } else {
            const checkElement = hoot.queryFirst(this.trigger);
            if (checkElement) {
                errors.push(`Element has been found.`);
                errors.push(
                    `BUT: Element is not visible. TIP: You can use :not(:visible) to force the search for an invisible element.`
                );
            } else {
                errors.push(`Element (${this.trigger}) has not been found.`);
            }
        }
        return errors;
    }

    /**
     * When return null or false, macro continues.
     */
    async doAction() {
        if (this.skipped) {
            return false;
        }
        const actionHelper = new TourHelpers(this.element);
        if (typeof this.run === "function") {
            return await this.run.call({ anchor: this.element }, actionHelper);
        } else if (typeof this.run === "string") {
            let lastResult = null;
            for (const todo of this.run.split("&&")) {
                const m = String(todo)
                    .trim()
                    .match(/^(?<action>\w*) *\(? *(?<arguments>.*?)\)?$/);
                lastResult = await actionHelper[m.groups?.action](m.groups?.arguments);
            }
            return lastResult;
        }
    }

    /**
     * Each time it returns false, tour engine wait for a mutation
     * to retry to find the trigger.
     * @returns {(HTMLElement|Boolean)}
     */
    findTrigger() {
        if (!this.active) {
            this.skipped = true;
            return true;
        }
        const visible = !/:(hidden|visible)\b/.test(this.trigger);
        this.element = hoot.queryFirst(this.trigger, { visible });
        if (this.element) {
            return !this.isUIBlocked &&
                this.elementIsEnabled &&
                this.elementIsInModal &&
                this.parentFrameIsReady
                ? this.element
                : false;
        }
        return false;
    }

    get isUIBlocked() {
        return (
            document.body.classList.contains("o_ui_blocked") ||
            document.querySelector(".o_blockUI") ||
            document.querySelector(".o_is_blocked")
        );
    }

    get parentFrameIsReady() {
        if (this.trigger.match(/\[is-ready=(true|false)\]/)) {
            return true;
        }
        const parentFrame = hoot.getParentFrame(this.element);
        return parentFrame && parentFrame.contentDocument.body.hasAttribute("is-ready")
            ? parentFrame.contentDocument.body.getAttribute("is-ready") === "true"
            : true;
    }

    get elementIsInModal() {
        if (this.hasAction) {
            const overlays = hoot.queryFirst(
                ".popover, .o-we-command, .o-we-toolbar, .o_notification"
            );
            const modal = hoot.queryFirst(".modal:visible:not(.o_inactive_modal):last");
            if (modal && !overlays && !this.trigger.startsWith("body")) {
                return (
                    modal.contains(hoot.getParentFrame(this.element)) ||
                    modal.contains(this.element)
                );
            }
        }
        return true;
    }

    get elementIsEnabled() {
        const isTag = (array) => array.includes(getTag(this.element, true));
        if (this.hasAction) {
            if (isTag(["input", "textarea"])) {
                return hoot.isEditable(this.element);
            } else if (isTag(["button", "select"])) {
                return !this.element.disabled;
            }
        }
        return true;
    }

    get hasAction() {
        return ["string", "function"].includes(typeof this.run) && !this.skipped;
    }
}

return __exports;
});
;

/****************************************************************
*  Filepath: /html_editor/static/tests/tours/helpers/editor.js  *
*  Lines: 31                                                    *
****************************************************************/
odoo.define('@html_editor/../tests/tours/helpers/editor', ['@web/core/utils/patch'], function (require) {
'use strict';
let __exports = {};
const { patch } = require("@web/core/utils/patch");

// To expose the editor instance globally for tour.
const editorsWeakMap = __exports.editorsWeakMap = new WeakMap();

const editorModule = odoo.loader.modules.get("@html_editor/editor");
if (editorModule) {
    const { Editor } = editorModule;
    patch(Editor.prototype, {
        attachTo(editable) {
            editorsWeakMap.set(editable.ownerDocument, this);
            return super.attachTo(...arguments);
        },
    });
}

__exports.setSelection = setSelection; function setSelection({
    anchorNode,
    anchorOffset,
    focusNode = anchorNode,
    focusOffset = anchorOffset,
}) {
    const selection = anchorNode.ownerDocument.getSelection();
    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);
}

return __exports;
});
;

/********************************************************************
*  Filepath: /mail/static/tests/tours/activity_date_format_tour.js  *
*  Lines: 45                                                        *
********************************************************************/
odoo.define('@mail/../tests/tours/activity_date_format_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("mail_activity_date_format", {
    steps: () => [
        {
            trigger: "button:contains('Activity')",
            run: "click",
        },
        {
            trigger: ".o_selection_badge span:contains('To-Do')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Go Party",
        },
        {
            trigger: "button:contains('Save')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity:contains('Go Party')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity-info i",
            run: "click",
        },
        // Format expected from the server for 9 AM at the first day of 2024 is date_format = "%d/%b/%y", time_format = "%I:%M:%S %p".
        {
            trigger:
                ".o-mail-Activity-details tr:contains('Created') td:contains('01/Jan/24 09:00:00 AM')",
        },
        {
            // Default due date is 5 days after creation date.
            trigger: ".o-mail-Activity-details tr:contains('Due on') td:contains('06/Jan/24')",
        },
    ],
});

return __exports;
});
;

/**************************************************************
*  Filepath: /mail/static/tests/tours/create_channel_tour.js  *
*  Lines: 35                                                  *
**************************************************************/
odoo.define('@mail/../tests/tours/create_channel_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("can_create_channel_from_form_view", {
    steps: () => [
        {
            trigger: ".o-mail-DiscussSidebarChannel-itemName:contains(OdooBot)",
            run: "click",
        },
        {
            trigger: ".o-mail-DiscussContent-threadName[title='OdooBot']",
        },
        { trigger: "button[title='View or join channels']:not(:visible)", run: "click" },
        {
            trigger: ".o_control_panel_main_buttons button:contains('New')",
            run: "click",
        },
        {
            trigger: "div[name='name'] input",
            run: "edit Test channel",
        },
        {
            trigger: ".breadcrumb-item:contains('OdooBot')",
            run: "click",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel-itemName:contains('Test channel')",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_call_invitation_tour.js  *
*  Lines: 68                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/discuss_call_invitation_tour', ['@mail/discuss/core/common/channel_member_model', '@web/core/registry', '@web/../tests/helpers/utils'], function (require) {
'use strict';
let __exports = {};
const { ChannelMember } = require("@mail/discuss/core/common/channel_member_model");

const { registry } = require("@web/core/registry");
const { patchWithCleanup } = require("@web/../tests/helpers/utils");

registry.category("web_tour.tours").add("discuss_call_invitation.js", {
    steps: () => {
        // Call invitation is cancelled after 30s. Increase this delay for the test.
        patchWithCleanup(ChannelMember, { CANCEL_CALL_INVITE_DELAY: 1e6 });
        return [
            { trigger: ".o-discuss-CallInvitation" },
            {
                trigger:
                    ".o-mail-CallInvitation-avatar[title='View the bob (base.group_user) and john (base.group_user) channel']",
            },
            {
                trigger:
                    ".o-discuss-CallInvitation-channelName:contains('bob (base.group_user) and john (base.group_user)')",
            },
            {
                trigger:
                    ".o-discuss-CallInvitation-description:contains('Incoming call from bob (base.group_user)')",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview:not(:visible)",
            },
            {
                trigger: ".o-discuss-CallInvitation button[title='Join Call']",
            },
            {
                trigger: ".o-discuss-CallInvitation button[title='Reject']",
            },
            {
                trigger: ".o-discuss-CallInvitation button[title='Show camera preview']",
                run: "click",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview button[title='Turn camera on']",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview button[title='Unmute']",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview button[title='Video Settings']",
                run: "click",
            },
            {
                trigger: "label:contains('Blur background')",
            },
            {
                trigger: ".o-discuss-CallInvitation button[title='Hide camera preview']",
                run: "click",
            },
            {
                trigger: ".o-discuss-CallInvitation-cameraPreview:not(:visible)",
            },
        ];
    },
});

return __exports;
});
;

/************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_as_guest_tour.js  *
*  Lines: 49                                                            *
************************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_as_guest_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains } = require("@web/../tests/utils");

registry.category("web_tour.tours").add("discuss_channel_as_guest_tour.js", {
    steps: () => [
        {
            content: "Channel secret token has been hidden on welcome page",
            trigger: ".o-mail-WelcomePage",
            run() {
                if (!window.location.pathname.startsWith("/discuss/channel")) {
                    console.error("Channel secret token is still present in URL.");
                }
            },
        },
        {
            content: "Click join",
            trigger: "button[title='Join Channel']",
            run: "click",
        },
        {
            content: "Check that we are on not in a call",
            trigger: "button[name='call']",
        },
        {
            content: "Check that we are on channel page",
            trigger: ".o-mail-Thread",
            run: "press ctrl+k",
        },
        {
            trigger: ".o_command_palette_search input",
            run: "fill @",
        },
        {
            trigger: ".o-mail-DiscussCommand",
            async run() {
                await contains(".fa-hashtag", {
                    parent: [".o-mail-DiscussCommand", { text: "Test channel" }],
                });
                await contains(".fa-user", { count: 0 });
            },
        },
    ],
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_call_action.js  *
*  Lines: 20                                                          *
**********************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_call_action', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_channel_call_action.js", {
    steps: () => [
        {
            content: "Check that the call has started",
            trigger: ".o-discuss-Call",
        },
        {
            content: "Check that current user is in call ('disconnect' button visible)",
            trigger: "button[title='Disconnect']",
        },
    ],
});

return __exports;
});
;

/***************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_call_public_tour.js  *
*  Lines: 36                                                               *
***************************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_call_public_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_channel_call_public_tour.js", {
    steps: () => [
        {
            content: "The call does not start on the welcome page",
            trigger: ".o-mail-WelcomePage",
            async run() {
                await new Promise((r) => setTimeout(r, 250));
                const rtcService = odoo.__WOWL_DEBUG__.root.env.services["discuss.rtc"];
                if (rtcService?.selfSession || rtcService?.state.hasPendingRequest) {
                    console.error("The call should not have started.");
                }
            },
        },
        {
            content: "Click join",
            trigger: "button[title='Join Channel']",
            run: "click",
        },
        {
            content: "Check that the call has started",
            trigger: ".o-discuss-Call",
        },
        {
            content: "Check that current user is in call ('disconnect' button visible)",
            trigger: "button[title='Disconnect']",
        },
    ],
});

return __exports;
});
;

/****************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_meeting_view_tour.js  *
*  Lines: 102                                                               *
****************************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_meeting_view_tour', ['@web/core/browser/browser', '@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { browser } = require("@web/core/browser/browser");
const { registry } = require("@web/core/registry");
const { dragenterFiles } = require("@web/../tests/utils");

const CLICK_ON_CHAT_STEP = "click-on-chat-action";

function getMeetingViewTourSteps({ inWelcomePage = false } = {}) {
    const steps = [
        { trigger: ".o-mail-Meeting" },
        {
            trigger: ".o-mail-Meeting [title='Invite People']",
            run: "click",
        },
        { trigger: ".o-mail-Meeting .o-mail-ActionPanel:contains('Invite people')" },
        {
            trigger: ".o-mail-Meeting [title='Invite People']", // close it
            run: "click",
        },
        { trigger: ".o-mail-Meeting:not(:has(.o-mail-ActionPanel))" },
        {
            trigger: ".o-mail-Meeting [title='Invite People']",
            run: "click",
        },
        { trigger: ".o-mail-Meeting .o-mail-ActionPanel:contains('Invite people')" },
        {
            trigger: ".o-mail-Meeting [title='Chat']",
            run: "click",
            content: CLICK_ON_CHAT_STEP,
        },
        {
            trigger:
                ".o-mail-Meeting .o-mail-ActionPanel .o-mail-Thread:contains('john (base.group_user) and bob (base.group_user)')",
        },
        {
            trigger: ".o-mail-Message[data-persistent]:contains('Hello everyone!')",
            run: "hover && click .o-mail-Message-actions button[title='Expand']",
        },
        {
            trigger: ".o-dropdown-item:contains('Mark as Unread')",
            run: "click",
        },
        { trigger: ".o-mail-Meeting [title='Chat']:has(.badge:contains(1))" },
        {
            trigger: ".o-mail-Thread-banner span:contains('Mark as Read')",
            run: "click",
        },
        {
            trigger: ".o-mail-Meeting [title='Chat']:not(:has(.badge))",
            async run({ waitFor }) {
                const files = [new File(["hi there"], "file2.txt", { type: "text/plain" })];
                await dragenterFiles(".o-mail-Meeting .o-mail-ActionPanel", files);
                // Ensure other dropzones such as discuss or chat window dropzones are not active in meeting view.
                await waitFor(".o-Dropzone", { only: true });
            },
        },
        {
            trigger: ".o-mail-Meeting [title='Close panel']",
            run: "click",
        },
        { trigger: ".o-mail-Meeting:not(:has(.o-mail-ActionPanel))" },
        {
            trigger: ".o-mail-Meeting [title='Exit Fullscreen']",
            run: "click",
        },
        { trigger: "body:not(:has(.o-mail-Meeting))" },
    ];
    if (inWelcomePage) {
        steps.unshift({ trigger: "[title='Join Channel']", run: "click" });
    }
    return steps;
}

registry
    .category("web_tour.tours")
    .add("discuss.meeting_view_tour", {
        steps: () => {
            // Avoid starting with mic/camera to prevent an unhandleable browser permission popup.
            browser.localStorage.setItem("discuss_call_preview_join_mute", "true");
            browser.localStorage.setItem("discuss_call_preview_join_video", "false");
            const steps = getMeetingViewTourSteps();
            const clickOnChatIndex = steps.find((step) => step.content === CLICK_ON_CHAT_STEP);
            steps.splice(
                clickOnChatIndex,
                0,
                {
                    trigger: ".o-mail-Composer.o-focused .o-mail-Composer-input",
                    run: "edit Hello everyone!",
                },
                { trigger: ".o-mail-Composer button[title='Send']:enabled", run: "click" }
            );
            return steps;
        },
    })
    .add("discuss.meeting_view_public_tour", {
        steps: () => getMeetingViewTourSteps({ inWelcomePage: true }),
    });

return __exports;
});
;

/**********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_channel_public_tour.js  *
*  Lines: 211                                                         *
**********************************************************************/
odoo.define('@mail/../tests/tours/discuss_channel_public_tour', ['@odoo/owl', '@web/core/registry', '@web/core/utils/urls', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { reactive } = require("@odoo/owl");
const { registry } = require("@web/core/registry");
const { getOrigin } = require("@web/core/utils/urls");
const { click, inputFiles } = require("@web/../tests/utils");

// The tour is ran twice, ensure the correct message is always targetted.
const messageSelector = ".o-mail-Message:has(.o-mail-Message-body:contains('cheese'))";
const editedMessageSelector = ".o-mail-Message:has(.o-mail-Message-body:contains('vegetables'))";

registry.category("web_tour.tours").add("discuss_channel_public_tour.js", {
    steps: () => [
        {
            trigger: ".o-mail-Discuss",
        },
        {
            trigger: ".o-mail-Thread",
            run() {
                if (!window.location.pathname.startsWith("/discuss/channel")) {
                    console.error("Channel secret token is still present in URL.");
                }
                const errors = odoo.loader.findErrors();
                if (Object.keys(errors).length) {
                    console.error("Couldn't load all JS modules.", errors);
                }
                document.body.classList.add("o_discuss_channel_public_modules_loaded");
                if (
                    !document.title.includes(
                        document.querySelector(".o-mail-DiscussContent-threadName")?.value
                    )
                ) {
                    console.error(
                        `Tab title should match conversation name. Got "${
                            document.title
                        }" instead of "${
                            document.querySelector(".o-mail-DiscussContent-threadName")?.value
                        }".`
                    );
                }
            },
        },
        {
            trigger: ".o_discuss_channel_public_modules_loaded",
        },
        {
            trigger: ".o-mail-Composer-input",
            run: "edit cheese",
        },
        { trigger: ".o-mail-Composer button[title='More Actions']", run: "click" },
        {
            trigger: ".dropdown-item:contains('Attach Files')",
            async run() {
                const text = new File(["hello, world"], "text.txt", { type: "text/plain" });
                await inputFiles(".o-mail-Composer .o_input_file", [text]);
            },
        },
        {
            trigger: ".o-mail-AttachmentContainer:not(.o-isUploading):contains(text.txt)",
        },
        {
            trigger: ".dropdown-item:contains('Attach Files')",
            async run() {
                await inputFiles(".o-mail-Composer .o_input_file", [
                    new File(
                        [
                            await (
                                await fetch(
                                    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2P4v5ThPwAG7wKklwQ/bwAAAABJRU5ErkJggg=="
                                )
                            ).blob(),
                        ],
                        "image.png",
                        { type: "image/png" }
                    ),
                ]);
            },
        },
        {
            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading)[title="image.png"]',
            async run({ waitFor }) {
                /** @type {import("models").Store} */
                const store = odoo.__WOWL_DEBUG__.root.env.services["mail.store"];
                if (store.self_guest) {
                    const src = this.anchor.querySelector("img").src;
                    const attachment = store["ir.attachment"].get(
                        (src.match("/web/image/([0-9]+)") || []).at(-1)
                    );
                    if (!attachment) {
                        throw new Error(`Attachment was not found from src: ${src}`);
                    }
                    if (!attachment.raw_access_token) {
                        await new Promise((resolve) => {
                            const proxy = reactive(attachment, () => {
                                if (attachment.raw_access_token) {
                                    resolve();
                                } else {
                                    void proxy.raw_access_token; // keep observing until a value is received
                                }
                            });
                            void proxy.raw_access_token; // start observing
                        });
                    }
                    await waitFor(
                        `.o-mail-AttachmentContainer[title="image.png"] img[src="${getOrigin()}/web/image/${
                            attachment.id
                        }?access_token=${attachment.raw_access_token}&filename=image.png&unique=${
                            attachment.checksum
                        }"]`
                    );
                }
            },
        },
        { trigger: ".o-mail-Composer button[title='Send']:enabled", run: "click" },
        {
            trigger: `${messageSelector}[data-persistent]`,
        },
        {
            trigger: `${messageSelector} .o-mail-AttachmentContainer:contains("text.txt")`,
        },
        {
            trigger: messageSelector,
            run: `hover && click ${messageSelector} [title='Add a Reaction']`,
        },
        {
            trigger: ".o-mail-QuickReactionMenu",
            run: () => click("[title='Toggle Emoji Picker']"),
        },
        {
            trigger: ".o-EmojiPicker .o-Emoji:contains('')",
            run: "click",
        },
        {
            trigger: `${messageSelector} .o-mail-MessageReaction:contains('')`,
            run: "click",
        },
        {
            trigger: `${messageSelector}:not(:has(.o-mail-MessageReaction:contains('')))`,
        },
        {
            trigger: `${messageSelector}`,
            run: `hover && click ${messageSelector} [title='Expand']`,
        },
        {
            trigger: `.o-mail-Message-moreMenu [title='Edit'], ${messageSelector} [title='Edit']`,
            run: "click",
        },
        {
            trigger: ".o-mail-Message .o-mail-Composer-input",
            run: "edit vegetables",
        },
        {
            trigger: ".o-mail-Message .o-mail-Composer button[title='More Actions']",
            run: "click",
        },
        {
            trigger: ".dropdown-item:contains('Attach Files')",
            async run() {
                const extratxt = new File(["hello 2"], "extra.txt", { type: "text/plain" });
                await inputFiles(".o-mail-Message .o_input_file", [extratxt]);
            },
        },
        {
            trigger:
                ".o-mail-Message .o-mail-Composer .o-mail-AttachmentContainer:not(.o-isUploading):contains(extra.txt)",
        },
        {
            trigger: ".o-mail-Message button:contains(save)",
            run: "click",
        },
        {
            trigger: editedMessageSelector,
        },
        {
            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains("text.txt")`,
        },
        {
            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains("extra.txt")`,
        },
        {
            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains("extra.txt") .o-mail-Attachment-unlink`,
            run: "click",
        },
        {
            trigger: ".modal:contains(Confirmation) .btn:contains(Ok)",
            run: "click",
        },
        {
            trigger: `${editedMessageSelector}:not(:has(.o-mail-AttachmentContainer:contains("extra.txt")))`,
        },
        {
            trigger: "button[title='Search Messages']",
            run: "click",
        },
        {
            trigger: ".o_searchview_input",
            run: "edit text.txt",
        },
        {
            trigger: "button[aria-label='Search button']",
            run: "click",
        },
        {
            trigger: `.o-mail-SearchMessagesPanel ${editedMessageSelector} .o-mail-AttachmentContainer:contains("text.txt")`,
        },
    ],
});

return __exports;
});
;

/*********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_configuration_tour.js  *
*  Lines: 84                                                         *
*********************************************************************/
odoo.define('@mail/../tests/tours/discuss_configuration_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add("discuss_configuration_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="mail.menu_root_discuss"]',
            run: "click",
        },
        {
            trigger: ".o_main_navbar button:contains('Configuration')",
            run: "click",
        },
        {
            trigger: ".dropdown-menu a:contains('Notification')",
            run: "click",
        },
        {
            trigger: "button:contains('All Messages')",
            run: "click",
        },
        {
            trigger: "button:contains('Mentions Only')",
            run: "click",
        },
        {
            trigger: "button:contains('Nothing')",
            run: "click",
        },
        {
            trigger: ".modal-header button[aria-label='Close']",
            run: "click",
        },
        {
            trigger: ".o_main_navbar button:contains('Configuration')",
            run: "click",
        },
        {
            trigger: ".dropdown-menu a:contains('Voice & Video')",
            run: "click",
        },
        {
            trigger: "select[name='inputDevice']",
        },
        {
            trigger: "button:contains('Voice Detection')",
            run: "click",
        },
        {
            trigger: "span:contains('Voice detection sensitivity')",
        },
        {
            trigger: "button:contains('Push to Talk')",
            run: "click",
        },
        {
            trigger: "label:contains('Push-to-talk key')",
        },
        {
            trigger: "label:contains('Delay after releasing push-to-talk')",
        },
        {
            trigger: "input[aria-label='Show video participants only']",
        },
        {
            trigger: "input[aria-label='Blur video background']",
            run: "click",
        },
        {
            trigger: "label:contains('Background blur intensity')",
        },
        {
            trigger: "label:contains('Edge blur intensity')",
        },
    ],
});

return __exports;
});
;

/******************************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_go_back_to_thread_from_breadcrumbs_tour.js  *
*  Lines: 17                                                                              *
******************************************************************************************/
odoo.define('@mail/../tests/tours/discuss_go_back_to_thread_from_breadcrumbs_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_go_back_to_thread_from_breadcrumbs.js", {
    steps: () => [
        { trigger: ".o-mail-DiscussContent-threadName[title='Inbox']" },
        { trigger: ".o-mail-DiscussSidebar-item:contains('Starred messages')", run: "click" },
        { trigger: "button[title='View or join channels']:not(:visible)", run: "click" },
        { trigger: ".breadcrumb-item:contains('Starred messages')", run: "click" },
        { trigger: ".o-mail-DiscussContent-threadName[title='Starred messages']" },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/discuss_invite_by_email_tour.js  *
*  Lines: 53                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/discuss_invite_by_email_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss.invite_by_email", {
    steps: () => [
        {
            trigger: "button[title='Invite People']",
            run: "click",
        },
        {
            trigger: ".o-discuss-ChannelInvitation-search[placeholder='Invite people or email']",
            run: "edit john@test.com",
        },
        {
            trigger: ".o-discuss-ChannelInvitation-selectable:contains('john (base.group_user)')",
            async run({ waitFor, click }) {
                await waitFor(".o-discuss-ChannelInvitation-selectable", {
                    only: true,
                    timeout: 5000,
                });
                await click();
            },
        },
        {
            trigger:
                ".o-discuss-ChannelInvitation-selectedList :contains('john (base.group_user)')",
        },
        {
            trigger: ".o-discuss-ChannelInvitation-search",
            run: "edit unknown_email@test.com",
        },
        {
            trigger: ".o-discuss-ChannelInvitation-selectable:contains('unknown_email@test.com')",
            run: "click",
        },
        {
            trigger:
                ".o-discuss-ChannelInvitation-selectedList :contains('unknown_email@test.com')",
        },
        {
            trigger: "button:contains(Invite to Group Chat)",
            run: "click",
        },
        {
            trigger: "body:not(:has(.o-mail-ActionPanel))",
        },
    ],
});

return __exports;
});
;

/***********************************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_mention_suggestions_group_restricted_channel.js  *
*  Lines: 23                                                                                   *
***********************************************************************************************/
odoo.define('@mail/../tests/tours/discuss_mention_suggestions_group_restricted_channel', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("discuss_mention_suggestions_group_restricted_channel.js", {
    steps: () => [
        { trigger: ".o-mail-DiscussContent-threadName[title='R&D Channel']" },
        { trigger: ".o-mail-Composer-input", run: "edit @" },
        { trigger: ".o-mail-Composer-suggestion:count(3)" },
        {
            content: "Suggest channel member not in R&D group",
            trigger: ".o-mail-Composer-suggestion strong:text(Consultant User)",
        },
        {
            content: "Suggest non-channel member in R&D group",
            trigger: ".o-mail-Composer-suggestion strong:text(Dev User)",
        },
    ],
});

return __exports;
});
;

/******************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_sidebar_in_public_page_tour.js  *
*  Lines: 55                                                                  *
******************************************************************************/
odoo.define('@mail/../tests/tours/discuss_sidebar_in_public_page_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("sidebar_in_public_page_tour", {
    steps: () => [
        {
            trigger: ".o-mail-DiscussContent-header [title='Channel 1']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2)",
            run: "click",
        },
        {
            trigger: ".o-mail-DiscussContent-header [title='Channel 2']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active",
            run() {
                history.back();
            },
        },
        {
            trigger: ".o-mail-DiscussContent-header [title='Channel 1']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active",
            run() {
                history.forward();
            },
        },
        {
            trigger: ".o-mail-DiscussContent-header [title='Channel 2']",
        },
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active",
        },
        {
            content: "Open channel actions",
            trigger: ".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active",
            run: "hover && click [title='Channel Actions']",
        },
        {
            trigger: ".o-dropdown-item:contains('Invite People')",
            run: "click",
        },
    ],
});

return __exports;
});
;

/**************************************************************************
*  Filepath: /mail/static/tests/tours/discuss_sub_channel_search_tour.js  *
*  Lines: 181                                                             *
**************************************************************************/
odoo.define('@mail/../tests/tours/discuss_sub_channel_search_tour', ['@mail/discuss/core/public_web/sub_channel_list', '@odoo/owl', '@web/core/registry', '@web/core/utils/concurrency', '@web/core/utils/patch', '@web/core/utils/reactive', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { SubChannelList } = require("@mail/discuss/core/public_web/sub_channel_list");

const { status } = require("@odoo/owl");

const { registry } = require("@web/core/registry");
const { Deferred } = require("@web/core/utils/concurrency");
const { patch } = require("@web/core/utils/patch");
const { effect } = require("@web/core/utils/reactive");
const { contains, dragenterFiles, dropFiles, scroll } = require("@web/../tests/utils");

let waitForLoadMoreToDisappearDef;
registry.category("web_tour.tours").add("test_discuss_sub_channel_search", {
    steps: () => [
        {
            trigger: "body",
            run() {
                patch(SubChannelList.prototype, {
                    setup() {
                        super.setup(...arguments);
                        effect(
                            (state) => {
                                if (status(this) === "destroyed") {
                                    return;
                                }
                                if (!state.isVisible) {
                                    waitForLoadMoreToDisappearDef?.resolve();
                                }
                            },
                            [this.loadMoreState]
                        );
                    },
                });
            },
        },
        {
            trigger: "button[title='Threads']",
            run: "click",
        },
        {
            trigger: ".o-mail-SubChannelList",
            async run() {
                // 30 newest sub channels are loaded initially.
                for (let i = 99; i > 69; i--) {
                    await contains(".o-mail-SubChannelPreview", {
                        text: `Sub Channel ${i}`,
                    });
                    await contains(".o-mail-SubChannelPreview", { count: 30 });
                }
            },
        },
        {
            trigger: ".o-mail-ActionPanel:has(.o-mail-SubChannelList) .o_searchview_input",
            run: "edit Sub Channel 10",
        },
        {
            trigger:
                ".o-mail-ActionPanel:has(.o-mail-SubChannelList) button[aria-label='Search button']",
            run: "click",
        },
        {
            trigger: ".o-mail-SubChannelPreview:contains(Sub Channel 10)",
            async run() {
                await contains(".o-mail-SubChannelPreview", { count: 1 });
                waitForLoadMoreToDisappearDef = new Deferred();
            },
        },
        {
            trigger: ".o_searchview_input",
            run: "clear",
        },
        {
            trigger: ".o-mail-SubChannelPreview:contains(Sub Channel 99)",
            async run() {
                await contains(".o-mail-SubChannelPreview", { count: 31 });
                // Already fetched sub channels are shown in addition to the one
                // that was fetched during the search.
                for (let i = 99; i > 69; i--) {
                    await contains(".o-mail-SubChannelPreview", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await contains(".o-mail-SubChannelPreview", { text: `Sub Channel 10` });
                // Ensure lazy loading is still working after a search.
                await waitForLoadMoreToDisappearDef;
                waitForLoadMoreToDisappearDef = new Deferred();
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelPreview:contains(Sub Channel 40)",
            async run() {
                await contains(".o-mail-SubChannelPreview", { count: 61 });
                for (let i = 99; i > 39; i--) {
                    await contains(".o-mail-SubChannelPreview", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await waitForLoadMoreToDisappearDef;
                waitForLoadMoreToDisappearDef = new Deferred();
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelPreview:contains(Sub Channel 11)",
            async run() {
                await contains(".o-mail-SubChannelPreview", { count: 90 });
                for (let i = 99; i > 9; i--) {
                    await contains(".o-mail-SubChannelPreview", {
                        text: `Sub Channel ${i}`,
                    });
                }
                await waitForLoadMoreToDisappearDef;
                await scroll(".o-mail-ActionPanel:has(.o-mail-SubChannelList)", "bottom");
            },
        },
        {
            trigger: ".o-mail-SubChannelPreview:contains(Sub Channel 0)",
            async run() {
                await contains(".o-mail-SubChannelPreview", { count: 100 });
                for (let i = 99; i > 0; i--) {
                    await contains(".o-mail-SubChannelPreview", {
                        text: `Sub Channel ${i}`,
                    });
                }
            },
        },
    ],
});

registry.category("web_tour.tours").add("create_thread_for_attachment_without_body", {
    steps: () => [
        {
            content: "Open general channel",
            trigger: '.o-mail-DiscussSidebarChannel-itemName:contains("general")',
            run: "click",
        },
        {
            content: "Drop a file",
            trigger: ".o-mail-DiscussContent-main",
            async run() {
                const files = [new File(["hi there"], "file2.txt", { type: "text/plain" })];
                await dragenterFiles(".o-mail-DiscussContent-main", files);
                await dropFiles(".o-Dropzone", files);
            },
        },
        {
            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading):contains("file2.txt")',
        },
        {
            content: "Click on send button",
            trigger: ".o-mail-Composer-mainActions [title='Send']:enabled",
            run: "click",
        },
        {
            content: "Hover on attachment",
            trigger:
                '.o-mail-Message:not(:has(.o-mail-Message-pendingProgress)) .o-mail-AttachmentContainer:contains("file2.txt")',
            run: "hover",
        },
        {
            content: "Click on expand button",
            trigger: '.o-mail-Message [title="Expand"]',
            run: "click",
        },
        {
            content: "Create a new thread",
            trigger: '.o-dropdown-item:contains("Create Thread")',
            run: "click",
        },
        {
            content: "Check a new thread is created",
            trigger: '.o-mail-Discuss:contains("New Thread")',
        },
    ],
});

return __exports;
});
;

/******************************************************************************
*  Filepath: /mail/static/tests/tours/mail_activity_schedule_from_chatter.js  *
*  Lines: 54                                                                  *
******************************************************************************/
odoo.define('@mail/../tests/tours/mail_activity_schedule_from_chatter', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("mail_activity_schedule_from_chatter", {
    steps: () => [
        {
            trigger: "button:contains('Activity')",
            run: "click",
        },
        {
            trigger: ".o_selection_badge span:contains('Call')",
            run: "click",
        },
        {
            trigger: ".o_selection_badge.active span:contains('Call')",
        },
        {
            trigger: ".o_selection_badge span:contains('To-Do')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Play Mario Party",
        },
        {
            trigger: "button:contains('Save')",
            run: "click",
        },
        {
            trigger: ".o-mail-Activity:contains('Play Mario Party')",
            run: "click",
        },
        {
            trigger: "button:contains('Activity')",
            run: "click",
        },
        {
            trigger: "div[name='summary'] input",
            run: "edit Play Mario Kart",
        },
        {
            trigger: "button.btn.btn-secondary:contains('Mark Done')",
            run: "click",
        },
        {
            trigger: ".o-mail-Message:contains('Play Mario Kart')",
        },
    ],
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /mail/static/tests/tours/mail_composer_autosave_tour.js  *
*  Lines: 50                                                          *
**********************************************************************/
odoo.define('@mail/../tests/tours/mail_composer_autosave_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add("mail/static/tests/tours/mail_composer_autosave_tour.js", {
    steps: () => [
        {
            content: "Edit the function field",
            trigger: ".o_field_widget[name='function'] > .o_input",
            run: "edit Director",
        },
        {
            trigger: ".o_form_sheet_bg",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: ".o-mail-Chatter-sendMessage",
            run: "click",
        },
        {
            content: "Open the full composer",
            trigger: "[name='open-full-composer']",
            run: "click",
        },
        {
            content: "Edit the body",
            trigger: ".o-wysiwyg div[contenteditable='true']",
            run: "editor Hello-- Mitchell Admin",
        },
        {
            content: "Click on Send Message",
            trigger: ".o_mail_send[name='action_send_mail']",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("Hello")',
        },
        {
            trigger: ".o_form_saved",
        },
        ...stepUtils.toggleHomeMenu(),
    ],
});

return __exports;
});
;

/******************************************************************
*  Filepath: /mail/static/tests/tours/mail_composer_test_tour.js  *
*  Lines: 284                                                     *
******************************************************************/
odoo.define('@mail/../tests/tours/mail_composer_test_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains, dragenterFiles, dropFiles, inputFiles } = require("@web/../tests/utils");

/**
 * This tour depends on data created by python test in charge of launching it.
 * It is not intended to work when launched from interface. It is needed to test
 * an action (action manager) which is not possible to test with QUnit.
 * @see mail/tests/test_mail_composer.py
 */
registry.category("web_tour.tours").add("mail/static/tests/tours/mail_composer_test_tour.js", {
    steps: () => [
        {
            content: "Wait for the chatter to be fully loaded",
            trigger: ".o-mail-Chatter",
            async run() {
                await contains(".o-mail-Message", { count: 1 });
            },
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write something in composer",
            trigger: ".o-mail-Composer-input",
            run: "edit blahblah @Not && click body",
        },
        {
            content: "Mention a partner",
            trigger: ".o-mail-Composer-suggestion:contains(Not A Demo User)",
            run: "click",
        },
        {
            content: "Add one file in composer",
            trigger: ".o-mail-Composer button[title='Attach Files']",
            async run() {
                const files = [new File(["hello, world"], "file1.txt", { type: "text/plain" })];
                await inputFiles(".o-mail-Composer .o_input_file", files);
            },
        },
        {
            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading):contains("file1.txt")',
        },
        {
            content: "Open full composer",
            trigger: "button[title='Open Full Composer']",
            run: "click",
        },
        {
            content: "Check composer keeps open after pushing Escape",
            trigger: ".o_mail_composer_form_view",
            run: "press Escape",
        },
        {
            content: "Check the earlier provided attachment is listed",
            trigger: ".o_field_mail_composer_attachment_list a:contains(file1.txt)",
        },
        {
            content: "Check subject is autofilled",
            trigger: '[name="subject"] input',
            run() {
                const subjectValue = document.querySelector('[name="subject"] input').value;
                if (subjectValue !== "Jane") {
                    console.error(
                        `Full composer should have "Jane" in subject input (actual: ${subjectValue})`
                    );
                }
            },
        },
        {
            content: "Check composer content is kept and contains the user's signature",
            trigger: '.o_field_html[name="body"]',
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                if (!bodyContent.includes("blahblah @Not A Demo User")) {
                    console.error(
                        `Full composer should contain text from small composer ("blahblah @Not A Demo User") in body input (actual: ${bodyContent})`
                    );
                }
                const mentionLink = document.querySelector(
                    '.o_field_html[name="body"] a'
                ).textContent;
                if (!mentionLink.includes("@Not A Demo User")) {
                    console.error(
                        `Full composer should contain mention link from small composer ("@Not A Demo User") in body input)`
                    );
                }
                /** When opening the full composer for the first time, the system
                 * should add the user's signature to the end of the message so
                 * that the user can edit it. After adding the signature to
                 * the editor, the server shouldn't automatically add the
                 * signature to the message (see: Python tests). */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 1) {
                    console.error("Full composer should contain the user's signature once.");
                }
            },
        },
        {
            content: "Drop a file on the full composer",
            trigger: ".o_mail_composer_form_view",
            async run() {
                const files = [new File(["hi there"], "file2.txt", { type: "text/plain" })];
                await dragenterFiles(".o_mail_composer_form_view .o_form_renderer", files);
                await dropFiles(".o-Dropzone", files);
            },
        },
        {
            content: "Check the attachment is listed",
            trigger: ".o_field_mail_composer_attachment_list a:contains(file2.txt)",
        },
        {
            content: "Click on the mail template selector",
            trigger: ".mail-composer-template-dropdown-btn",
            run: "click",
        },
        {
            content: "Check a template is listed",
            trigger:
                '.mail-composer-template-dropdown.popover .o-dropdown-item:contains("Test template")',
        },
        {
            content: "Verify admin template is NOT listed",
            trigger: ".mail-composer-template-dropdown.popover",
            run() {
                const hasAdminTemplate = [...document.querySelectorAll('.o-dropdown-item')]
                    .some(item => item.textContent.includes("Test template for admin"));
                if (hasAdminTemplate) {
                    console.error("Template assigned to the admin is visible to a non-assigned user! This should not happen.");
                }
            },
        },
        {
            content: "Send message from full composer",
            trigger: ".o_mail_send",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("blahblah @Not A Demo User")',
            run: "click",
        },
        {
            content: "Click on envelope to see recipients of message",
            trigger:
                '.o-mail-Message:has(.o-mail-Message-body:contains("blahblah @Not A Demo User")) .o-mail-Message-notification',
            run: "click",
        },
        {
            content: "Check message has correct recipients",
            trigger:
                ".o-mail-MessageNotificationPopover:contains('Not A Demo User (NotADemoUser@mail.com) Jane (jane@example.com) Mitchell Admin (test.admin@test.example.com)')",
        },
        {
            content: "Check message contains the first attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentContainer:contains("file1.txt")',
        },
        {
            content: "Check message contains the second attachment",
            trigger: '.o-mail-Message .o-mail-AttachmentContainer:contains("file2.txt")',
        },
        // Test the full composer input text is kept on closing
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Open full composer",
            trigger: "button[title='Open Full Composer']",
            run: "click",
        },
        {
            content: "Check that the composer contains the signature",
            trigger: '.o_field_html[name="body"]',
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                /** When opening the full composer, the system should add the
                 * user's signature, as this is a new message and the signature
                 * has not yet been added to it. */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 1) {
                    console.log("Full composer should contain the user's signature once.");
                }
            },
        },
        {
            content: "Write something in full composer",
            trigger: ".note-editable",
            run: "editor keep the content",
        },
        {
            content: "Close full composer",
            trigger: ".btn-close",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Check full composer text is kept",
            trigger: ".o-mail-Composer-input",
            run() {
                if (this.anchor.value !== "keep the content") {
                    console.error(
                        "Composer in chatter should contain full composer text after discarding."
                    );
                }
            },
        },
        {
            content: "Open full composer",
            trigger: "button[title='Open Full Composer']",
            run: "click",
        },
        {
            content: "Check that the composer doesn't add the user's signature twice",
            trigger: ".note-editable",
            run() {
                const bodyContent = document.querySelector(
                    '.o_field_html[name="body"]'
                ).textContent;
                /** When re-opening the full composer, the system shouldn't re-add
                 * the user's signature to the message. As the user deleted the
                 * signature in the previous steps (see: `editor keep the content`),
                 * the editor shouldn't contain any signature. */
                if ((bodyContent.match(/--\nErnest/g) || []).length !== 0) {
                    console.error("The composer should not contain the user's signature.");
                }
            },
        },
        {
            content: "Close full composer",
            trigger: ".btn-close",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Send message from chatter",
            trigger: ".o-mail-Composer-send:enabled",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("keep the content")',
        },
        // Test that the server automatically adds the user's signature to the
        // email when the user didn't open the full composer.
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write a message",
            trigger: ".o-mail-Composer-input",
            run: "edit hello world",
        },
        {
            content: "Send message from chatter",
            trigger: ".o-mail-Composer-send:enabled",
            run: "click",
        },
        {
            content: "Check message is shown",
            trigger: '.o-mail-Message-body:contains("hello world")',
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/mail_html_composer_test_tour.js  *
*  Lines: 105                                                          *
***********************************************************************/
odoo.define('@mail/../tests/tours/mail_html_composer_test_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains } = require("@web/../tests/utils");

/**
 * This tour depends on data created by python test in charge of launching it.
 * It is not intended to work when launched from interface. It is needed to test
 * an action (action manager) which is not possible to test with QUnit.
 * @see mail/tests/test_mail_composer.py
 */
registry.category("web_tour.tours").add("mail/static/tests/tours/mail_html_composer_test_tour.js", {
    steps: () => [
        {
            content: "Wait for the chatter to be fully loaded",
            trigger: ".o-mail-Chatter",
            async run() {
                const composerService = odoo.__WOWL_DEBUG__.root.env.services["mail.composer"];
                composerService.setHtmlComposer();
                await contains(".o-mail-Message", { count: 1 });
            },
        },
        {
            content: "Click on Send Message",
            trigger: "button:contains(Send message)",
            run: "click",
        },
        {
            content: "Write something in composer",
            trigger: ".o-mail-Composer-html.odoo-editor-editable",
            run: "editor Hello",
        },
        {
            content: "Select the text",
            trigger: ".o-mail-Composer-html.odoo-editor-editable",
            run: "dblclick",
        },
        {
            trigger: ".o-we-toolbar",
        },
        {
            content: "Bold the text",
            trigger: ".o-we-toolbar button[title='Toggle bold']",
            run: "click",
        },
        {
            content: "The bolded text is in the composer",
            trigger: ".o-mail-Composer-html.odoo-editor-editable strong:contains(Hello)",
        },
        {
            content: "Open full composer",
            trigger: "button[title='Open Full Composer']",
            run: "click",
        },
        {
            content: "Check composer keeps the formatted content",
            trigger: ".o_mail_composer_message strong:contains(Hello)",
        },
        {
            content: "Focus the text in full composer",
            trigger: ".o_mail_composer_message .odoo-editor-editable",
            run: "click",
        },
        {
            content: "Select the text in full composer",
            trigger: ".o_mail_composer_message .odoo-editor-editable",
            run: "dblclick",
        },
        {
            trigger: ".o-we-toolbar",
        },
        {
            content: "Remove the Bold",
            trigger: ".o-we-toolbar button[title='Toggle bold']",
            run: "click",
        },
        {
            content: "Italicize the text",
            trigger: ".o-we-toolbar button[title='Toggle italic']",
            run: "click",
        },
        {
            content: "The italicized text is in the full composer",
            trigger: ".o_mail_composer_message em:contains(Hello)",
        },
        {
            content: "Close full composer",
            trigger: ".btn-close",
            run: "click",
        },
        {
            content: "Click on Send Message",
            trigger: "button:not(.active):contains(Send message)",
            run: "click",
        },
        {
            content: "The italicized text is in the composer",
            trigger: ".o-mail-Composer-html.odoo-editor-editable em:contains(Hello)",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/mail_message_load_order_tour.js  *
*  Lines: 75                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/mail_message_load_order_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { contains, scroll } = require("@web/../tests/utils");

registry.category("web_tour.tours").add("mail_message_load_order_tour", {
    steps: () => [
        {
            trigger: ".o-mail-DiscussSidebarChannel:contains(MyTestChannel)",
            run: "click",
        },
        {
            trigger: ".o-mail-Thread .o-mail-Message",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 30 });
                await contains(".o-mail-Thread", { scroll: "bottom" });
            },
        },
        {
            trigger: "*[title='Pinned Messages']",
            run: "click",
        },
        {
            content: "Click on invisible jump (should hover card to be visible)",
            trigger: ".o-mail-MessageCard-jump:not(:visible)",
            run: "click",
        },
        {
            // Messages depends on FETCH_LIMIT (currently set to 60) in
            // the thread service. Thus, at first load the message range
            // will be (31 - 60). This trigger ensures the next messages
            // are fetched after jumping to the message.
            trigger:
                ".o-mail-Thread .o-mail-Message:first .o-mail-Message-textContent:not(:contains(31))",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 31 });
                await contains(".o-mail-Thread", { scroll: 0 });
                // ensure 1 - 31 are loaded in order: 30 below and the
                // one we're loading messages around.
                const messages = Array.from(
                    document.querySelectorAll(".o-mail-Thread .o-mail-Message-content")
                ).map((el) => el.innerText);
                for (let i = 0; i < 31; i++) {
                    if (messages[i] !== (i + 1).toString()) {
                        throw new Error("Wrong message order after loading around");
                    }
                }
                await scroll(".o-mail-Thread", "bottom");
            },
        },
        {
            // After jumping to the pinned message, the message range
            // was (1 -31): 30 before (but none were found), 30 after
            // and the pinned message itself. This trigger ensures the
            // next messages are fetched after scrolling to the bottom.
            trigger: ".o-mail-Thread .o-mail-Message .o-mail-Message-textContent:contains(17)",
            async run() {
                await contains(".o-mail-Thread .o-mail-Message", { count: 60 });
                // ensure 1 - 60  are loaded in order.
                const messages = Array.from(
                    document.querySelectorAll(".o-mail-Thread .o-mail-Message-content")
                ).map((el) => el.innerText);
                for (let i = 0; i < 60; i++) {
                    if (messages[i] !== (i + 1).toString()) {
                        throw new Error("Wrong message order after loading after");
                    }
                }
            },
        },
    ],
});

return __exports;
});
;

/*********************************************************************************
*  Filepath: /mail/static/tests/tours/mail_template_dynamic_placeholder_tour.js  *
*  Lines: 234                                                                    *
*********************************************************************************/
odoo.define('@mail/../tests/tours/mail_template_dynamic_placeholder_tour', ['@web/core/registry', '@web_tour/tour_utils', '@web/core/utils/concurrency'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");
const { delay } = require("@web/core/utils/concurrency");

registry.category("web_tour.tours").add("mail_template_dynamic_placeholder_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            content: 'Go into the Setting "app"',
            trigger: '.o_app[data-menu-xmlid="base.menu_administration"]',
            run: "click",
        },
        {
            content: "Open email templates",
            trigger: 'button[name="open_mail_templates"]',
            run: "click",
        },
        {
            content: "Create a new email template",
            trigger: "button.o_list_button_add",
            run: "click",
        },
        {
            content: 'Insert # inside "Subject" input',
            trigger: 'div[name="subject"] input[type="text"]',
            run: "edit(no_model_id #)",
        },
        {
            content: 'Select "Contact" model',
            trigger: 'div[name="model_id"] input[type="text"]',
            run: "edit Contact",
        },
        {
            content: "Wait for the autocomplete RPC",
            trigger: 'div[name="model_id"] .ui-autocomplete:contains("Contact")',
            run: async () => {
                await delay(300);
            },
        },
        {
            content: "Click on contact",
            trigger: 'div[name="model_id"] .ui-autocomplete',
            run: async function () {
                const contact = Array.from(
                    document.querySelectorAll(
                        'div[name="model_id"] .ui-autocomplete .dropdown-item'
                    )
                ).find((el) => el.textContent === "Contact");
                await contact.click();
            },
        },
        {
            content: "Wait for the drop down to disappear",
            trigger: 'div[name="model_id"] .o-autocomplete:not(:has(.ui-autocomplete))',
            run: async () => {
                // Ensure the system has registered a correct model value before
                // we try to open the DPH.
                // It seems that the autocomplete validation can be very slow.
                await delay(200);
            },
        },
        {
            content: 'Retry insert # inside "Subject" input',
            trigger: 'div[name="subject"] input[type="text"]',
            run: "edit (yes_model_id) && press #",
        },
        {
            content: "Check if the dynamic placeholder popover is opened",
            trigger: "div.o_model_field_selector_popover",
        },
        {
            content: "filter the dph result",
            trigger: "div.o_model_field_selector_popover_search input[type='text']",
            run: "edit name",
        },
        {
            content: "Click on the first entry of the dynamic placeholder",
            trigger: 'div.o_model_field_selector_popover button:contains("Company Name")',
            run: "click",
        },
        {
            content: "Enter a default value",
            trigger:
                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type="text"]',
            run: "edit defValue",
        },
        {
            content: "Click on the insert button",
            trigger: "div.o_model_field_selector_popover button:first-child",
            run: "click",
        },
        {
            content: "Wait for the popover to disappear",
            trigger: "body:not(:has(.o_model_field_selector_popover))",
            run: "click",
        },
        {
            content: "Check if subject value was correctly updated",
            trigger: 'div[name="subject"] input[type="text"]',
            run() {
                const subjectValue = this.anchor.value;
                const correctValue = "yes_model_id {{object.company_name|||defValue}}";
                if (subjectValue !== correctValue) {
                    console.error(
                        `Email template should have "${correctValue}" in subject input (actual: ${subjectValue})`
                    );
                }
            },
        },
        {
            content: "Insert text inside editable",
            trigger: ".note-editable.odoo-editor-editable",
            async run(actions) {
                await actions.editor(`/`);
                document.querySelector(".note-editable").dispatchEvent(
                    new InputEvent("input", {
                        inputType: "insertText",
                        data: "/",
                    })
                );
            },
        },
        {
            content: "Click on the the dynamic placeholder powerBox options",
            trigger: "div.o-we-powerbox .o-we-command:contains(Dynamic Placeholder)",
            run: "click",
        },
        {
            content: "Check if the dynamic placeholder popover is opened",
            trigger: "div.o_model_field_selector_popover",
            run: "click",
        },
        {
            content: "filter the dph result",
            trigger: "div.o_model_field_selector_popover_search input[type='text']",
            run: "edit name",
        },
        {
            content: "Click on the first entry of the dynamic placeholder",
            trigger: 'div.o_model_field_selector_popover button:contains("Company Name")',
            run: "click",
        },
        {
            content: "Enter a default value",
            trigger:
                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type="text"]',
            run: "edit defValue",
        },
        {
            content: "Click on the insert button",
            trigger: "div.o_model_field_selector_popover button:first-child",
            run: "click",
        },
        {
            content: "Ensure the editable contain the dynamic placeholder t tag",
            trigger: `.note-editable.odoo-editor-editable t[t-out="object.company_name"]:contains("defValue")`,
        },
        {
            content: 'Type "Push Notification Device" model',
            trigger: 'div[name="model_id"] input[type="text"]',
            run: "edit Push Notification Device",
        },
        {
            content: 'Select "Push Notification Device" model',
            trigger: 'a.dropdown-item:contains("Push Notification Device")',
            run: "click",
        },
        {
            content: "Insert text inside editable",
            trigger: ".note-editable.odoo-editor-editable",
            async run(actions) {
                await actions.editor(`/`);
                document.querySelector(".note-editable").dispatchEvent(
                    new InputEvent("input", {
                        inputType: "insertText",
                        data: "/",
                    })
                );
            },
        },
        {
            content: "Click on the the dynamic placeholder powerBox options",
            trigger: "div.o-we-powerbox .o-we-command:contains(Dynamic Placeholder)",
            run: "click",
        },
        {
            content: "Check if the dynamic placeholder popover is opened",
            trigger: "div.o_model_field_selector_popover",
            run: "click",
        },
        {
            content: "filter the dph result",
            trigger: "div.o_model_field_selector_popover_search input[type='text']",
            run: "edit created on",
        },
        {
            content: "Click on the first entry of the dynamic placeholder",
            trigger:
                'div.o_model_field_selector_popover li:first-child button:contains("Created on")',
            run: "click",
        },
        {
            content: "Enter a default value",
            trigger:
                "div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type='text']",
            run: "edit localTime",
        },
        {
            content: "Click on the insert button",
            trigger: "div.o_model_field_selector_popover button:first-child:contains('Insert)",
            run: "click",
        },
        {
            content: "Ensure the editable contain the dynamic placeholder t tag",
            trigger: `.note-editable.odoo-editor-editable t[t-out="format_datetime(object.create_date, tz=object.partner_id.tz) or 'localTime'"]:contains("localTime")`,
        },
        {
            content: "Discard form changes",
            trigger: "button.o_form_button_cancel",
            run: "click",
        },
        {
            content: "Wait for the form view to disappear",
            trigger: "body:not(:has(.o_form_sheet))",
        },
    ],
});

return __exports;
});
;

/***********************************************************************
*  Filepath: /mail/static/tests/tours/user_modify_own_profile_tour.js  *
*  Lines: 46                                                           *
***********************************************************************/
odoo.define('@mail/../tests/tours/user_modify_own_profile_tour', ['@web/core/registry', '@web/../tests/utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { click, contains } = require("@web/../tests/utils");

/**
 * Verify that a user can modify their own profile information.
 */
registry.category("web_tour.tours").add("mail/static/tests/tours/user_modify_own_profile_tour.js", {
    steps: () => [
        {
            content: "Open user account menu",
            trigger: ".o_user_menu button",
            run: "click",
        },
        {
            content: "Open preferences / profile screen",
            trigger: "[data-menu=preferences]",
            run: "click",
        },
        {
            content: "Update the notification type",
            trigger: '.modal div[name="notification_type"] input[data-value="inbox"]',
            async run() {
                await click('.modal div[name="notification_type"] input[data-value="inbox"]');
                await contains(".o_form_dirty", { count: 1 });
            },
        },
        {
            content: "Save the form",
            trigger: 'button[name="preference_save"]',
            run: "click",
        },
        {
            content: "Wait until the modal is closed",
            trigger: "body:not(.modal-open)",
            async run() {
                await contains(".o_form_dirty", { count: 0 });
            },
        },
    ],
});

return __exports;
});
;

/***************************************************
*  Filepath: /portal/static/tests/tours/portal.js  *
*  Lines: 39                                       *
***************************************************/
odoo.define('@portal/../tests/tours/portal', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("portal_load_homepage", {
    url: "/my",
    steps: () => [
        {
            content: "Check portal is loaded",
            trigger: 'a[href*="/my/account"]:contains("Edit"):first',
            run: "click",
            expectUnloadPage: true,
        },
        {
            content: "Load my account details",
            trigger: 'input[value="Joel Willis"]',
            run: "click",
        },
        {
            content: "type a different phone number",
            trigger: 'input[name="phone"]',
            run: "edit +1 555 666 7788",
        },
        {
            content: "Submit the form",
            trigger: "button[id=save_address]",
            run: "click",
            expectUnloadPage: true,
        },
        {
            content: "Check that we are back on the portal",
            trigger: 'a[href*="/my/account"]:contains("Edit"):first',
        },
    ],
});

return __exports;
});
;

/************************************************************
*  Filepath: /portal/static/tests/tours/skip_to_content.js  *
*  Lines: 27                                                *
************************************************************/
odoo.define('@portal/../tests/tours/skip_to_content', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("skip_to_content", {
    url: "/",
    steps: () => [
        {
            content: "Make sure that Skip to Content button is on top of all the links present in header",
            trigger: "a:first-child[class~='o_skip_to_content']",
            run: "click"
        },
        {
            content: "Check if we have been redirected to #wrap",
            trigger: "body",
            run: () => {
                if (!window.location.href.endsWith("#wrap")) {
                    console.error("We should be on #wrap.");
                }
            }
        }
    ]
});

return __exports;
});
;

/*********************************************************
*  Filepath: /account/static/src/js/tours/tour_utils.js  *
*  Lines: 62                                             *
*********************************************************/
odoo.define('@account/js/tours/tour_utils', [], function (require) {
'use strict';
let __exports = {};
__exports.addSectionFromProductCatalog = addSectionFromProductCatalog; function addSectionFromProductCatalog() {
    return [
        {
            content: "Click Catalog Button",
            trigger: 'button[name=action_add_from_catalog]',
            run: 'click',
        },
        {
            content: "Click 'Add Section' button",
            trigger: '.o_search_panel_sections button:contains("+ Add Section")',
            run: 'click',
        },
        {
            content: "Type new section name",
            trigger: 'input.o_section_input',
            run: 'edit Section A',
        },
        {
            content: "Click anywhere to add the section",
            trigger: '.o_search_panel',
            run: 'click',
        },
        {
            content: "Check section A is selected",
            trigger: '.o_search_panel_sections .o_selected_section:contains("Section A")',
        },
        {
            content: "Add a Product",
            trigger: '.o_kanban_record:contains("Test Product")',
            run: function () {
                setTimeout(() => {
                    [...document.querySelectorAll('.o_kanban_record')].find(el =>
                        el.textContent.includes('Test Product')
                    )?.click();
                }, 1000);
            },
        },
        {
            content: "Wait for product to be added",
            trigger: '.o_kanban_record:contains("Test Product"):not(:has(.fa-shopping-cart))',
        },
        {
            content: "Close the catalog",
            trigger: '.o-kanban-button-back',
            run: 'click',
        },
        {
            content: "Ensure Section is first row",
            trigger: '.o_section_and_note_list_view tr:nth-child(1).o_is_line_section',
        },
        {
            content: "Ensure Product is second row",
            trigger: 'tbody tr:nth-child(2) .o_field_product_label_section_and_note_cell:contains("Test Product")',
        },
    ];
}

return __exports;
});
;

/***************************************************************************
*  Filepath: /account/static/tests/tours/account_product_catalog_tests.js  *
*  Lines: 40                                                               *
***************************************************************************/
odoo.define('@account/../tests/tours/account_product_catalog_tests', ['@account/js/tours/tour_utils', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { addSectionFromProductCatalog } = require("@account/js/tours/tour_utils");
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("test_use_product_catalog_on_invoice", {
    steps: () => [
        {
            content: "Click Catalog Button",
            trigger: "button[name=action_add_from_catalog]",
            run: "click",
        },
        {
            content: "Add a Product",
            trigger: ".o_kanban_record:contains(Test Product)",
            run: "click",
        },
        {
            content: "Wait for it",
            trigger: ".o_product_added",
        },
        {
            content: "Back to Invoice",
            trigger: ".o-kanban-button-back",
            run: "click",
        },
        {
            content: "Ensure product is added",
            trigger: ".o_field_product_label_section_and_note_cell:contains(Test Product)",
        },
    ],
});

registry.category("web_tour.tours").add('test_add_section_from_product_catalog_on_invoice', {
    steps: () => addSectionFromProductCatalog()
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /account/static/tests/tours/deductible_amount_column.js  *
*  Lines: 29                                                          *
**********************************************************************/
odoo.define('@account/../tests/tours/deductible_amount_column', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require('@web/core/registry');
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add("deductible_amount_column", {
    url: "/odoo/vendor-bills/new",
    steps: () => [
    {
        content: "Add item",
        trigger: "div[name='invoice_line_ids'] .o_field_x2many_list_row_add a:contains('Add a line')",
        run: "click",
    },
    {
        content: "Edit name",
        trigger: ".o_field_widget[name='name'] .o_input",
        run: "edit Laptop"
    },
    {
        content: "Edit deductible amount",
        trigger: ".o_field_widget[name='deductible_amount'] > .o_input",
        run: "edit 80"
    },
    ...stepUtils.saveForm(),
]})

return __exports;
});
;

/*************************************************************
*  Filepath: /account/static/tests/tours/tax_group_tests.js  *
*  Lines: 148                                                *
*************************************************************/
odoo.define('@account/../tests/tours/tax_group_tests', ['@account/js/tours/account', '@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { accountTourSteps } = require("@account/js/tours/account");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add('account_tax_group', {
    url: "/odoo",
    steps: () => [
    ...accountTourSteps.goToAccountMenu("Go to Invoicing"),
    {
        content: "Go to Vendors",
        trigger: 'span:contains("Vendors")',
        run: "click",
    },
    {
        content: "Go to Bills",
        trigger: 'a:contains("Bills")',
        run: "click",
    },
    {
        trigger: ".o_breadcrumb .text-truncate:contains(Bills)",
    },
    {
        content: "Create new bill",
        trigger: '.o_control_panel_main_buttons .o_list_button_add',
        run: "click",
    },
    // Set a vendor
    {
        content: "Add vendor",
        trigger: 'div.o_field_widget.o_field_res_partner_many2one[name="partner_id"] div input',
        run: "edit Account Tax Group Partner",
    },
    {
        content: "Valid vendor",
        trigger: '.ui-menu-item a:contains("Account Tax Group Partner")',
        run: "click",
    },
    // Show product column
    {
        content: "Open line fields list",
        trigger: ".o_optional_columns_dropdown_toggle",
        run: "click"
    },
    {
        content: "Show product column",
        trigger: '.o-dropdown-item input[name="product_id"]',
        run: "click"
    },
    {
        content: "Close line fields list",
        trigger: ".o_optional_columns_dropdown_toggle",
        run: "click"
    },
    // Add First product
    {
        content: "Add items",
        trigger: 'div[name="invoice_line_ids"] .o_field_x2many_list_row_add a:contains("Add a line")',
        run: "click",
    },
    {
        content: "Select input",
        trigger: 'div[name="invoice_line_ids"] .o_selected_row .o_list_many2one[name="product_id"] input',
        run: "edit Account Tax Group Product",
    },
    {
        content: "Valid item",
        trigger: '.ui-menu-item-wrapper:contains("Account Tax Group Product")',
        run: "click",
    },
    // Save account.move
    ...stepUtils.saveForm(),
    // Edit tax group amount
    {
        content: "Edit tax group amount",
        trigger: '.o_tax_group_edit',
        run: "click",
    },
    {
        content: "Modify the input value",
        trigger: '.o_tax_group_edit_input input',
        run() {
            this.anchor.value = 200;
            this.anchor.select();
            this.anchor.blur();
        },
    },
    // Check new value for total (with modified tax_group_amount).
    {
        content: "Valid total amount",
        trigger: 'span[name="amount_total"]:contains("800")',
        run: "click",
    },
    // Modify the quantity of the object
    {
        content: "Select item quantity",
        trigger: 'div[name="invoice_line_ids"] tbody tr.o_data_row .o_list_number[name="quantity"]',
        run: "click",
    },
    {
        content: "Change item quantity",
        trigger: 'div[name="invoice_line_ids"] tbody tr.o_data_row .o_list_number[name="quantity"] input',
        run: "edit 2",
    },
    {
        content: "Valid the new value",
        trigger: 'div[name="invoice_line_ids"] tbody tr.o_data_row .o_list_number[name="quantity"] input',
        run: "press Enter",
    },
    // Check new tax group value
    {
        content: "Check new value of tax group",
        trigger: '.o_tax_group_amount_value:contains("120")',
        run: "click",
    },
    // Save form
    ...stepUtils.saveForm(),
    // Check new tax group value
    {
        content: "Check new value of tax group",
        trigger: '.o_tax_group_amount_value:contains("120")',
        run: "click",
    },
    {
        content: "Edit tax value",
        trigger: '.o_tax_group_edit_input input',
        run: "edit 2 && click body",
    },
    {
        content: "Check new value of total",
        trigger: '.oe_subtotal_footer_separator:contains("1,202")',
        run: "click",
    },
    {
        content: "Discard changes",
        trigger: '.o_form_button_cancel',
        run: "click",
    },
    {
        content: "Check tax value is reset",
        trigger: '.o_tax_group_amount_value:contains("120")',
    },
]});

return __exports;
});
;

/*************************************************************************
*  Filepath: /account/static/tests/tours/tour_tests_shared_js_python.js  *
*  Lines: 22                                                             *
*************************************************************************/
odoo.define('@account/../tests/tours/tour_tests_shared_js_python', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add('tests_shared_js_python', {
    url: "/account/init_tests_shared_js_python",
    steps: () => [
    {
        content: "Click",
        trigger: 'button',
        run: "click",
    },
    {
        content: "Wait",
        trigger: 'button.text-success',
        timeout: 3000,
    },
]});

return __exports;
});
;

/****************************************************************************
*  Filepath: /sale/static/tests/tours/mail_attachment_removal_test_tour.js  *
*  Lines: 38                                                                *
****************************************************************************/
odoo.define('@sale/../tests/tours/mail_attachment_removal_test_tour', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add("mail_attachment_removal_tour", {
    steps: () => [

    {
        content: "click on send by email",
        trigger: ".o_statusbar_buttons > button[name='action_quotation_send']",
        run: "click"
    },
    {
        content: "save a new layout",
        trigger: ".o_technical_modal button[name='document_layout_save']",
        run: "click"
    },
    {
        content: "delete attachment",
        trigger: ".o_field_widget[name='attachment_ids'] li > button .fa-times",
        run: "click"
    },
    {
        content: "send the email",
        trigger: ".o_mail_send",
        run: "click"
    },
    {
        content: "confirm quotation",
        trigger: "button[name='action_confirm']",
        run: "click"
    }
]
})

return __exports;
});
;

/***********************************************************************
*  Filepath: /sale/static/tests/tours/product_attribute_value_tour.js  *
*  Lines: 62                                                           *
***********************************************************************/
odoo.define('@sale/../tests/tours/product_attribute_value_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

const openProductAttribute = (product_attribute) => [
    ...stepUtils.goToAppSteps("sale.sale_menu_root", "Go to the Sales App"),
    {
        content: 'Open configuration menu',
        trigger: '.o-dropdown[data-menu-xmlid="sale.menu_sale_config"]',
        run: "click",
    },
    {
        content: 'Navigate to product attribute list view',
        trigger: '.o-dropdown-item[data-menu-xmlid="sale.menu_product_attribute_action"]',
        run: "click",
    },
    {
        content: `Navigate to ${product_attribute}`,
        trigger: `.o_data_cell[data-tooltip=${product_attribute}]`,
        run: "click",
    },
];
const deletePAV = (product_attribute_value, message) => [
    {
        content: 'Click delete button',
        trigger: `.o_data_cell[data-tooltip=${product_attribute_value}] ~ .o_list_record_remove`,
        run: "click",
    },
    {
        content: 'Check correct message in modal',
        trigger: message || '.modal-title:contains("Bye-bye, record!")',
        run: "click",
    },
    {
        content: 'Close modal',
        trigger: '.btn-close',
        run: "click",
    }
]

// This tour relies on data created on the Python test.
registry.category("web_tour.tours").add('delete_product_attribute_value_tour', {
    url: '/odoo',
    steps: () => [
        ...openProductAttribute("PA"),
        // Test error message on a used attribute value
        ...deletePAV("pa_value_1", ".text-prewrap:contains('pa_value_1')"),
        // Test deletability of a used attribute value on archived product
        ...deletePAV("pa_value_2"),
        // Test deletability of a removed attribute value on product
        ...deletePAV("pa_value_3"),
        {
            content: 'Check test finished',
            trigger: 'a:contains("Attributes")',
        }
    ]
});

return __exports;
});
;

/*******************************************************
*  Filepath: /sale/static/tests/tours/sale_catalog.js  *
*  Lines: 104                                          *
*******************************************************/
odoo.define('@sale/../tests/tours/sale_catalog', ['@account/js/tours/tour_utils', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { addSectionFromProductCatalog } = require("@account/js/tours/tour_utils");
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add('sale_catalog', {
    steps: () => [
        {
            content: "Create a new SO",
            trigger: '.o_list_button_add',
            run: 'click',
        },
        {
            content: "Select the customer field",
            trigger: ".o_field_res_partner_many2one input.o_input",
            run: 'click',
        },
        {
            content: "Wait for the field to be active",
            trigger: ".o_field_res_partner_many2one input[aria-expanded=true]",
        },
        {
            content: "Select a customer from the dropdown",
            trigger: ".o_field_res_partner_many2one .dropdown-item:not([id$='_loading']):first",
            run: 'click',
        },
        {
            content: "Open product catalog",
            trigger: 'button[name="action_add_from_catalog"]',
            run: 'click',
        },
        {
            content: "Type 'Restricted' into the search bar",
            trigger: 'input.o_searchview_input',
            run: "edit Restricted",
        },
        {
            content: "Search for the product",
            trigger: 'input.o_searchview_input',
            run: "press Enter",
        },
        {
            content: "Wait for catalog rendering",
            trigger: '.o_kanban_record:contains("Restricted Product")',
        },
        {
            content: "Wait for filtering",
            trigger: '.o_kanban_renderer:not(:has(.o_kanban_record:contains("AAA Product")))',
        },
        {
            content: "Add the product to the SO",
            trigger: '.o_kanban_record:contains("Restricted Product") .fa-shopping-cart',
            run: 'click',
        },
        {
            content: "Wait for product to be added",
            trigger: '.o_kanban_record:contains("Restricted Product"):not(:has(.fa-shopping-cart))',
        },
        {
            content: "Input a custom quantity",
            trigger: '.o_kanban_record:contains("Restricted Product") .o_input',
            run: "edit 6",
        },
        {
            content: "Increase the quantity",
            trigger: '.o_kanban_record:contains("Restricted Product") .fa-plus',
            run: 'click',
        },
        {
            content: "Close the catalog",
            trigger: '.o-kanban-button-back',
            run: 'click',
        },
    ]
});

registry.category("web_tour.tours").add('test_add_section_from_product_catalog_on_sale_order', {
    steps: () => [
        {
            content: "Create a new SO",
            trigger: '.o_list_button_add',
            run: 'click',
        },
        {
            content: "Select the customer field",
            trigger: '.o_field_res_partner_many2one input.o_input',
            run: 'click',
        },
        {
            content: "Wait for the field to be active",
            trigger: '.o_field_res_partner_many2one input[aria-expanded=true]',
        },
        {
            content: "Select a customer from the dropdown",
            trigger: '.o_field_res_partner_many2one .dropdown-item:not([id$="_loading"]):first',
            run: 'click',
        },
        ...addSectionFromProductCatalog(),
    ]
});

return __exports;
});
;

/******************************************************************
*  Filepath: /sale/static/tests/tours/sale_combo_configurator.js  *
*  Lines: 142                                                     *
******************************************************************/
odoo.define('@sale/../tests/tours/sale_combo_configurator', ['@web/core/registry', '@web_tour/tour_utils', '@sale/js/tours/combo_configurator_tour_utils', '@sale/js/tours/product_configurator_tour_utils', '@sale/js/tours/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require('@web/core/registry');
const { stepUtils } = require('@web_tour/tour_utils');
const comboConfiguratorTourUtils = require('@sale/js/tours/combo_configurator_tour_utils')[Symbol.for("default")];
const productConfiguratorTourUtils = require('@sale/js/tours/product_configurator_tour_utils')[Symbol.for("default")];
const tourUtils = require('@sale/js/tours/tour_utils')[Symbol.for("default")];

registry
    .category('web_tour.tours')
    .add('sale_combo_configurator', {
        url: '/odoo',
        steps: () => [
            ...stepUtils.goToAppSteps('sale.sale_menu_root', "Open the sales app"),
            ...tourUtils.createNewSalesOrder(),
            ...tourUtils.selectCustomer("Test Partner"),
            ...tourUtils.addProduct("Combo product"),
            // Assert that the combo configurator has the correct data.
            comboConfiguratorTourUtils.assertComboCount(2),
            comboConfiguratorTourUtils.assertComboItemCount("Combo A", 2),
            comboConfiguratorTourUtils.assertComboItemCount("Combo B", 2),
            // Assert that price changes when the quantity is updated.
            comboConfiguratorTourUtils.assertQuantity(1),
            comboConfiguratorTourUtils.assertPrice('25.00'),
            comboConfiguratorTourUtils.increaseQuantity(),
            comboConfiguratorTourUtils.assertQuantity(2),
            comboConfiguratorTourUtils.assertPrice('50.00'),
            comboConfiguratorTourUtils.decreaseQuantity(),
            comboConfiguratorTourUtils.assertQuantity(1),
            comboConfiguratorTourUtils.assertPrice('25.00'),
            comboConfiguratorTourUtils.setQuantity(3),
            comboConfiguratorTourUtils.assertQuantity(3),
            comboConfiguratorTourUtils.assertPrice('75.00'),
            // Assert that the combo configurator can only be saved after selecting an item for each
            // combo.
            comboConfiguratorTourUtils.assertConfirmButtonDisabled(),
            comboConfiguratorTourUtils.selectComboItem("Product A2"),
            comboConfiguratorTourUtils.selectComboItem("Product B2"),
            comboConfiguratorTourUtils.assertConfirmButtonEnabled(),
            // Assert that the product configurator is opened when a product with configurable
            // `no_variant` PTALs is selected.
            comboConfiguratorTourUtils.selectComboItem("Product A1"),
            productConfiguratorTourUtils.selectAttribute("Product A1", "No variant attribute", "A"),
            ...productConfiguratorTourUtils.saveConfigurator(),
            // Assert that the extra price of a combo item is applied correctly.
            comboConfiguratorTourUtils.assertPrice('90.00'),
            // Assert that the extra price of a `no_variant` PTAV is applied correctly.
            comboConfiguratorTourUtils.selectComboItem("Product A1"),
            ...productConfiguratorTourUtils.selectAndSetCustomAttribute(
                "Product A1", "No variant attribute", "B", "Some custom value"
            ),
            ...productConfiguratorTourUtils.saveConfigurator(),
            comboConfiguratorTourUtils.assertPrice('93.00'),
            // Assert that the order's content is correct.
            ...comboConfiguratorTourUtils.saveConfigurator(),
            tourUtils.checkSOLDescriptionContains("Combo product x 3"),
            tourUtils.checkSOLDescriptionContains(
                "Product A1", "No variant attribute: B: Some custom value"
            ),
            tourUtils.checkSOLDescriptionContains("Product B2"),
            {
                content: "Verify the combo item quantities",
                trigger: 'td[name="product_uom_qty"]:contains(3.00)',
            },
            {
                content: "Verify the first combo item's unit price",
                trigger: 'td[name="price_unit"]:contains(18.50)',
            },
            {
                content: "Verify the second combo item's unit price",
                trigger: 'td[name="price_unit"]:contains(12.50)',
            },
            {
                content: "Verify the order's total price",
                trigger: 'div.oe_subtotal_footer:contains(93.00)',
            },
            // Assert that the combo configurator is opened with the previous selection when the
            // combo is edited.
            tourUtils.editLineMatching("Combo product x 3"),
            tourUtils.editConfiguration(),
            comboConfiguratorTourUtils.setQuantity(2),
            comboConfiguratorTourUtils.assertComboItemSelected("Product A1"),
            comboConfiguratorTourUtils.assertComboItemSelected("Product B2"),
            comboConfiguratorTourUtils.selectComboItem("Product A2"),
            // Assert that the order's content has been updated.
            ...comboConfiguratorTourUtils.saveConfigurator(),
            tourUtils.checkSOLDescriptionContains("Combo product x 2"),
            tourUtils.checkSOLDescriptionContains("Product A2"),
            tourUtils.checkSOLDescriptionContains("Product B2"),
            {
                content: "Verify the combo item quantities",
                trigger: 'td[name="product_uom_qty"]:contains(2.00)',
            },
            {
                content: "Verify the first combo item's unit price",
                trigger: 'td[name="price_unit"]:contains(12.50)',
            },
            {
                content: "Verify the second combo item's unit price",
                trigger: 'td[name="price_unit"]:contains(12.50)',
            },
            {
                content: "Verify the order's total price",
                trigger: 'div.oe_subtotal_footer:contains(50.00)',
            },
            // Don't end the tour with a form in edition mode.
            ...stepUtils.saveForm(),
        ],
    });

    registry
    .category('web_tour.tours')
    .add('sale_combo_configurator_with_optional_products', {
        url: '/odoo',
        steps: () => [
            ...stepUtils.goToAppSteps('sale.sale_menu_root', "Open the sales app"),
            ...tourUtils.createNewSalesOrder(),
            ...tourUtils.selectCustomer("Test Partner"),
            ...tourUtils.addProduct("Combo product"),
            comboConfiguratorTourUtils.selectComboItem("Product B2"),
            ...comboConfiguratorTourUtils.saveConfigurator(),
            productConfiguratorTourUtils.addOptionalProduct("Optional product"),
            {
                content: "verify that we cannot reduce main product quantity",
                trigger: ':not(button[name="sale_quantity_button_minus"])',
            },
            {
                content: "verify that we cannot increase main product quantity",
                trigger: ':not(button[name="sale_quantity_button_plus"])',
            },
            ...productConfiguratorTourUtils.saveConfigurator(),
            tourUtils.checkSOLDescriptionContains("Combo product"),
            tourUtils.checkSOLDescriptionContains("Product B2"),
            tourUtils.checkSOLDescriptionContains("Optional product"),
            // Don't end the tour with a form in edition mode.
            ...stepUtils.saveForm(),
        ],
    });

return __exports;
});
;

/****************************************************************************************************
*  Filepath: /sale/static/tests/tours/sale_combo_configurator_preconfigure_unconfigurable_ptals.js  *
*  Lines: 43                                                                                        *
****************************************************************************************************/
odoo.define('@sale/../tests/tours/sale_combo_configurator_preconfigure_unconfigurable_ptals', ['@web/core/registry', '@web_tour/tour_utils', '@sale/js/tours/combo_configurator_tour_utils', '@sale/js/tours/product_configurator_tour_utils', '@sale/js/tours/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require('@web/core/registry');
const { stepUtils } = require('@web_tour/tour_utils');
const comboConfiguratorTourUtils = require('@sale/js/tours/combo_configurator_tour_utils')[Symbol.for("default")];
const productConfiguratorTourUtils = require('@sale/js/tours/product_configurator_tour_utils')[Symbol.for("default")];
const tourUtils = require('@sale/js/tours/tour_utils')[Symbol.for("default")];

registry
    .category('web_tour.tours')
    .add('sale_combo_configurator_preconfigure_unconfigurable_ptals', {
        url: '/odoo',
        steps: () => [
            ...stepUtils.goToAppSteps('sale.sale_menu_root', "Open the sales app"),
            ...tourUtils.createNewSalesOrder(),
            ...tourUtils.selectCustomer("Test Partner"),
            ...tourUtils.addProduct("Combo product"),
            {
                content: "Verify that unconfigurable ptals are preconfigured",
                trigger: `${comboConfiguratorTourUtils.comboItemSelector("Test product")}:contains("Attribute A: A")`,
            },
            {
                content: "Verify that configurable ptals aren't preconfigured",
                trigger: `${comboConfiguratorTourUtils.comboItemSelector("Test product")}:not(:contains("Attribute B: B"))`,
            },
            comboConfiguratorTourUtils.selectComboItem("Test product"),
            productConfiguratorTourUtils.selectAttribute(
                "Test product", "Attribute B", "B", 'multi'
            ),
            ...productConfiguratorTourUtils.saveConfigurator(),
            {
                content: "Verify that configurable ptals are now configured",
                trigger: `${comboConfiguratorTourUtils.comboItemSelector("Test product")}:contains("Attribute B: B")`,
            },
            ...comboConfiguratorTourUtils.saveConfigurator(),
            // Don't end the tour with a form in edition mode.
            ...stepUtils.saveForm(),
        ],
    });

return __exports;
});
;

/********************************************************************************************************
*  Filepath: /sale/static/tests/tours/sale_combo_configurator_preselect_single_unconfigurable_items.js  *
*  Lines: 42                                                                                            *
********************************************************************************************************/
odoo.define('@sale/../tests/tours/sale_combo_configurator_preselect_single_unconfigurable_items', ['@web/core/registry', '@web_tour/tour_utils', '@sale/js/tours/combo_configurator_tour_utils', '@sale/js/tours/product_configurator_tour_utils', '@sale/js/tours/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require('@web/core/registry');
const { stepUtils } = require('@web_tour/tour_utils');
const comboConfiguratorTourUtils = require('@sale/js/tours/combo_configurator_tour_utils')[Symbol.for("default")];
const productConfiguratorTourUtils = require('@sale/js/tours/product_configurator_tour_utils')[Symbol.for("default")];
const tourUtils = require('@sale/js/tours/tour_utils')[Symbol.for("default")];

registry
    .category('web_tour.tours')
    .add('sale_combo_configurator_preselect_single_unconfigurable_items', {
        url: '/odoo',
        steps: () => [
            ...stepUtils.goToAppSteps('sale.sale_menu_root', "Open the sales app"),
            ...tourUtils.createNewSalesOrder(),
            ...tourUtils.selectCustomer("Test Partner"),
            ...tourUtils.addProduct("Combo product"),
            // Assert that only single unconfigurable items are preselected.
            comboConfiguratorTourUtils.assertPreselectedComboItemCount(2),
            comboConfiguratorTourUtils.assertComboItemPreselected("Product A"),
            comboConfiguratorTourUtils.assertComboItemPreselected("Product C"),
            comboConfiguratorTourUtils.assertConfirmButtonDisabled(),
            // Configure the remaining combos.
            comboConfiguratorTourUtils.selectComboItem("Product B"),
            productConfiguratorTourUtils.selectAttribute("Product B", "Attribute B", "B", 'multi'),
            ...productConfiguratorTourUtils.saveConfigurator(),
            comboConfiguratorTourUtils.selectComboItem("Product D"),
            productConfiguratorTourUtils.setCustomAttribute(
                "Product D", "Attribute D", "Test D"
            ),
            ...productConfiguratorTourUtils.saveConfigurator(),
            comboConfiguratorTourUtils.selectComboItem("Product E1"),
            comboConfiguratorTourUtils.assertConfirmButtonEnabled(),
            ...comboConfiguratorTourUtils.saveConfigurator(),
            // Don't end the tour with a form in edition mode.
            ...stepUtils.saveForm(),
        ],
    });

return __exports;
});
;

/***************************************************************************
*  Filepath: /sale/static/tests/tours/sale_order_product_uom_integrity.js  *
*  Lines: 20                                                               *
***************************************************************************/
odoo.define('@sale/../tests/tours/sale_order_product_uom_integrity', ['@web/core/registry', '@web_tour/tour_utils', '@sale/js/tours/product_configurator_tour_utils', '@sale/js/tours/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require('@web/core/registry');
const { stepUtils } = require('@web_tour/tour_utils');
const productConfiguratorTourUtils = require('@sale/js/tours/product_configurator_tour_utils')[Symbol.for("default")];
const tourUtils = require('@sale/js/tours/tour_utils')[Symbol.for("default")];

registry.category('web_tour.tours').add('sale_order_keep_uom_on_variant_wizard_quantity_change', {
    steps: () => [
        tourUtils.editLineMatching("Sofa"),
        tourUtils.editConfiguration(),
        productConfiguratorTourUtils.increaseProductQuantity("Sofa"),
        ...productConfiguratorTourUtils.saveConfigurator(),
        ...stepUtils.saveForm(),
    ],
});

return __exports;
});
;

/*********************************************************
*  Filepath: /sale/static/tests/tours/sale_signature.js  *
*  Lines: 87                                             *
*********************************************************/
odoo.define('@sale/../tests/tours/sale_signature', ['@web/core/registry', '@web/core/utils/urls'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { redirect } = require("@web/core/utils/urls");

// This tour relies on data created on the Python test.
registry.category("web_tour.tours").add('sale_signature', {
    url: '/my/quotes',
    steps: () => [
    {
        content: "open the test SO",
        trigger: 'a:text(test SO)',
        run: "click",
        expectUnloadPage: true,
    },
    {
        content: "click sign",
        trigger: 'a:contains("Sign")',
        run: "click",
    },
    {
        content: "check submit is enabled",
        trigger: '.o_portal_sign_submit:enabled',
    },
    {
        trigger: ".modal .o_web_sign_name_and_signature input:value(Joel Willis)"
    },
    {
        trigger: ".modal canvas.o_web_sign_signature",
        run: "canvasNotEmpty",
    },
    {
        content: "click select style",
        trigger: '.modal .o_web_sign_auto_select_style button',
        run: "click",
    },
    {
        content: "click style 4",
        trigger: ".o-dropdown-item:eq(3)",
        run: "click",
    },
    {
        content: "click submit",
        trigger: '.modal .o_portal_sign_submit:enabled',
        run: "click",
        expectUnloadPage: true,
    },
    {
        content: "check it's confirmed",
        trigger: '#quote_content:contains("Thank You")',
        run: "click",
    }, {
        trigger: '#quote_content',
        run: function () {
            redirect("/odoo");
        },  // Avoid race condition at the end of the tour by returning to the home page.
        expectUnloadPage: true,
    },
    {
        trigger: 'nav',
    }
]});

registry.category("web_tour.tours").add("sale_signature_without_name", {
    steps: () => [
        {
            content: "Sign & Pay",
            trigger:
                ".o_portal_sale_sidebar .btn-primary, :iframe .o_portal_sale_sidebar .btn-primary",
            run: "click",
        },
        {
            content: "click submit",
            trigger: ".o_portal_sign_submit:enabled, :iframe .o_portal_sign_submit:enabled",
            run: "click",
        },
        {
            content: "check error because no name",
            trigger:
                '.o_portal_sign_error_msg:contains("Signature is missing."), :iframe .o_portal_sign_error_msg:contains("Signature is missing.")',
        },
    ],
});

return __exports;
});
;

/*************************************************************************
*  Filepath: /sale/static/src/js/tours/combo_configurator_tour_utils.js  *
*  Lines: 215                                                            *
*************************************************************************/
odoo.define('@sale/js/tours/combo_configurator_tour_utils', [], function (require) {
'use strict';
let __exports = {};
function comboSelector(comboName) {
    return `
        .sale-combo-configurator-dialog
        [name="sale_combo_configurator_title"]:contains("${comboName}")
    `;
}

function comboItemSelector(comboItemName, extraClasses=[]) {
    const extraClassesSelector = extraClasses.map(extraClass => `.${extraClass}`).join('');
    return `
        .sale-combo-configurator-dialog
        .product-card${extraClassesSelector}:has(h6:contains("${comboItemName}"))
    `;
}

function assertComboCount(count) {
    return {
        content: `Assert that there are ${count} combos`,
        trigger: '.sale-combo-configurator-dialog',
        run() {
            const selector = `.sale-combo-configurator-dialog [name="sale_combo_configurator_title"]`;
            if (document.querySelectorAll(selector).length !== count) {
                console.error(`Assertion failed`);
            }
        },
    };
}

function assertComboItemCount(comboName, count) {
    return {
        content: `Assert that there are ${count} combo items in combo ${comboName}`,
        trigger: comboSelector(comboName),
        run({ queryAll }) {
            const selector = `${comboSelector(comboName)} + .row .product-card`;
            if (queryAll(selector).length !== count) {
                console.error(`Assertion failed`);
            }
        },
    };
}

function assertSelectedComboItemCount(count) {
    return {
        content: `Assert that there are ${count} selected combo items`,
        trigger: '.sale-combo-configurator-dialog',
        run() {
            const selector = `.sale-combo-configurator-dialog .row .product-card.selected`;
            if (document.querySelectorAll(selector).length !== count) {
                console.error(`Assertion failed`);
            }
        },
    };
}

function assertPreselectedComboItemCount(count) {
    return {
        content: `Assert that there are ${count} preselected combo items`,
        trigger: '.sale-combo-configurator-dialog',
        run() {
            const selector = '.sale-combo-configurator-dialog div[name="preselected_product_name"]';
            if (document.querySelectorAll(selector).length !== count) {
                console.error(`Assertion failed`);
            }
        },
    };
}

function selectComboItem(comboItemName) {
    return {
        content: `Select combo item ${comboItemName}`,
        trigger: comboItemSelector(comboItemName),
        run: 'click',
    };
}

function assertComboItemSelected(comboItemName) {
    return {
        content: `Assert that combo item ${comboItemName} is selected`,
        trigger: comboItemSelector(comboItemName, ['selected']),
    };
}

function assertComboItemPreselected(comboItemName) {
    return {
        content: `Assert that combo item ${comboItemName} is preselected`,
        trigger: `[name="preselected_product_name"]:contains(${comboItemName})`,
    };
}

function increaseQuantity() {
    return {
        content: "Increase the combo quantity",
        trigger: '.sale-combo-configurator-dialog button[name="sale_quantity_button_plus"]',
        run: 'click',
    };
}

function decreaseQuantity() {
    return {
        content: "Decrease the combo quantity",
        trigger: '.sale-combo-configurator-dialog button[name="sale_quantity_button_minus"]',
        run: 'click',
    };
}

function setQuantity(quantity) {
    return {
        content: `Set the combo quantity to ${quantity}`,
        trigger: '.sale-combo-configurator-dialog input[name="sale_quantity"]',
        run: `edit ${quantity} && click .modal-body`,
    };
}

function assertQuantity(quantity) {
    return {
        content: `Assert that the combo quantity is ${quantity}`,
        trigger: `.sale-combo-configurator-dialog input[name="sale_quantity"]:value(${quantity})`,
    };
}

function assertPrice(price) {
    return {
        content: `Assert that the price is ${price}`,
        trigger: `
            .sale-combo-configurator-dialog
            [name="sale_combo_configurator_total"]:contains("${price}")
        `,
    };
}

function assertPriceInfo(priceInfo) {
    return {
        content: `Assert that the price info is ${priceInfo}`,
        trigger: `.sale-combo-configurator-dialog footer.modal-footer:contains("${priceInfo}")`,
    };
}

function assertFooterButtonsDisabled() {
    return {
        content: "Assert that the footer buttons are disabled",
        trigger: '.sale-combo-configurator-dialog footer.modal-footer button:disabled',
    };
}

function assertFooterButtonsEnabled() {
    return {
        content: "Assert that the footer buttons are enabled",
        trigger: '.sale-combo-configurator-dialog footer.modal-footer button:enabled',
    };
}

function assertConfirmButtonDisabled() {
    return {
        content: "Assert that the confirm button is disabled",
        trigger: `
            .sale-combo-configurator-dialog
            button[name="sale_combo_configurator_confirm_button"]:disabled
        `,
    };
}

function assertConfirmButtonEnabled() {
    return {
        content: "Assert that the confirm button is enabled",
        trigger: `
            .sale-combo-configurator-dialog
            button[name="sale_combo_configurator_confirm_button"]:enabled
        `,
    };
}

function saveConfigurator() {
    return [
        {
            content: "Confirm the combo configurator",
            trigger: `
                .sale-combo-configurator-dialog
                button[name="sale_combo_configurator_confirm_button"]
            `,
            run: 'click',
        }, {
            content: "Wait until the modal is closed",
            trigger: 'body:not(:has(.sale-combo-configurator-dialog))',
        },
    ];
}

__exports[Symbol.for("default")] = {
    comboSelector,
    comboItemSelector,
    assertComboCount,
    assertComboItemCount,
    assertSelectedComboItemCount,
    assertPreselectedComboItemCount,
    selectComboItem,
    assertComboItemSelected,
    assertComboItemPreselected,
    increaseQuantity,
    decreaseQuantity,
    setQuantity,
    assertQuantity,
    assertPrice,
    assertPriceInfo,
    assertFooterButtonsDisabled,
    assertFooterButtonsEnabled,
    assertConfirmButtonDisabled,
    assertConfirmButtonEnabled,
    saveConfigurator,
};

return __exports;
});
;

/***************************************************************************
*  Filepath: /sale/static/src/js/tours/product_configurator_tour_utils.js  *
*  Lines: 271                                                              *
***************************************************************************/
odoo.define('@sale/js/tours/product_configurator_tour_utils', [], function (require) {
'use strict';
let __exports = {};
function productSelector(productName) {
    return `
        table.o_sale_product_configurator_table
        tr:has(td>div[name="o_sale_product_configurator_name"]
        span:contains("${productName}"))
    `;
}

function optionalProductSelector(productName) {
    return `
        table.o_sale_product_configurator_table_optional
        tr:has(td>div[name="o_sale_product_configurator_name"]
        span:contains("${productName}"))
    `;
}

function optionalProductImageSrc(queryOne, productName) {
    return queryOne(
        `${optionalProductSelector(productName)} td.o_sale_product_configurator_img>img`
    ).getAttribute("src");
}

function addOptionalProduct(productName) {
    return {
        content: `Add ${productName}`,
        trigger: `
            ${optionalProductSelector(productName)}
            td.o_sale_product_configurator_price
            button:contains("Add")
        `,
        run: 'click',
    };
}

function removeOptionalProduct(productName) {
    return {
        content: `Remove ${productName}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            a:contains("Remove")
        `,
        run: 'click',
    };
}

function decreaseProductQuantity(productName) {
    return {
        content: `Decrease the quantity of ${productName}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            button:has(i.oi-minus)
        `,
        run: 'click',
    };
}

function increaseProductQuantity(productName) {
    return {
        content: `Increase the quantity of ${productName}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            button:has(i.oi-plus)
        `,
        run: 'click',
    };
}

function setProductQuantity(productName, quantity) {
    return {
        content: `Set the quantity of ${productName} to ${quantity}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            input[name="sale_quantity"]
        `,
        run: `edit ${quantity} && click .modal-body`,
    };
}

function setProductUoM(productName, uomName) {
    // UoM must be enabled
    return {
        content: `Set the uom of ${productName} to ${uomName}`,
        trigger: `
            ${productSelector(productName)}
            label:contains("${uomName}")
        `,
        run: `click && click .modal-body`,
    };
}

function assertProductQuantity(productName, quantity) {
    return {
        content: `Assert that the quantity of ${productName} is ${quantity}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            input[name="sale_quantity"]:value(${quantity})
        `,
    };
}

function selectAttribute(productName, attributeName, attributeValue, attributeType='radio') {
    const ptalSelector = `
        ${productSelector(productName)}
        td>div[name="ptal"]:has(label:contains("${attributeName}"))
    `;
    const content = `Select ${attributeValue} for ${productName} ${attributeName}`;
    switch (attributeType) {
        case 'color':
            return {
                content: content,
                trigger: `${ptalSelector} label[title="${attributeValue}"]`,
                run: 'click',
            };
        case 'multi':
            return {
                content: content,
                trigger: `${ptalSelector}:has(label:text(${attributeValue})) input[type="checkbox"]`,
                run: "click",
            };
        case 'pills':
        case 'radio':
            return {
                content: content,
                trigger: `${ptalSelector} span:contains("${attributeValue}")`,
                run: 'click',
            };
        case 'select':
            return {
                content: content,
                trigger: `${ptalSelector} select`,
                run: `selectByLabel ${attributeValue}`,
            };
        default:
            console.error("Unsupported attribute type");
    }
}

function setCustomAttribute(productName, attributeName, customValue) {
    return {
        content: `Set ${customValue} as a custom attribute for ${productName} ${attributeName}`,
        trigger: `
            ${productSelector(productName)}
            td>div[name="ptal"]:has(label:contains("${attributeName}"))
            input[type="text"]
        `,
        run: `edit ${customValue} && click .modal-body`,
    };
}

function selectAndSetCustomAttribute(
    productName, attributeName, attributeValue, customValue, attributeType='radio'
) {
    return [
        selectAttribute(productName, attributeName, attributeValue, attributeType),
        setCustomAttribute(productName, attributeName, customValue),
    ];
}

function assertPriceTotal(total) {
    return {
        content: `Assert that the total is ${total}`,
        trigger: `
            .o_sale_product_configurator_dialog .o_configurator_price_total:contains("${total}"),
        `,
    };
}

function assertProductPrice(productName, price) {
    return {
        content: `Assert that ${productName} costs ${price}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            span:contains("${price}")
        `,
    };
}

function assertOptionalProductPrice(productName, price) {
    return {
        content: `Assert that ${productName} costs ${price}`,
        trigger: `
            ${optionalProductSelector(productName)}
            td.o_sale_product_configurator_price
            span:contains("${price}")
        `,
    };
}

function assertProductPriceInfo(productName, priceInfo) {
    return {
        content: `Assert that the price info of ${productName} is ${priceInfo}`,
        trigger: `
            ${productSelector(productName)}
            td.o_sale_product_configurator_qty
            div:contains("${priceInfo}")
        `,
    };
}

function assertOptionalProductPriceInfo(productName, priceInfo) {
    return {
        content: `Assert that the price info of ${productName} is ${priceInfo}`,
        trigger: `
            ${optionalProductSelector(productName)}
            td.o_sale_product_configurator_price
            div:contains("${priceInfo}")
        `,
    };
}

function assertProductNameContains(productName) {
    return {
        content: `Assert that the product name contains ${productName}`,
        trigger: productSelector(productName),
    };
}

function assertFooterButtonsDisabled() {
    return {
        content: "Assert that the footer buttons are disabled",
        trigger: '.o_sale_product_configurator_dialog footer.modal-footer button:disabled',
    };
}

function saveConfigurator() {
    return [
        {
            trigger: '.o_sale_product_configurator_dialog button:contains(Confirm)',
            run: 'click',
        }, {
            content: "Wait until the modal is closed",
            trigger: 'body:not(:has(.o_sale_product_configurator_dialog))',
        }
    ];
}

__exports[Symbol.for("default")] = {
    productSelector,
    optionalProductSelector,
    optionalProductImageSrc,
    addOptionalProduct,
    removeOptionalProduct,
    increaseProductQuantity,
    decreaseProductQuantity,
    setProductQuantity,
    setProductUoM,
    assertProductQuantity,
    selectAttribute,
    setCustomAttribute,
    selectAndSetCustomAttribute,
    assertPriceTotal,
    assertProductPrice,
    assertOptionalProductPrice,
    assertProductPriceInfo,
    assertOptionalProductPriceInfo,
    assertProductNameContains,
    assertFooterButtonsDisabled,
    saveConfigurator,
};

return __exports;
});
;

/******************************************************
*  Filepath: /sale/static/src/js/tours/tour_utils.js  *
*  Lines: 103                                         *
******************************************************/
odoo.define('@sale/js/tours/tour_utils', [], function (require) {
'use strict';
let __exports = {};
function createNewSalesOrder() {
    return [
        {
            trigger: '.o_sale_order',
        }, {
            content: "Create new order",
            trigger: '.o_list_button_add',
            run: 'click',
        },
    ]
}

function selectCustomer(customerName) {
    return [
        {
            content: `Select customer ${customerName}`,
            trigger: '.o_field_widget[name=partner_id] input',
            run: `edit ${customerName}`,
        },
        {
            trigger: `ul.ui-autocomplete > li > a:contains("${customerName}")`,
            run: 'click',
        },
    ];
}

function addProduct(productName, rowNumber=1) {
    return [
        {
            content: `Add product ${productName}`,
            trigger: 'a:contains("Add a product")',
            run: 'click',
        },
        {
            content: 'wait for new row to be created',
            trigger: `.o_data_row:nth-child(${rowNumber})`,
        },
        {
            trigger: 'div[name="product_template_id"] input',  // TODO VFE o_selected_row
            run: `edit ${productName}`,
        },
        {
            trigger: `ul.ui-autocomplete a:contains("${productName}")`,
            run: 'click',
        },
    ];
}

function clickSomewhereElse() {
    return [
        // TODO find a way for onchange to finish first ?
        {
            content: 'click somewhere else to exit cell focus',
            trigger: 'a[name=order_lines]',  // click on notebook tab to stop the sol edit mode.
            run: 'click',
        },
        {
            content: 'check that the soline is not focused anymore',
            trigger: 'table.o_section_and_note_list_view:not(:has(.o_selected_row))',
        }
    ]
}

function checkSOLDescriptionContains(productName, text) {
    // TODO in the future: look directly into the textarea value
    let trigger = '.o_field_product_label_section_and_note_cell';
    if (productName) {
        trigger = `${trigger}:has(:contains("${productName}"), input:value("${productName}"))`;
    }
    if (text) {
        trigger = `${trigger} .o_input`;
    }
    return { trigger };
}

function editLineMatching(productName, text) {
    let base_step = checkSOLDescriptionContains(productName, text);
    base_step['run'] = 'click';
    return base_step;
}

function editConfiguration() {
    return {
        trigger: '[name=product_template_id] button.fa-pencil',
        run: 'click',
    }
}

__exports[Symbol.for("default")] = {
    createNewSalesOrder,
    selectCustomer,
    addProduct,
    checkSOLDescriptionContains,
    editLineMatching,
    editConfiguration,
    clickSomewhereElse,
};

return __exports;
});
;

/************************************************************
*  Filepath: /calendar/static/tests/tours/calendar_tour.js  *
*  Lines: 138                                               *
************************************************************/
odoo.define('@calendar/../tests/tours/calendar_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

const todayDate = function () {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, "0");
    const day = String(now.getDate()).padStart(2, "0");

    return `${month}/${day}/${year} 10:00:00`;
};

registry.category("web_tour.tours").add("calendar_appointments_hour_tour", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="calendar.mail_menu_calendar"]',
            content: "Open Calendar",
            run: "click",
        },
        {
            trigger: ".o-calendar-button-new",
            content: "Create a new event",
            run: "click",
        },
        {
            trigger: "#name_0",
            content: "Give a name to the new event",
            run: "edit TEST EVENT",
        },
        {
            trigger: "div[name='start'] button",
            content: "Open the date picker",
            run: "click",
        },
        {
            trigger: "#start_0",
            content: "Give a date to the new event",
            run: `edit ${todayDate()}`,
        },
        {
            trigger: "#duration_0",
            content: "Give a duration to the new event",
            run: "edit 02:00",
        },
        {
            trigger: ".fa-cloud-upload",
            content: "Save the new event",
            run: "click",
        },
        {
            trigger: ".o_back_button",
            content: "Go back to Calendar view",
            run: "click",
        },
        {
            trigger: ".scale_button_selection",
            content: "Click to change calendar view",
            run: "click",
        },
        {
            trigger: '.dropdown-item:contains("Month")',
            content: "Change the calendar view to Month",
            run: "click",
        },
        {
            trigger: ".fc-col-header-cell.fc-day.fc-day-mon",
            content: "Check the day is properly displayed",
            run: "click",
        },
        {
            trigger: '.fc-time:contains("10:00")',
            content: "Check the time is properly displayed",
            run: "click",
        },
        {
            trigger: '.o_event_title:contains("TEST EVENT")',
            content: "Check the event title",
        },
    ],
});

const clickOnTheEvent = {
    content: "Click on the event (focus + waiting)",
    trigger: 'a .fc-event-main:contains("Test Event")',
    async run(actions) {
        await actions.click();
        await new Promise((r) => setTimeout(r, 1000));
        const custom = document.querySelector(".o_cw_custom_highlight");
        if (custom) {
            custom.click();
        }
    },
};

registry.category("web_tour.tours").add("test_calendar_delete_tour", {
    steps: () => [
        clickOnTheEvent,
        {
            trigger: ".o_cw_popover",
        },
        {
            content: "Delete the event",
            trigger: ".o_cw_popover_delete",
            run: "click",
        },
        {
            content: "Validate the deletion",
            trigger: 'button:contains("Delete")',
            run: "click",
        },
    ],
});

registry.category("web_tour.tours").add("test_calendar_decline_tour", {
    steps: () => [
        clickOnTheEvent,
        {
            trigger: ".o_cw_popover",
        },
        {
            content: "Delete the event",
            trigger: ".o_cw_popover_delete",
            run: "click",
        },
        {
            content: "Wait declined status",
            trigger: ".o_attendee_status_declined",
        },
    ],
});

return __exports;
});
;

/**********************************************************************
*  Filepath: /contacts/static/tests/tours/debug_menu_set_defaults.js  *
*  Lines: 80                                                          *
**********************************************************************/
odoo.define('@contacts/../tests/tours/debug_menu_set_defaults', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
    const { registry } = require("@web/core/registry");
    const { stepUtils } = require("@web_tour/tour_utils");

    registry.category("web_tour.tours").add('debug_menu_set_defaults', {
        url: '/odoo?debug=1',
        steps: () => [
            ...stepUtils.goToAppSteps('contacts.menu_contacts', "Open the contacts menu"),
            {
                content: "Create a new contact",
                trigger: '.o_list_button_add',
                run: "click",
            },
            {
                content: "Check that Company is checked by default, and not Individual",
                trigger: '.o_field_widget[name="company_type"] input[data-value="company"]:checked',
            },
            {
                content: "Select the individual radio button",
                trigger: '.o_field_widget[name="company_type"] input[data-value="person"]',
                run: "click",
            },
            {
                content: "Open the debug menu",
                trigger: '.o_debug_manager button',
                run: "click",
            },
            {
                content: "Click the Set Defaults menu",
                trigger: '.dropdown-item:contains(Set Default Values)',
                run: "click",
            },
            {
                content: "Choose Company Type = Individual",
                trigger: '#formview_default_fields',
                run: function () {
                    const element_field = document.querySelector('select#formview_default_fields');
                    element_field.value = 'company_type';
                    element_field.dispatchEvent(new Event("change"));
                },
            },
            {
                content: "Check that there are conditions",
                trigger: '#formview_default_conditions',
                run: "click",
            },
            {
                content: "Save the new default",
                trigger: 'footer button:contains(Save default)',
                run: "click",
            },
            {
                content: "Discard the contact creation",
                trigger: 'button.o_form_button_cancel',
                run: "click",
            },
            {
                trigger: '.o_action_manager > .o_list_view .o_list_button_add',
                run: "click",
            },
            {
                content: "Check that Individual is checked instead of Company",
                trigger: '.o_field_widget[name="company_type"] input[data-value="person"]:checked',
            },
            {
                content: "Discard the contact creation",
                trigger: 'button.o_form_button_cancel',
                run: "click",
            },
            {
                content: "Wait for discard",
                trigger: '.o_control_panel .o_list_button_add',
            },
        ]
    });

return __exports;
});
;

/**************************************************************
*  Filepath: /crm/static/tests/tours/create_crm_team_tour.js  *
*  Lines: 44                                                  *
**************************************************************/
odoo.define('@crm/../tests/tours/create_crm_team_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add('create_crm_team_tour', {
    url: "/odoo",
    steps: () => [
    ...stepUtils.goToAppSteps('crm.crm_menu_root'),
{
    trigger: 'button[data-menu-xmlid="crm.crm_menu_config"]',
    run: "click",
}, {
    trigger: 'a[data-menu-xmlid="crm.crm_team_config"]',
    run: "click",
}, {
    trigger: 'button.o_list_button_add',
    run: "click",
}, {
    trigger: 'input[id="name_0"]',
    run: "edit My CRM Team",
}, {
    trigger: '.btn.o-kanban-button-new',
    run: "click",
}, {
    trigger: 'div.modal-dialog tr:contains("Test Salesman") input.form-check-input',
    run: 'click',
}, {
    trigger: 'div.modal-dialog tr:contains("Test Sales Manager") input.form-check-input',
    run: 'click',
}, {
    trigger: 'div.modal-dialog tr:contains("Test Sales Manager") input.form-check-input:checked',
}, {
    trigger: '.o_selection_box:contains(2)',
}, {
    trigger: 'button.o_select_button',
    run: "click",
},
    ...stepUtils.saveForm()
]});

return __exports;
});
;

/*************************************************************************
*  Filepath: /crm/static/tests/tours/crm_email_and_phone_propagation.js  *
*  Lines: 31                                                             *
*************************************************************************/
odoo.define('@crm/../tests/tours/crm_email_and_phone_propagation', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
    const { registry } = require("@web/core/registry");
    const { stepUtils } = require("@web_tour/tour_utils");

    registry.category("web_tour.tours").add('crm_email_and_phone_propagation_edit_save', {
        url: '/odoo',
        steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: '.o_app[data-menu-xmlid="crm.crm_menu_root"]',
            content: 'open crm app',
            run: "click",
        }, {
            trigger: '.o_kanban_record:contains(Test Lead Propagation)',
            content: 'Open the first lead',
            run: 'click',
        },
        {
            trigger: ".o_form_editable .o_field_widget[name=email_from] input",
        },
        {
            trigger: ".o_form_button_save:not(:visible)",
            content: 'Save the lead',
            run: 'click',
        },
    ]});

return __exports;
});
;

/***********************************************************
*  Filepath: /crm/static/tests/tours/crm_forecast_tour.js  *
*  Lines: 99                                               *
***********************************************************/
odoo.define('@crm/../tests/tours/crm_forecast_tour', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");
const today = luxon.DateTime.now();

registry.category("web_tour.tours").add('crm_forecast', {
    url: "/odoo",
    steps: () => [
    stepUtils.showAppsMenuItem(),
    {
        trigger: ".o_app[data-menu-xmlid='crm.crm_menu_root']",
        content: "open crm app",
        run: "click",
    }, {
        trigger: '.dropdown-toggle[data-menu-xmlid="crm.crm_menu_report"]',
        content: 'Open Reporting menu',
        run: 'click',
    }, {
        trigger: '.dropdown-item[data-menu-xmlid="crm.crm_menu_forecast"]',
        content: 'Open Forecast menu',
        run: 'click',
    }, {
        trigger: '.o_column_quick_create',
        content: 'Wait page loading',
    }, {
        trigger: ".o-kanban-button-new",
        content: "click create",
        run: 'click',
    }, {
        trigger: ".o_field_widget[name=name] input",
        content: "complete name",
        run: "edit Test Opportunity 1",
    }, {
        trigger: ".o_field_widget[name=expected_revenue] input",
        content: "complete expected revenue",
        run: "edit 999999",
    }, {
        trigger: "button.o_kanban_edit",
        content: "edit lead",
        run: "click",
    }, {
        trigger: "div[name=date_deadline] button",
        content: "open date picker",
        run: "click",
    }, {
        trigger: "div[name=date_deadline] input",
        content: "complete expected closing",
        run: `edit ${today.toFormat("MM/dd/yyyy")}`,
    }, {
        trigger: "div[name=date_deadline] input",
        content: "click to make the datepicker disappear",
        run: "click"
    }, {
        trigger: '.o_back_button',
        content: 'navigate back to the kanban view',
        tooltipPosition: "bottom",
        run: "click"
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1')",
        content: "move to the next month",
        async run({ queryAll, drag_and_drop }) {
            const undefined_groups = queryAll('.o_column_title:contains("None")').length;
            await drag_and_drop(`.o_opportunity_kanban .o_kanban_group:eq(${1 + undefined_groups})`);
        },
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1')",
        content: "edit lead",
        run: "click"
    }, {
        trigger: "div[name=date_deadline] button",
        content: "open date picker",
        run: "click",
    }, {
        trigger: ".o_field_widget[name=date_deadline] input",
        content: "complete expected closing",
        run: `edit ${today.plus({ months: 5 }).startOf("month").minus({ days: 1 }).toFormat("MM/dd/yyyy")} && press Escape`,
    }, {
        trigger: "button[name=action_set_won_rainbowman]",
        content: "win the lead",
        run:"click"
    }, {
        trigger: '.o_back_button',
        content: 'navigate back to the kanban view',
        tooltipPosition: "bottom",
        run: "click"
    }, {
        trigger: '.o_column_quick_create.o_quick_create_folded div',
        content: "add next month",
        run: "click"
    }, {
        trigger: ".o_kanban_record:contains('Test Opportunity 1'):contains('Won')",
        content: "assert that the opportunity has the Won banner",
    }
]});

return __exports;
});
;

/********************************************************
*  Filepath: /crm/static/tests/tours/crm_rainbowman.js  *
*  Lines: 125                                           *
********************************************************/
odoo.define('@crm/../tests/tours/crm_rainbowman', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add("crm_rainbowman", {
    url: "/odoo",
    steps: () => [
        stepUtils.showAppsMenuItem(),
        {
            trigger: ".o_app[data-menu-xmlid='crm.crm_menu_root']",
            content: "open crm app",
            run: "click",
        },
        {
            trigger: "body:has(.o_kanban_renderer) .o-kanban-button-new",
            content: "click create",
            run: "click",
        },
        {
            trigger: ".o_field_widget[name=name] input",
            content: "complete name",
            run: "edit Test Lead 1",
        },
        {
            trigger: ".o_field_widget[name=expected_revenue] input",
            content: "complete expected revenue",
            run: "edit 999999997",
        },
        {
            trigger: "button.o_kanban_add",
            content: "create lead",
            run: "click",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 1')",
            content: "move to won stage",
            run: "drag_and_drop (.o_opportunity_kanban .o_kanban_group:has(.o_column_title:contains('Won')))",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            // This step and the following simulates the fact that after drag and drop,
            // from the previous steps, a click event is triggered on the window element,
            // which closes the currently shown .o_kanban_quick_create.
            trigger: ".o_kanban_renderer",
            run: "click",
        },
        {
            trigger: ".o_kanban_renderer:not(:has(.o_kanban_quick_create))",
        },
        {
            trigger: ".o-kanban-button-new",
            content: "create second lead",
            run: "click",
        },
        {
            trigger: ".o_field_widget[name=name] input",
            content: "complete name",
            run: "edit Test Lead 2",
        },
        {
            trigger: ".o_field_widget[name=expected_revenue] input",
            content: "complete expected revenue",
            run: "edit 999999998",
        },
        {
            trigger: "button.o_kanban_add",
            content: "create lead",
            run: "click",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 2')",
        },
        {
            // move first test back to new stage to be able to test rainbowman a second time
            trigger: ".o_kanban_record:contains('Test Lead 1')",
            content: "move back to new stage",
            run: "drag_and_drop .o_opportunity_kanban .o_kanban_group:eq(0) ",
        },
        {
            trigger: ".o_kanban_record:contains('Test Lead 2')",
            content: "click on second lead",
            run: "click",
        },
        {
            trigger: ".o_statusbar_status button[data-value='4']",
            content: "move lead to won stage",
            run: "click",
        },
        {
            content: "wait for save completion",
            trigger: ".o_form_readonly, .o_form_saved",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            trigger: ".o_statusbar_status button[data-value='1']",
            content: "move lead to previous stage & rainbowman appears",
            run: "click",
        },
        {
            trigger: "button[name=action_set_won_rainbowman]",
            content: "click button mark won",
            run: "click",
        },
        {
            content: "wait for save completion",
            trigger: ".o_form_readonly, .o_form_saved",
        },
        {
            trigger: ".o_reward_rainbow",
        },
        {
            trigger: ".o_menu_brand",
            content: "last rainbowman appears",
        },
    ],
});

return __exports;
});
;

/************************************************************
*  Filepath: /auth_passkey/static/tests/passkeys_delete.js  *
*  Lines: 83                                                *
************************************************************/
odoo.define('@auth_passkey/../tests/passkeys_delete', ['@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");

registry.category("web_tour.tours").add('passkeys_tour_delete', {
    url: '/odoo',
    steps: () => [
        {
            content: 'Open user account menu',
            trigger: '.o_user_menu .dropdown-toggle',
            run: 'click',
        }, {
            content: "Open preferences / profile screen",
            trigger: '[data-menu=preferences]',
            run: 'click',
        }, {
            content: "Switch to security tab",
            trigger: 'a[role=tab]:contains("Security")',
            run: 'click',
        }, {
            content: "Ensure there is only one passkey",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                let amount = document.querySelectorAll("div[name='auth_passkey_key_ids'] article").length;
                if(amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        }, {
            content: "Open Passkey dropdown",
            trigger: '[name="auth_passkey_key_ids"] .o_dropdown_kanban .o-dropdown:not(:visible)',
            run: 'click',
        }, {
            content: "Delete Passkey",
            trigger: 'a[name="action_delete_passkey"]',
            run: 'click',
        }, {
            content: "Identitycheck: use password",
            trigger: 'button[name="action_use_password"]',
            run: 'click',
        }, {
            content: "Check that we have to enter enhanced security mode",
            trigger: ".modal div:contains(Enter your current password)",
        }, {
            content: "Input password",
            trigger: '.modal [name=password] input',
            run: "edit admin",
        }, {
            content: "Confirm",
            trigger: ".modal button:contains(Confirm Password)",
            run: "click",
        }, {
            content: 'Open user account menu',
            trigger: '.o_user_menu .dropdown-toggle',
            run: 'click',
        }, {
            content: "Open preferences / profile screen",
            trigger: '[data-menu=preferences]',
            run: 'click',
        }, {
            // The HR module causes the switch to security tab to trigger on the old DOM, before the new one is loaded
            content: "Make sure the Preferences tab is open",
            trigger: 'label:contains("Email Signature")',
        }, {
            content: "Switch to security tab",
            trigger: 'a[role=tab]:contains("Security")',
            run: 'click',
        }, {
            content: "Ensure there are no more passkeys",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                let amount = document.querySelectorAll("div[name='auth_passkey_key_ids'] article").length;
                if(amount != 0) {
                    throw Error("Amount of Passkeys must be 0");
                }
            },
        }
    ]
})

return __exports;
});
;

/***********************************************************
*  Filepath: /auth_passkey/static/tests/passkeys_login.js  *
*  Lines: 48                                               *
***********************************************************/
odoo.define('@auth_passkey/../tests/passkeys_login', ['@web/core/registry', '@web/core/utils/patch', '@auth_passkey/../lib/simplewebauthn'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { patch } = require("@web/core/utils/patch");
const passkeyLib = require("@auth_passkey/../lib/simplewebauthn");

registry.category("web_tour.tours").add('passkeys_tour_login', {
    url: '/web/login',
    steps: () => [
        {
            content: "Inject authenticator data",
            trigger: 'body',
            run: () => {
                // Due to switching from /web/login to /odoo, the asset bundles will be different. As a result this will automatically clean up the test.
                patch(passkeyLib, {
                    async startAuthentication() {
                        return {
                            // test-keepassxc
                            "id": "y6aJVJsvvSSkbwTeGZ1FbQP_jCDho7EBPwZq-3lAjQ0",
                            "rawId": "y6aJVJsvvSSkbwTeGZ1FbQP_jCDho7EBPwZq-3lAjQ0",
                            "response": {
                                "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA",
                                "clientDataJSON": "eyJjaGFsbGVuZ2UiOiJMTnBWMGRQSU10bXBTd0dlbklIX2gxVnljUXVBZ0ZnUVJKOVRQS0JvTmF5U2NOQUVyUy1yc25hVTE5bjdfQWFYemVpWVJnM25HSTN5dUgwYWk2VVBYQSIsImNyb3NzT3JpZ2luIjpmYWxzZSwib3JpZ2luIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6ODg4OCIsInR5cGUiOiJ3ZWJhdXRobi5nZXQifQ",
                                "signature": "MEYCIQCqkh2NBQQao5uDTaBKyNhiEpnk4jgbH-PjdLAul9-d0gIhAMObtNTbaEMUILdNgCT01BKNN4NHRzkzsGaDN2Ozu0WX",
                                "userHandle": "Ng",
                            },
                            "type": "public-key",
                            "clientExtensionResults": {},
                            "authenticatorAttachment": "platform",
                        };
                    },
                });
            },
        }, {
            content: 'Login with Passkey',
            trigger: 'a:contains("Use a Passkey")',
            run: 'click',
            expectUnloadPage: true,
        }, {
            content: 'Check if we are logged in',
            trigger: '.o_user_menu .dropdown-toggle',
        },
    ]
})

return __exports;
});
;

/******************************************************************
*  Filepath: /auth_passkey/static/tests/passkeys_registration.js  *
*  Lines: 124                                                     *
******************************************************************/
odoo.define('@auth_passkey/../tests/passkeys_registration', ['@web/core/registry', '@web/core/utils/patch', '@auth_passkey/../lib/simplewebauthn'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { patch } = require("@web/core/utils/patch");
const passkeyLib = require("@auth_passkey/../lib/simplewebauthn");

let unpatchPasskeyRegistration;

registry.category("web_tour.tours").add('passkeys_tour_registration', {
    url: '/odoo',
    steps: () => [
        {
            content: 'Open user account menu',
            trigger: '.o_user_menu .dropdown-toggle',
            run: 'click',
        }, {
            content: "Open preferences / profile screen",
            trigger: '[data-menu=preferences]',
            run: 'click',
        }, {
            content: "Switch to security tab",
            trigger: 'a[role=tab]:contains("Security")',
            run: 'click',
        }, {
            content: "Ensure there are no passkeys already",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                let amount = document.querySelectorAll("div[name='auth_passkey_key_ids'] article").length;
                if(amount != 0) {
                    throw Error("Amount of Passkeys must be 0");
                }
            },
        }, {
            content: "Add a Passkey",
            trigger: 'button:contains("Add Passkey")',
            run: 'click',
        }, {
            content: "Check that we have to enter enhanced security mode",
            trigger: ".modal div:contains(Enter your current password)",
        }, {
            content: "Input password",
            trigger: '.modal [name=password] input',
            run: "edit admin",
        }, {
            content: "Confirm",
            trigger: ".modal button:contains(Confirm Password)",
            run: "click",
        }, {
            content: "Ready to create Passkey",
            trigger: ".modal div:contains(Create Passkey)",
        }, {
            content: "Input passkey name",
            trigger: '.modal .o_field_char input',
            run: "edit test_passkey_one",
        }, {
            content: "Override startRegistration",
            trigger: 'body',
            run: () => {
                unpatchPasskeyRegistration = patch(passkeyLib, {
                    async startRegistration() {
                        return {
                            // test-yubikey
                            "id": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "rawId": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "response": {
                                "attestationObject": "o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjCSZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI",
                                "clientDataJSON": "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiVW9hNk01akVQN0kzVG95SzlRQTB2ZjhJY3NlemZlSmswcmdzMXBMVVdyTWdGOXZkMC03RHY1aVYzeFc3cjcwLVlxa3dlUlhoQUNtRFBtaEhLdEFJZVEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9",
                                "transports": [
                                    "nfc",
                                    "usb",
                                ],
                                "publicKeyAlgorithm": -7,
                                "publicKey": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEL2p6jvcWuCMTRmkZHDEsgbnQviQ2WGPYMjKpJz9iJFLarpsvb4ignqP8aRVN188rLHxEXl7zDNf35mTfsDKQzw",
                                "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI",
                            },
                            "type": "public-key",
                            "clientExtensionResults": {},
                            "authenticatorAttachment": "cross-platform",
                        };
                    },
                });
            },
        }, {
            content: "Click the Create button",
            trigger: ".modal button:contains(Create)",
            run: "click",
        }, {
            content: 'Open user account menu',
            trigger: '.o_user_menu .dropdown-toggle',
            run: 'click',
        }, {
            content: "Return startRegistration to original state",
            trigger: 'body',
            run: () => {
                unpatchPasskeyRegistration();
            },
        }, {
            content: "Open preferences / profile screen",
            trigger: '[data-menu=preferences]',
            run: 'click',
        }, {
            // The HR module causes the switch to security tab to trigger on the old DOM, before the new one is loaded
            content: "Make sure the Preferences tab is open",
            trigger: 'label:contains("Email Signature")',
        }, {
            content: "Switch to security tab",
            trigger: 'a[role=tab]:contains("Security")',
            run: 'click',
        }, {
            content: "Ensure there is one passkey",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                let amount = document.querySelectorAll("div[name='auth_passkey_key_ids'] article").length;
                if(amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        },
    ]
})

return __exports;
});
;

/************************************************************
*  Filepath: /auth_passkey/static/tests/passkeys_verify.js  *
*  Lines: 79                                                *
************************************************************/
odoo.define('@auth_passkey/../tests/passkeys_verify', ['@web/core/registry', '@web/core/utils/patch', '@auth_passkey/../lib/simplewebauthn'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { patch } = require("@web/core/utils/patch");
const passkeyLib = require("@auth_passkey/../lib/simplewebauthn");

let unpatchPasskeyVerify;

registry.category("web_tour.tours").add('passkeys_tour_verify', {
    url: '/odoo',
    steps: () => [
        {
            content: 'Open user account menu',
            trigger: '.o_user_menu .dropdown-toggle',
            run: 'click',
        }, {
            content: "Open preferences / profile screen",
            trigger: '[data-menu=preferences]',
            run: 'click',
        }, {
            content: "Switch to security tab",
            trigger: 'a[role=tab]:contains("Security")',
            run: 'click',
        }, {
            content: "Ensure there is one passkey",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                let amount = document.querySelectorAll("div[name='auth_passkey_key_ids'] article").length;
                if(amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        }, {
            content: "Trigger security prompt",
            trigger: 'button:contains("Add Passkey")',
            run: 'click',
        }, {
            content: "Override startAuthentication",
            trigger: 'body',
            run: () => {
                unpatchPasskeyVerify = patch(passkeyLib, {
                    async startAuthentication() {
                        return {
                            // test-yubikey
                            "id": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "rawId": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "response": {
                                "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAw",
                                "clientDataJSON": "eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiREtydzVJZUZpTDB3X3k1b0IwUkFUUHJxRzFlRk9DMlA3eUVpWENzdEJSdVpZYlNCQmtBV2ZoQUlJbmtNcVdqWUlOOHZiS243SjNQTVhfVGh6bkhwcWciLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9",
                                "signature": "MEUCIQD5iaPp48QMS3amx4PS89kv_EBAo3bBkaWnLzWlSgFSXgIgLWKEv9xR_ZwVXZbw2zx459RKbrQuAcd-UqD4gJw1lWY",
                                "userHandle": "Mg",
                            },
                            "type": "public-key",
                            "clientExtensionResults": {},
                            "authenticatorAttachment": "cross-platform",
                        };
                    },
                });
            },
        }, {
            content: "Click Use Passkey",
            trigger: 'button:contains("Use Passkey")',
            run: 'click',
        }, {
            content: "Ready to create Passkey",
            trigger: ".modal div:contains(Create Passkey)",
        }, {
            content: "Return startAuthentication to original state",
            trigger: 'body',
            run: () => {
                unpatchPasskeyVerify();
            },
        }
    ]
})

return __exports;
});
;

/*****************************************************************************
*  Filepath: /auth_passkey_portal/static/tests/tours/test_passkey_portal.js  *
*  Lines: 172                                                                *
*****************************************************************************/
odoo.define('@auth_passkey_portal/../tests/tours/test_passkey_portal', ['@web/core/registry', '@web/core/utils/patch', '@auth_passkey/../lib/simplewebauthn'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { patch } = require("@web/core/utils/patch");
const passkeyLib = require("@auth_passkey/../lib/simplewebauthn");

let unpatchPasskeyRegistrationPortal;

registry.category("web_tour.tours").add("passkeys_portal_create", {
    url: "/my/security",
    steps: () => [
        {
            content: "Ensure there are no passkeys already",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                const amount = document.querySelectorAll(".o_passkey_portal_entry").length;
                if (amount != 0) {
                    throw Error("Amount of Passkeys must be 0");
                }
            },
        }, {
            content: "Add a Passkey",
            trigger: 'button:contains("Add Passkey")',
            run: "click",
        }, {
            content: "Check that we have to enter enhanced security mode",
            trigger: "form strong:contains(Please enter your password to confirm you own this account)",
        }, {
            content: "Input password",
            trigger: "form input[name=password]",
            run: "edit passkey_portal",
        }, {
            content: "Confirm",
            trigger: ".modal-footer button:contains(Confirm Password)",
            run: "click",
        }, {
            content: "Ready to create Passkey",
            trigger: ".modal-title:contains(Create Passkey)",
        }, {
            content: "Input passkey name",
            trigger: 'input[name="keyname"]',
            run: "edit test_passkey_one",
        }, {
            content: "Override startRegistration",
            trigger: "body",
            run: () => {
                unpatchPasskeyRegistrationPortal = patch(passkeyLib, {
                    async startRegistration() {
                        return {
                            // test-yubikey
                            "id": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "rawId": "L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB",
                            "response": {
                                "attestationObject": "o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjCSZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI",
                                "clientDataJSON": "eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiVW9hNk01akVQN0kzVG95SzlRQTB2ZjhJY3NlemZlSmswcmdzMXBMVVdyTWdGOXZkMC03RHY1aVYzeFc3cjcwLVlxa3dlUlhoQUNtRFBtaEhLdEFJZVEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9",
                                "transports": [
                                    "nfc",
                                    "usb",
                                ],
                                "publicKeyAlgorithm": -7,
                                "publicKey": "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEL2p6jvcWuCMTRmkZHDEsgbnQviQ2WGPYMjKpJz9iJFLarpsvb4ignqP8aRVN188rLHxEXl7zDNf35mTfsDKQzw",
                                "authenticatorData": "SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI",
                            },
                            "type": "public-key",
                            "clientExtensionResults": {},
                            "authenticatorAttachment": "cross-platform",
                        };
                    },
                });
            },
        }, {
            content: "Click the Create button",
            trigger: ".modal-content button:contains(Create)",
            run: "click",
            expectUnloadPage: true,
        }, {
            content: "Return startRegistration to original state",
            trigger: "body",
            run: () => {
                if (unpatchPasskeyRegistrationPortal) {
                    unpatchPasskeyRegistrationPortal();
                }
            },
        }, {
            content: "Ensure there is one passkey",
            trigger: ".o_passkey_name",
            run: () => {
                const amount = document.querySelectorAll(".o_passkey_portal_entry").length;
                if (amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        },
    ],
});

registry.category("web_tour.tours").add("passkeys_portal_rename", {
    url: "/my/security",
    steps: () => [
        {
            content: "Ensure there is one passkey",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                const amount = document.querySelectorAll(".o_passkey_portal_entry").length;
                if (amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        }, {
            content: "Click rename",
            trigger: '.o_passkey_portal_rename',
            run: "click",
        }, {
            content: "Input passkey name",
            trigger: 'input[name="keyname"]',
            run: "edit edited_key",
        }, {
            content: "Confirm the rename",
            trigger: ".modal-content button:contains(Rename)",
            run: "click",
            expectUnloadPage: true,
        }, {
            content: "Ensure the rename occurred",
            trigger: ".o_passkey_name:contains(edited_key)",
        },
    ],
});

registry.category("web_tour.tours").add("passkeys_portal_delete", {
    url: "/my/security",
    steps: () => [
        {
            content: "Ensure there is one passkey",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                const amount = document.querySelectorAll(".o_passkey_portal_entry").length;
                if (amount != 1) {
                    throw Error("Amount of Passkeys must be 1");
                }
            },
        }, {
            content: "Click delete",
            trigger: '.o_passkey_portal_delete',
            run: "click",
        }, {
            content: "Check that we have to enter enhanced security mode",
            trigger: "form strong:contains(Please enter your password to confirm you own this account)",
        }, {
            content: "Input password",
            trigger: "form input[name=password]",
            run: "edit passkey_portal",
        }, {
            content: "Confirm",
            trigger: ".modal-footer button:contains(Confirm Password)",
            run: "click",
            expectUnloadPage: true,
        }, {
            content: "Ensure there are no more passkeys",
            trigger: 'button:contains("Add Passkey")',
            run: () => {
                const amount = document.querySelectorAll(".o_passkey_portal_entry").length;
                if (amount != 0) {
                    throw Error("Amount of Passkeys must be 0");
                }
            },
        },
    ],
});

return __exports;
});
;

/******************************************************
*  Filepath: /auth_totp/static/tests/apikeys_flow.js  *
*  Lines: 119                                         *
******************************************************/
odoo.define('@auth_totp/../tests/apikeys_flow', ['@web/core/network/rpc', '@web/core/registry'], function (require) {
'use strict';
let __exports = {};
const { rpc } = require("@web/core/network/rpc");
const { registry } = require("@web/core/registry");

const openUserPreferenceSecurity = () => [{
    content: 'Open user account menu',
    trigger: '.o_user_menu .dropdown-toggle',
    run: 'click',
}, {
    content: "Open preferences / profile screen",
    trigger: '[data-menu=preferences]',
    run: 'click',
}, {
    content: "Switch to security tab",
    trigger: 'a[role=tab]:contains("Security")',
    run: 'click',
}]

registry.category("web_tour.tours").add('apikeys_tour_setup', {
    url: '/odoo?debug=1', // Needed as API key part is now only displayed in debug mode
    steps: () => [
    ...openUserPreferenceSecurity(), {
    content: "Open API keys wizard",
    trigger: 'button:contains("Add API Key")',
    run: "click",
}, {
    content: "Check that we have to enter enhanced security mode",
    trigger: ".modal div:contains(Enter your current password)",
}, {
    content: "Input password",
    trigger: '.modal [name=password] input',
    run: "edit test_user",
}, {
    content: "Confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check that we're now on the key description dialog",
    trigger: '.modal p:contains("Enter a description of and purpose for the key.")',
}, {
    content: "Enter description",
    trigger: '.modal [name=name] input',
    run: "edit my key",
}, {
    content: "Confirm key creation",
    trigger: '.modal button:contains("Generate key")',
    run: "click",
}, {
    content: "Check that we're on the last step & grab key",
    trigger: '.modal p:contains("Here is your new API key")',
    run: async () => {
        const key = document.querySelector("code [name=key] span").textContent;
        await rpc('/web/dataset/call_kw', {
            model: 'ir.logging', method: 'send_key',
            args: [key],
            kwargs: {},
        });
    }
},
{
    trigger: "button:contains(Done)",
    run: "click",
},
...openUserPreferenceSecurity(),
{
    content: "check that our key is present",
    trigger: '[name=api_key_ids] .o_kanban_record:contains("my key")',
}]});

// deletes the previously created key
registry.category("web_tour.tours").add('apikeys_tour_teardown', {
    url: '/odoo?debug=1', // Needed as API key part is now only displayed in debug mode
    steps: () => [{
    content: 'Open preferences',
    trigger: '.o_user_menu .dropdown-toggle',
    run: "click",
}, {
    trigger: '[data-menu=preferences]',
    run: "click",
}, {
    content: "Switch to security tab",
    trigger: 'a[role=tab]:contains("Security")',
    run: 'click',
}, {
    content: "Open kanban dropdown menu of the key",
    trigger: '[name=api_key_ids] .o_kanban_record:contains("my key") .oe_kanban_action[name="remove"]',
    run: 'click',
}, {
    content: "Input password for security mode again",
    trigger: ".modal [name=password] input",
    run: "edit test_user",
}, {
    content: "And confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
},
{
    trigger: "body:not(:has(.modal))",
},
{
    content: 'Re-open preferences again',
    trigger: '.o_user_menu .dropdown-toggle',
    run: "click",
}, {
    trigger: '[data-menu=preferences]',
    run: "click",
}, {
    content: "Switch to security tab",
    trigger: 'a[role=tab]:contains("Security")',
    run: 'click',
}, {
    content: "Check that there's no more keys",
    trigger: "body:not(:has(.o_notebook [name=api_key_ids]))",
}]});

return __exports;
});
;

/***************************************************
*  Filepath: /auth_totp/static/tests/totp_flow.js  *
*  Lines: 430                                      *
***************************************************/
odoo.define('@auth_totp/../tests/totp_flow', ['@bus/workers/websocket_worker', '@web/core/network/rpc', '@web/core/registry', '@web_tour/tour_utils', '@odoo/owl'], function (require) {
'use strict';
let __exports = {};
const { WORKER_STATE } = require("@bus/workers/websocket_worker");
const { rpc } = require("@web/core/network/rpc");
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");
const { whenReady } = require("@odoo/owl");

function openRoot() {
    return [{
        content: "return to client root to avoid race condition",
        trigger: 'body',
        run() {
            document.querySelector("body").classList.add("wait");
            window.location = '/odoo';
        },
        expectUnloadPage: true,
    }, {
        content: "wait for client reload",
        trigger: 'body:not(.wait)',
    }];
}
function openUserPreferencesAtSecurityTab() {
    return [{
        content: 'Open user account menu',
        trigger: '.o_user_menu .dropdown-toggle',
        run: 'click',
    }, {
        content: "Open My Preferences",
        trigger: '[data-menu=preferences]',
        run: 'click',
    }, {
        content: "wait for security tab",
        trigger: 'a[role=tab]:contains("Security")',
    }, {
        content: "Switch to security tab",
        trigger: 'a[role=tab]:contains("Security")',
        run: 'click',
    }];
}

/**
 * Checks that the TOTP button is in the specified state (true = enabled =
 * can disable, false = disabled = can enable), then closes the preferences dialog
 * if it's one (= hr not installed).
 *
 * If no totp state is provided, just checks that the toggle exists.
 */
function closePreferencesDialog({content, totp_state}) {
    let trigger;
    switch (totp_state) {
    case true: trigger = 'button[name=action_totp_disable]'; break;
    case false: trigger = 'button[name=action_totp_enable_wizard]'; break;
    case undefined: trigger = 'div:contains("Two-factor Authentication") + button'; break;
    default: throw new Error(`Invalid totp state ${totp_state}`)
    }

    return [{
        content,
        trigger: 'a[role=tab]:contains("Security").active',
    }, 
    {
        trigger,
        async run(helpers) {
            const modal = document.querySelector(".o_dialog");
            if (modal) {
                modal.querySelector("button[name=preference_cancel]").click();
            }
        }
    },
    {
        trigger: 'body:not(:has(.o_dialog))',
    }];
}

registry.category("web_tour.tours").add('totp_tour_setup', {
    url: '/odoo',
    steps: () => [
...openUserPreferencesAtSecurityTab(),
{
    content: "Open totp wizard",
    trigger: 'a[role=tab]:contains("Security").active',
},
{
    trigger: "button[name=action_totp_enable_wizard]",
    run: "click",
},
{
    trigger: ".modal div:contains(Enter your current password)",
},
{
    content: "Check that we have to enter enhanced security mode and input password",
    trigger: '[name=password] input',
    run: 'edit test_user',
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check the wizard has opened",
    trigger: '.modal:contains("Two-Factor Authentication Activation")',
}, {
    content: "Get secret from collapsed div",
    trigger: `.modal a:contains("Cannot scan it?")`,
    async run(helpers) {
        const secret = this.anchor
            .closest("div")
            .querySelector("[name=secret] span:first-child");
        const copyBtn = secret.querySelector("button");
        if (copyBtn) {
            copyBtn.remove();
        }
        const token = await rpc('/totphook', {
            secret: secret.textContent,
            offset: 0,
        });
        await helpers.edit(token, '[name=code] input');
    }
},
{
    trigger: ".modal button.btn-primary:contains(Enable Two-Factor Authentication)",
    run: "click",
},
{
    trigger: ".o_notification_content:contains(2-Factor authentication is now enabled)",
},
...openRoot(),
...openUserPreferencesAtSecurityTab(),
...closePreferencesDialog({
    content: "Check that the button has changed",
    totp_state: true,
}),
]});

registry.category("web_tour.tours").add('totp_login_enabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    isActive: ["body:not(:has(input#login))"],
    trigger: "a:contains(Sign in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "input incorrect code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        // set the offset in the past, so the token will be always wrong
        await rpc("/totphook", { offset: -2 });
        helpers.edit("123456");
    }
}, {
    trigger: `button:contains("Log in")`,
    run: "click",
    expectUnloadPage: true,
}, {
    content: "using an incorrect token should fail",
    trigger: "p.alert.alert-danger:contains(Verification failed, please double-check the 6-digit code)",
}, {
    content: "reuse same code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        // send the same token as the one last one from the setup tour
        const token = await rpc("/totphook", { offset: 0 });
        helpers.edit(token);
    }
}, {
    trigger: `button:contains("Log in")`,
    run: "click",
    expectUnloadPage: true,
}, {
    content: "reusing the same token should fail",
    trigger: "p.alert.alert-danger:contains(Verification failed, please use the latest 6-digit code)",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        const token = await rpc('/totphook', { offset: 1 });
        helpers.edit(token);
    }
},
{
    trigger: `button:contains("Log in")`,
    run: "click",
    expectUnloadPage: true,
}, {
    content: "check we're logged in",
    trigger: ".o_user_menu .dropdown-toggle",
}]});

registry.category("web_tour.tours").add('totp_login_device', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    isActive: ["body:not(:has(input#login))"],
    trigger: "a:contains(Sign in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "check remember device box",
    trigger: 'label[for=switch-remember]',
    run: "click",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    async run(helpers) {
        const token = await rpc('/totphook', { offset: 2 });
        helpers.edit(token);
    }
},
{
    trigger: "button:contains(Log in)",
    run: "click",
    expectUnloadPage: true,
},
{
    trigger: ".o_web_client .o_navbar",
    async run() {
        await whenReady();
    }
},
{
    trigger: ".o_web_client .o_navbar",
    async run() {
        await new Promise((resolve) => {
            const bus = odoo.__WOWL_DEBUG__.root.env.services.bus_service;
            bus.addEventListener("BUS:CONNECT", resolve, { once: true });
            if (bus.workerState === WORKER_STATE.CONNECTED) {
                resolve();
            }
        });
    },
},
{
    content: "check we're logged in",
    trigger: ".o_user_menu .dropdown-toggle",
    run: 'click',
}, {
    content: "click the Log out button",
    trigger: '.dropdown-item[data-menu=logout]',
    run: "click",
    expectUnloadPage: true,
}, {
    content: "check that we're back on the login page or go to it",
    trigger: 'input#login, a:contains(Log in)',
    run: "edit Test",
}, {
    content: "input login again",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password again',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button again",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
},  {
    content: "check we're logged in without 2FA",
    trigger: ".o_user_menu .dropdown-toggle",
},
// now go and disable two-factor authentication would be annoying to do in a separate tour
// because we'd need to login & totp again as HttpCase.authenticate can't
// succeed w/ totp enabled
...openUserPreferencesAtSecurityTab(),
{
    content: "Open totp wizard",
    trigger: 'a[role=tab]:contains("Security").active',
},
{
    trigger: "button[name=action_totp_disable]",
    run: "click",
},
{
    trigger: ".modal div:contains(Enter your current password)",
},
{
    content: "Check that we have to enter enhanced security mode and input password",
    trigger: '.modal [name=password] input',
    run: "edit test_user",
}, {
    content: "Confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
},
{
    trigger:".o_notification_content:contains(Two-factor authentication disabled)",
},
...openRoot(),
...openUserPreferencesAtSecurityTab(),
...closePreferencesDialog({
    content: "Check that the button has changed",
    totp_state: false
}),
]});

registry.category("web_tour.tours").add('totp_login_disabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    isActive: ["body:not(:has(input#login))"],
    trigger: "a:contains(Sign in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit test_user",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit test_user",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
},
// normally we'd end the tour here as it's all we care about but there are a
// bunch of ongoing queries from the loading of the web client which cause
// issues, so go and open the preferences screen to make sure
// everything settles down
...openUserPreferencesAtSecurityTab(),
// close the dialog if that makes sense
...closePreferencesDialog({})
]});

registry.category("web_tour.tours").add('totp_admin_disables', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), {
    content: 'Go to settings',
    trigger: '[data-menu-xmlid="base.menu_administration"]',
    run: "click",
}, {
    content: 'Wait for page',
    trigger: '.o_menu_brand:contains("Settings")',
}, {
    content: "Open Users menu",
    trigger: '[data-menu-xmlid="base.menu_users"]',
    run: "click",
}, {
    content: "Open Users view",
    trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
    run: "click",
}, {
    content: "Find test_user User",
    trigger: 'tr:has(td.o_data_cell:contains("test_user")) ' +
                '.o_list_record_selector input[type=checkbox]',
    run: "click",
}, {
    content: "Open Actions menu",
    trigger: 'button.dropdown-toggle:contains("Action")',
    run: "click",
}, {
    content: "Select totp remover",
    trigger: 'span.dropdown-item:contains(Disable two-factor authentication)',
    run: "click",
},
{
    trigger: ".modal div:contains(Enter your current password)",
},
{ // enhanced security yo
    content: "Check that we have to enter enhanced security mode & input password",
    trigger: '.modal [name=password] input',
    run: "edit admin",
}, {
    content: "Confirm",
    trigger: ".modal button:contains(Confirm Password)",
    run: "click",
},
{
    content: "Wait for user to be unchecked (~ action done)",
    trigger: 'tr:has(td.o_data_cell:contains(test_user)) ' +
                '.o_list_record_selector input[type=checkbox]:not(:checked)',
},
{
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(test_user)",
    run: "click",
}, {
    content: "wait for Security Tab to appear",
    trigger: "a.nav-link:contains(Security)",
},{
    content: "go to Security Tab",
    trigger: "a.nav-link:contains(Security)",
    run: "click",
}, {
    content: "check 2FA button: should be disabled",
    trigger: 'body:not(:has(button[name=action_totp_enable_wizard]))',
}
]})

return __exports;
});
;

/********************************************************
*  Filepath: /auth_totp_mail/static/tests/totp_flow.js  *
*  Lines: 72                                            *
********************************************************/
odoo.define('@auth_totp_mail/../tests/totp_flow', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

function openAccountSettingsTab() {
    return [{
        content: 'Go to settings',
        trigger: '[data-menu-xmlid="base.menu_administration"]',
        run: "click",
    }, {
        content: 'Wait for page',
        trigger: '.o_menu_brand:contains("Settings")',
    }, {
        content: "Open Users menu",
        trigger: '[data-menu-xmlid="base.menu_users"]',
        run: "click",
    }, {
        content: "Open Users view",
        trigger: '[data-menu-xmlid="base.menu_action_res_users"]',
        run: function (helpers) {
            // funny story: the users view we're trying to reach, sometimes we're
            // already there, but if we re-click the next step executes before the
            // action has the time to re-load, the one after that doesn't, and our
            // selection get discarded by the action reloading, so here try to
            // see if we're already on the users action through the breadcrumb and
            // just close the menu if so
            const breadcrumb = document.querySelector('.breadcrumb');
            if (!breadcrumb || !breadcrumb.textContent.includes("Users")) {
                // on general settings page, click menu
                helpers.click();
            } else {
                // else close menu
                helpers.click('[data-menu-xmlid="base.menu_users"]');
            }
        }
    }];
}

registry.category("web_tour.tours").add('totp_admin_self_invite', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(admin)",
    run: "click",
}, {
    content: "go to Security Tab",
    trigger: "a.nav-link:contains(Security)",
    run: "click",
}, {
    content: "check that user cannot invite themselves to use 2FA.",
    trigger: "body:not(:has(button:contains(Invite to use 2FA)))",
}]});

registry.category("web_tour.tours").add('totp_admin_invite', {
    url: '/odoo',
    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {
    content: "open the user's form",
    trigger: "td.o_data_cell:contains(test_user)",
    run: "click",
}, {
    content: "go to security Tab",
    trigger: "a.nav-link:contains(Security)",
    run: "click",
}, {
    content: "check that test_user user can be invited to use 2FA.",
    trigger: "button:contains(Invite to use 2FA)",
}]});

return __exports;
});
;

/************************************************************
*  Filepath: /auth_totp_portal/static/tests/totp_portal.js  *
*  Lines: 142                                               *
************************************************************/
odoo.define('@auth_totp_portal/../tests/totp_portal', ['@web/core/registry', '@web/core/network/rpc'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { rpc } = require("@web/core/network/rpc");

registry.category("web_tour.tours").add('totportal_tour_setup', {
    url: '/my/security',
    steps: () => [{
    content: "Open totp wizard",
    trigger: 'button#auth_totp_portal_enable',
    run: "click",
}, {
    content: "Check that we have to enter enhanced security mode",
    trigger: ".modal div:contains(enter your password)",
}, {
    content: "Input password",
    trigger: '[name=password]',
    run: "edit portal", // FIXME: better way to do this?
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
}, {
    content: "Check the wizard has opened",
    trigger: '.o_auth_totp_enable_2FA',
}, {
    content: "Get secret from collapsed div",
    trigger: 'a:contains("Cannot scan it?")',
},
{
    trigger: `span[name="secret"]:hidden`,
    async run(helpers) {
        const secret = this.anchor.textContent;
        const token = await rpc("/totphook", {
            secret,
            offset: 0,
        });
        await helpers.edit(token, 'input[name="code"]');
    }
}, {
    trigger: "button.btn-primary:contains(Activate)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "Check that the button has changed",
    trigger: 'button:contains(Disable two-factor authentication)',
}]});

registry.category("web_tour.tours").add('totportal_login_enabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    isActive: ["body:not(:has(input#login))"],
    trigger: "a:contains(Sign in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit portal",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit portal",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
}, {
    content: "expect totp screen",
    trigger: 'label:contains(Authentication Code)',
    run: "click",
}, {
    content: "input code",
    trigger: 'input[name=totp_token]',
    run: async function (helpers) {
        const token = await rpc('/totphook', { offset: 1 });
        await helpers.edit(token);
    }
}, {
    trigger: "button:contains(Log in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "check we're logged in",
    trigger: "h3:contains(My account)",
}, {
    content: "go back to security",
    trigger: "a:contains(Security)",
    run: "click",
    expectUnloadPage: true,
},{
    content: "Open totp wizard",
    trigger: 'button#auth_totp_portal_disable',
    run: "click",
}, {
    content: "Check that we have to enter enhanced security mode",
    trigger: ".modal div:contains(enter your password)",
}, {
    content: "Input password",
    trigger: '[name=password]',
    run: "edit portal",
}, {
    content: "Confirm",
    trigger: "button:contains(Confirm Password)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "Check that the button has changed",
    trigger: 'button:contains(Enable two-factor authentication)',
}]});

registry.category("web_tour.tours").add('totportal_login_disabled', {
    url: '/',
    steps: () => [{
    content: "check that we're on the login page or go to it",
    isActive: ["body:not(:has(input#login))"],
    trigger: "a:contains(Sign in)",
    run: "click",
    expectUnloadPage: true,
}, {
    content: "input login",
    trigger: 'input#login',
    run: "edit portal",
}, {
    content: 'input password',
    trigger: 'input#password',
    run: "edit portal",
}, {
    content: "click da button",
    trigger: 'button:contains("Log in")',
    run: "click",
    expectUnloadPage: true,
}, {
    content: "check we're logged in",
    trigger: "h3:contains(My account)",
}]});

return __exports;
});
;

/*********************************************************************************************
*  Filepath: /sale_pdf_quote_builder/static/tests/tours/custom_content_kanban_like_tests.js  *
*  Lines: 28                                                                                 *
*********************************************************************************************/
odoo.define('@sale_pdf_quote_builder/../tests/tours/custom_content_kanban_like_tests', ['@web/core/registry', '@web_tour/tour_utils'], function (require) {
'use strict';
let __exports = {};
const { registry } = require("@web/core/registry");
const { stepUtils } = require("@web_tour/tour_utils");

registry.category("web_tour.tours").add('custom_content_kanban_like_tour', {
    steps: () => [
        {
            trigger: "ul.nav a:contains(Quote Builder)",
            run: "click",
        },
        {
            trigger: "label:contains(Header)",
            run: "click",
        },
        {
            trigger: "h5:contains(custom_1) ~ div textarea",
            break: true,
            run: "edit Test",
        },
        ...stepUtils.saveForm(),
        // TODO VCR: Finish this
    ]
});

return __exports;
});


//# sourceMappingURL=/web/assets/3b79898/web.assets_tests.js.map