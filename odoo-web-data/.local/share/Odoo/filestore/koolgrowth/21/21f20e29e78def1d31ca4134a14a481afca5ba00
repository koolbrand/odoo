)]}'
{"version": 3, "sources": ["/base/static/tests/test_ir_model_fields_translation.js", "/web/static/tests/legacy/helpers/cleanup.js", "/web/static/tests/legacy/helpers/utils.js", "/web/static/tests/legacy/utils.js", "/web/static/tests/tours/favorite_management_tour.js", "/web/static/tests/tours/test_user_group_settings_tour.js", "/web/static/tests/tours/user_switch_tour.js", "/web_tour/static/src/js/tour_automatic/tour_helpers.js", "/web/static/lib/hoot-dom/helpers/dom.js", "/web/static/lib/hoot-dom/helpers/events.js", "/web/static/lib/hoot-dom/helpers/time.js", "/web/static/lib/hoot-dom/hoot-dom.js", "/web/static/lib/hoot-dom/hoot_dom_utils.js", "/web_tour/static/src/js/tour_step.js", "/web_tour/static/src/js/tour_automatic/tour_automatic.js", "/web_tour/static/src/js/tour_automatic/tour_helpers_hoot.js", "/web_tour/static/src/js/tour_automatic/tour_step_automatic.js", "/html_editor/static/tests/tours/helpers/editor.js", "/mail/static/tests/tours/activity_date_format_tour.js", "/mail/static/tests/tours/create_channel_tour.js", "/mail/static/tests/tours/discuss_call_invitation_tour.js", "/mail/static/tests/tours/discuss_channel_as_guest_tour.js", "/mail/static/tests/tours/discuss_channel_call_action.js", "/mail/static/tests/tours/discuss_channel_call_public_tour.js", "/mail/static/tests/tours/discuss_channel_meeting_view_tour.js", "/mail/static/tests/tours/discuss_channel_public_tour.js", "/mail/static/tests/tours/discuss_configuration_tour.js", "/mail/static/tests/tours/discuss_go_back_to_thread_from_breadcrumbs_tour.js", "/mail/static/tests/tours/discuss_invite_by_email_tour.js", "/mail/static/tests/tours/discuss_mention_suggestions_group_restricted_channel.js", "/mail/static/tests/tours/discuss_sidebar_in_public_page_tour.js", "/mail/static/tests/tours/discuss_sub_channel_search_tour.js", "/mail/static/tests/tours/mail_activity_schedule_from_chatter.js", "/mail/static/tests/tours/mail_composer_autosave_tour.js", "/mail/static/tests/tours/mail_composer_test_tour.js", "/mail/static/tests/tours/mail_html_composer_test_tour.js", "/mail/static/tests/tours/mail_message_load_order_tour.js", "/mail/static/tests/tours/mail_template_dynamic_placeholder_tour.js", "/mail/static/tests/tours/user_modify_own_profile_tour.js", "/portal/static/tests/tours/portal.js", "/portal/static/tests/tours/skip_to_content.js", "/account/static/src/js/tours/tour_utils.js", "/account/static/tests/tours/account_product_catalog_tests.js", "/account/static/tests/tours/deductible_amount_column.js", "/account/static/tests/tours/tax_group_tests.js", "/account/static/tests/tours/tour_tests_shared_js_python.js", "/sale/static/tests/tours/mail_attachment_removal_test_tour.js", "/sale/static/tests/tours/product_attribute_value_tour.js", "/sale/static/tests/tours/sale_catalog.js", "/sale/static/tests/tours/sale_combo_configurator.js", "/sale/static/tests/tours/sale_combo_configurator_preconfigure_unconfigurable_ptals.js", "/sale/static/tests/tours/sale_combo_configurator_preselect_single_unconfigurable_items.js", "/sale/static/tests/tours/sale_order_product_uom_integrity.js", "/sale/static/tests/tours/sale_signature.js", "/sale/static/src/js/tours/combo_configurator_tour_utils.js", "/sale/static/src/js/tours/product_configurator_tour_utils.js", "/sale/static/src/js/tours/tour_utils.js", "/calendar/static/tests/tours/calendar_tour.js", "/contacts/static/tests/tours/debug_menu_set_defaults.js", "/crm/static/tests/tours/create_crm_team_tour.js", "/crm/static/tests/tours/crm_email_and_phone_propagation.js", "/crm/static/tests/tours/crm_forecast_tour.js", "/crm/static/tests/tours/crm_rainbowman.js", "/auth_passkey/static/tests/passkeys_delete.js", "/auth_passkey/static/tests/passkeys_login.js", "/auth_passkey/static/tests/passkeys_registration.js", "/auth_passkey/static/tests/passkeys_verify.js", "/auth_passkey_portal/static/tests/tours/test_passkey_portal.js", "/auth_totp/static/tests/apikeys_flow.js", "/auth_totp/static/tests/totp_flow.js", "/auth_totp_mail/static/tests/totp_flow.js", "/auth_totp_portal/static/tests/totp_portal.js", "/sale_pdf_quote_builder/static/tests/tours/custom_content_kanban_like_tests.js"], "mappings": "AAAA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjnCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7qBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3HA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnJA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7KA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACfA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpoEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACh4FA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/eA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5aA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7NA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnXA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClMA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9DA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC3CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACdA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9BA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7MA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACXA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/KA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC5CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtRA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACnGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpOA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC9IA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AChCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxDA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACrCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACdA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjFA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjNA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzQA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjGA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtCA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzBA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7FA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7EA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1CA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACtKA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACjHA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxaA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClEA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACxIA;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\nfunction checkLoginColumn(translation) {\n    return [\n        stepUtils.showAppsMenuItem(), {\n            content: \"Settings\",\n            trigger: 'a[data-menu-xmlid=\"base.menu_administration\"]',\n            run: 'click',\n        }, {\n            content: \"Open Users & Companies\",\n            trigger: '[data-menu-xmlid=\"base.menu_users\"]',\n            run: \"click\",\n        }, {\n            content: \"Open Users\",\n            trigger: '[data-menu-xmlid=\"base.menu_action_res_users\"]',\n            run: \"click\",\n        }, {\n            content: `Login column should be ${translation}`,\n            trigger: `[data-name=\"login\"] span:contains(\"${translation}\")`,\n        }\n    ]\n}\n\nregistry.category(\"web_tour.tours\").add('ir_model_fields_translation_en_tour', {\n    url: '/odoo',\n    steps: () => checkLoginColumn('Login')\n});\n\nregistry.category(\"web_tour.tours\").add('ir_model_fields_translation_en_tour2', {\n    url: '/odoo',\n    steps: () => checkLoginColumn('Login2')\n});\n\nregistry.category(\"web_tour.tours\").add('ir_model_fields_translation_fr_tour', {\n    url: '/odoo',\n    steps: () => checkLoginColumn('Identifiant')\n});\n\nregistry.category(\"web_tour.tours\").add('ir_model_fields_translation_fr_tour2', {\n    url: '/odoo',\n    steps: () => checkLoginColumn('Identifiant2')\n});\n", "/** @odoo-module alias=@web/../tests/helpers/cleanup default=false */\n\n// -----------------------------------------------------------------------------\n// Cleanup\n// -----------------------------------------------------------------------------\n\nconst cleanups = [];\n\n/**\n * Register a cleanup callback that will be executed whenever the current test\n * is done.\n *\n * - the cleanups will be executed in reverse order\n * - they will be executed even if the test fails/crashes\n *\n * @param {Function} callback\n */\nexport function registerCleanup(callback) {\n    cleanups.push(callback);\n}\n\nif (window.QUnit) {\n    QUnit.on(\"OdooAfterTestHook\", (info) => {\n        if (QUnit.config.debug) {\n            return;\n        }\n        let cleanup;\n        // note that this calls the cleanup callbacks in reverse order!\n        while ((cleanup = cleanups.pop())) {\n            try {\n                cleanup(info);\n            } catch (error) {\n                console.error(error);\n            }\n        }\n    });\n\n    // -----------------------------------------------------------------------------\n    // Check leftovers\n    // -----------------------------------------------------------------------------\n\n    /**\n     * List of elements tolerated in the body after a test. The property \"keep\"\n     * prevents the element from being removed (typically: qunit suite elements).\n     */\n    const validElements = [\n        // always in the body:\n        { tagName: \"DIV\", attr: \"id\", value: \"qunit\", keep: true },\n        { tagName: \"DIV\", attr: \"id\", value: \"qunit-fixture\", keep: true },\n        // shouldn't be in the body after a test but are tolerated:\n        { tagName: \"SCRIPT\", attr: \"id\", value: \"\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"o_notification_manager\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip fade bs-tooltip-auto\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip fade bs-tooltip-auto show\" },\n        { tagName: \"DIV\", attr: \"class\", value: \"tooltip tooltip-field-info fade bs-tooltip-auto\" },\n        {\n            tagName: \"DIV\",\n            attr: \"class\",\n            value: \"tooltip tooltip-field-info fade bs-tooltip-auto show\",\n        },\n\n        // Due to a Document Kanban bug (already present in 12.0)\n        { tagName: \"DIV\", attr: \"class\", value: \"ui-helper-hidden-accessible\" },\n        {\n            tagName: \"UL\",\n            attr: \"class\",\n            value: \"ui-menu ui-widget ui-widget-content ui-autocomplete ui-front\",\n        },\n        {\n            tagName: \"UL\",\n            attr: \"class\",\n            value: \"ui-menu ui-widget ui-widget-content ui-autocomplete dropdown-menu ui-front\", // many2ones\n        },\n    ];\n\n    /**\n     * After each test, we check that there is no leftover in the DOM.\n     *\n     * Note: this event is not QUnit standard, we added it for this specific use case.\n     * As a payload, an object with keys 'moduleName' and 'testName' is provided. It\n     * is used to indicate the test that left elements in the DOM, when it happens.\n     */\n    QUnit.on(\"OdooAfterTestHook\", function (info) {\n        if (QUnit.config.debug) {\n            return;\n        }\n        const failed = info.testReport.getStatus() === \"failed\";\n        const toRemove = [];\n        // check for leftover elements in the body\n        for (const bodyChild of document.body.children) {\n            const tolerated = validElements.find(\n                (e) => e.tagName === bodyChild.tagName && bodyChild.getAttribute(e.attr) === e.value\n            );\n            if (!failed && !tolerated) {\n                QUnit.pushFailure(\n                    `Body still contains undesirable elements:\\n${bodyChild.outerHTML}`\n                );\n            }\n            if (!tolerated || !tolerated.keep) {\n                toRemove.push(bodyChild);\n            }\n        }\n        // cleanup leftovers in #qunit-fixture\n        const qunitFixture = document.getElementById(\"qunit-fixture\");\n        if (qunitFixture.children.length) {\n            toRemove.push(...qunitFixture.children);\n        }\n        // remove unwanted elements if not in debug\n        for (const el of toRemove) {\n            el.remove();\n        }\n        document.body.classList.remove(\"modal-open\");\n    });\n}\n", "/** @odoo-module alias=@web/../tests/helpers/utils default=false */\n\nimport { getTemplate } from \"@web/core/templates\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { isMacOS } from \"@web/core/browser/feature_detection\";\nimport { download } from \"@web/core/network/download\";\nimport { getPopoverForTarget } from \"@web/core/popover/popover\";\nimport { Deferred } from \"@web/core/utils/concurrency\";\nimport { patch } from \"@web/core/utils/patch\";\nimport { isVisible } from \"@web/core/utils/ui\";\nimport { _t } from \"@web/core/l10n/translation\";\nimport { registerCleanup } from \"./cleanup\";\nimport { customDirectives, globalValues } from \"@web/env\";\n\nimport {\n    App,\n    onError,\n    onMounted,\n    onPatched,\n    onRendered,\n    onWillDestroy,\n    onWillPatch,\n    onWillRender,\n    onWillStart,\n    onWillUnmount,\n    onWillUpdateProps,\n    useComponent,\n} from \"@odoo/owl\";\n\n/**\n * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType\n *\n * @typedef {Side | `${Side}-${Side}` | { x?: number, y?: number }} Position\n *\n * @typedef {\"bottom\" | \"left\" | \"right\" | \"top\"} Side\n *\n * @typedef TriggerEventOptions\n * @property {boolean} [skipVisibilityCheck=false]\n * @property {boolean} [sync=false]\n */\n\n/**\n * Patch the native Date object\n *\n * Note that it will be automatically unpatched at the end of the test\n *\n * @param {number} [year]\n * @param {number} [month]\n * @param {number} [day]\n * @param {number} [hours]\n * @param {number} [minutes]\n * @param {number} [seconds]\n * @param {number} [ms=0]\n */\nexport function patchDate(year, month, day, hours, minutes, seconds, ms = 0) {\n    var RealDate = window.Date;\n    var actualDate = new RealDate();\n\n    // By default, RealDate uses the browser offset, so we must replace it with the offset fixed in luxon.\n    var fakeDate = new RealDate(year, month, day, hours, minutes, seconds, ms);\n    if (!(luxon.Settings.defaultZone instanceof luxon.FixedOffsetZone)) {\n        throw new Error(\"luxon.Settings.defaultZone must be a FixedOffsetZone\");\n    }\n    const browserOffset = -fakeDate.getTimezoneOffset();\n    const patchedOffset = luxon.Settings.defaultZone.offset();\n    const offsetDiff = patchedOffset - browserOffset;\n    const correctedMinutes = fakeDate.getMinutes() - offsetDiff;\n    fakeDate.setMinutes(correctedMinutes);\n\n    var timeInterval = actualDate.getTime() - fakeDate.getTime();\n\n    // eslint-disable-next-line no-global-assign\n    window.Date = (function (NativeDate) {\n        function Date(Y, M, D, h, m, s, ms) {\n            var length = arguments.length;\n            let date;\n            if (arguments.length > 0) {\n                date =\n                    length == 1 && String(Y) === Y // isString(Y)\n                        ? // We explicitly pass it through parse:\n                          new NativeDate(Date.parse(Y))\n                        : // We have to manually make calls depending on argument\n                        // length here\n                        length >= 7\n                        ? new NativeDate(Y, M, D, h, m, s, ms)\n                        : length >= 6\n                        ? new NativeDate(Y, M, D, h, m, s)\n                        : length >= 5\n                        ? new NativeDate(Y, M, D, h, m)\n                        : length >= 4\n                        ? new NativeDate(Y, M, D, h)\n                        : length >= 3\n                        ? new NativeDate(Y, M, D)\n                        : length >= 2\n                        ? new NativeDate(Y, M)\n                        : length >= 1\n                        ? new NativeDate(Y)\n                        : new NativeDate();\n                // Prevent mixups with unfixed Date object\n                date.constructor = Date;\n                return date;\n            } else {\n                date = new NativeDate();\n                var time = date.getTime();\n                time -= timeInterval;\n                date.setTime(time);\n                return date;\n            }\n        }\n\n        // Copy any custom methods a 3rd party library may have added\n        for (var key in NativeDate) {\n            Date[key] = NativeDate[key];\n        }\n\n        // Copy \"native\" methods explicitly; they may be non-enumerable\n        // exception: 'now' uses fake date as reference\n        Date.now = function () {\n            var date = new NativeDate();\n            var time = date.getTime();\n            time -= timeInterval;\n            return time;\n        };\n        Date.UTC = NativeDate.UTC;\n        Date.prototype = NativeDate.prototype;\n        Date.prototype.constructor = Date;\n\n        // Upgrade Date.parse to handle simplified ISO 8601 strings\n        Date.parse = NativeDate.parse;\n        return Date;\n    })(Date);\n\n    registerCleanup(() => {\n        window.Date = RealDate;\n    });\n}\n\n/**\n * Applies a fixed time zone to luxon based on an offset to the UTC time zone.\n *\n * @param {number} offset the number of minutes ahead or behind the UTC time zone\n *                          +120 => UTC+2\n *                          -120 => UTC-2\n */\nexport function patchTimeZone(offset) {\n    patchWithCleanup(luxon.Settings, { defaultZone: luxon.FixedOffsetZone.instance(offset) });\n}\n\n/**\n *\n * @param {Object} obj object to patch\n * @param {Object} patchValue the actual patch description\n */\nexport function patchWithCleanup(obj, patchValue) {\n    const unpatch = patch(obj, patchValue);\n    registerCleanup(() => {\n        unpatch();\n    });\n}\n\n/**\n * @returns {Element}\n */\nexport function getFixture() {\n    if (!window.QUnit) {\n        return document;\n    }\n    if (QUnit.config.debug) {\n        return document.body;\n    } else {\n        return document.getElementById(\"qunit-fixture\");\n    }\n}\n\nexport async function nextTick() {\n    await new Promise((resolve) => window.requestAnimationFrame(resolve));\n    await new Promise((resolve) => setTimeout(resolve));\n}\n\nexport function makeDeferred() {\n    return new Deferred();\n}\n\nexport function findElement(el, selector) {\n    let target = el;\n    if (selector) {\n        const els = el.querySelectorAll(selector);\n        if (els.length === 0) {\n            throw new Error(`No element found (selector: ${selector})`);\n        }\n        if (els.length > 1) {\n            throw new Error(`Found ${els.length} elements, instead of 1 (selector: ${selector})`);\n        }\n        target = els[0];\n    }\n    return target;\n}\n\n//-----------------------------------------------------------------------------\n// Event init attributes mappers\n//-----------------------------------------------------------------------------\n\n/** @param {EventInit} [args] */\nconst mapBubblingEvent = (args) => ({ ...args, bubbles: true });\n\n/** @param {EventInit} [args] */\nconst mapNonBubblingEvent = (args) => ({ ...args, bubbles: false });\n\n/** @param {EventInit} [args={}] */\nconst mapBubblingPointerEvent = (args = {}) => ({\n    clientX: args.pageX,\n    clientY: args.pageY,\n    ...args,\n    bubbles: true,\n    cancelable: true,\n    view: window,\n});\n\n/** @param {EventInit} [args] */\nconst mapNonBubblingPointerEvent = (args) => ({\n    ...mapBubblingPointerEvent(args),\n    bubbles: false,\n    cancelable: false,\n});\n\n/** @param {EventInit} [args={}] */\nconst mapCancelableTouchEvent = (args = {}) => ({\n    ...args,\n    bubbles: true,\n    cancelable: true,\n    composed: true,\n    rotation: 0.0,\n    touches: args.touches ? [...args.touches.map((e) => new Touch(e))] : undefined,\n    view: window,\n    zoom: 1.0,\n});\n\n/** @param {EventInit} [args] */\nconst mapNonCancelableTouchEvent = (args) => ({\n    ...mapCancelableTouchEvent(args),\n    cancelable: false,\n});\n\n/** @param {EventInit} [args] */\nconst mapKeyboardEvent = (args) => ({\n    ...args,\n    bubbles: true,\n    cancelable: true,\n});\n\n/**\n * @template {typeof Event} T\n * @param {EventType} eventType\n * @returns {[T, (attrs: EventInit) => EventInit]}\n */\nconst getEventConstructor = (eventType) => {\n    switch (eventType) {\n        // Mouse events\n        case \"auxclick\":\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"mousedown\":\n        case \"mouseup\":\n        case \"mousemove\":\n        case \"mouseover\":\n        case \"mouseout\": {\n            return [MouseEvent, mapBubblingPointerEvent];\n        }\n        case \"mouseenter\":\n        case \"mouseleave\": {\n            return [MouseEvent, mapNonBubblingPointerEvent];\n        }\n        // Pointer events\n        case \"pointerdown\":\n        case \"pointerup\":\n        case \"pointermove\":\n        case \"pointerover\":\n        case \"pointerout\": {\n            return [PointerEvent, mapBubblingPointerEvent];\n        }\n        case \"pointerenter\":\n        case \"pointerleave\": {\n            return [PointerEvent, mapNonBubblingPointerEvent];\n        }\n        // Focus events\n        case \"focusin\": {\n            return [FocusEvent, mapBubblingEvent];\n        }\n        case \"focus\":\n        case \"blur\": {\n            return [FocusEvent, mapNonBubblingEvent];\n        }\n        // Clipboard events\n        case \"cut\":\n        case \"copy\":\n        case \"paste\": {\n            return [ClipboardEvent, mapBubblingEvent];\n        }\n        // Keyboard events\n        case \"keydown\":\n        case \"keypress\":\n        case \"keyup\": {\n            return [KeyboardEvent, mapKeyboardEvent];\n        }\n        // Drag events\n        case \"drag\":\n        case \"dragend\":\n        case \"dragenter\":\n        case \"dragstart\":\n        case \"dragleave\":\n        case \"dragover\":\n        case \"drop\": {\n            return [DragEvent, mapBubblingEvent];\n        }\n        // Input events\n        case \"input\": {\n            return [InputEvent, mapBubblingEvent];\n        }\n        // Composition events\n        case \"compositionstart\":\n        case \"compositionend\": {\n            return [CompositionEvent, mapBubblingEvent];\n        }\n        // UI events\n        case \"scroll\": {\n            return [UIEvent, mapNonBubblingEvent];\n        }\n        // Touch events\n        case \"touchstart\":\n        case \"touchend\":\n        case \"touchmove\": {\n            return [TouchEvent, mapCancelableTouchEvent];\n        }\n        case \"touchcancel\": {\n            return [TouchEvent, mapNonCancelableTouchEvent];\n        }\n        // Default: base Event constructor\n        default: {\n            return [Event, mapBubblingEvent];\n        }\n    }\n};\n\n/**\n * @template {EventType} T\n * @param {Element} el\n * @param {string | null | undefined | false} selector\n * @param {T} eventType\n * @param {EventInit} [eventInit]\n * @param {TriggerEventOptions} [options={}]\n * @returns {GlobalEventHandlersEventMap[T] | Promise<GlobalEventHandlersEventMap[T]>}\n */\nexport function triggerEvent(el, selector, eventType, eventInit, options = {}) {\n    const errors = [];\n    const target = findElement(el, selector);\n\n    // Error handling\n    if (typeof eventType !== \"string\") {\n        errors.push(\"event type must be a string\");\n    }\n    if (!target) {\n        errors.push(\"cannot find target\");\n    } else if (!options.skipVisibilityCheck && !isVisible(target)) {\n        errors.push(\"target is not visible\");\n    }\n    if (errors.length) {\n        throw new Error(\n            `Cannot trigger event${eventType ? ` \"${eventType}\"` : \"\"}${\n                selector ? ` (with selector \"${selector}\")` : \"\"\n            }: ${errors.join(\" and \")}`\n        );\n    }\n\n    // Actual dispatch\n    const [Constructor, processParams] = getEventConstructor(eventType);\n    const event = new Constructor(eventType, processParams(eventInit));\n    target.dispatchEvent(event);\n\n    if (window.QUnit && QUnit.config.debug) {\n        const group = `%c[${event.type.toUpperCase()}]`;\n        console.groupCollapsed(group, \"color: #b52c9b\");\n        console.log(target, event);\n        console.groupEnd(group, \"color: #b52c9b\");\n    }\n\n    if (options.sync) {\n        return event;\n    } else {\n        return nextTick().then(() => event);\n    }\n}\n\n/**\n * @param {Element} el\n * @param {string | null | undefined | false} selector\n * @param {(EventType | [EventType, EventInit])[]} [eventDefs]\n * @param {TriggerEventOptions} [options={}]\n */\nexport function triggerEvents(el, selector, eventDefs, options = {}) {\n    const events = [...eventDefs].map((eventDef) => {\n        const [eventType, eventInit] = Array.isArray(eventDef) ? eventDef : [eventDef, {}];\n        return triggerEvent(el, selector, eventType, eventInit, options);\n    });\n    if (options.sync) {\n        return events;\n    } else {\n        return nextTick().then(() => events);\n    }\n}\n\n/**\n * Triggers a scroll event on the given target\n *\n * If the target cannot be scrolled or an axis has reached\n * the end of the scrollable area, the event can be transmitted\n * to its nearest parent until it can be triggered\n *\n * @param {Element} target target of the scroll event\n * @param {Object} coordinates\n * @param {number} coordinates.left coordinates to scroll horizontally\n * @param {number} coordinates.top coordinates to scroll vertically\n * @param {boolean} canPropagate states if the scroll can propagate to a scrollable parent\n */\nexport async function triggerScroll(\n    target,\n    coordinates = { left: null, top: null },\n    canPropagate = true\n) {\n    const isScrollable =\n        (target.scrollHeight > target.clientHeight && target.clientHeight > 0) ||\n        (target.scrollWidth > target.clientWidth && target.clientWidth > 0);\n    if (!isScrollable && !canPropagate) {\n        return;\n    }\n    if (isScrollable) {\n        const canScrollFrom = {\n            left:\n                coordinates.left > target.scrollLeft\n                    ? target.scrollLeft + target.clientWidth < target.scrollWidth\n                    : target.scrollLeft > 0,\n            top:\n                coordinates.top > target.scrollTop\n                    ? target.scrollTop + target.clientHeight < target.scrollHeight\n                    : target.scrollTop > 0,\n        };\n        const scrollCoordinates = {};\n        Object.entries(coordinates).forEach(([key, value]) => {\n            if (value !== null && canScrollFrom[key]) {\n                scrollCoordinates[key] = value;\n                delete coordinates[key];\n            }\n        });\n        target.scrollTo(scrollCoordinates);\n        await triggerEvent(target, null, \"scroll\");\n        if (!canPropagate || !Object.entries(coordinates).length) {\n            return;\n        }\n    }\n    target.parentElement\n        ? triggerScroll(target.parentElement, coordinates)\n        : triggerEvent(window, null, \"scroll\");\n    await nextTick();\n}\n\nexport function click(\n    el,\n    selector,\n    { mouseEventInit = {}, skipDisabledCheck = false, skipVisibilityCheck = false } = {}\n) {\n    if (!skipDisabledCheck && el.disabled) {\n        throw new Error(\"Can't click on a disabled button\");\n    }\n    return triggerEvents(\n        el,\n        selector,\n        [\n            \"pointerdown\",\n            \"mousedown\",\n            \"focus\",\n            \"focusin\",\n            \"pointerup\",\n            \"mouseup\",\n            [\"click\", mouseEventInit],\n        ],\n        { skipVisibilityCheck }\n    );\n}\n\nexport function clickCreate(htmlElement) {\n    if (\n        htmlElement.querySelectorAll(\n            \".o_control_panel_main_buttons .o_form_button_create\"\n        ).length\n    ) {\n        return click(\n            htmlElement,\n            \".o_control_panel_main_buttons .o_form_button_create\"\n        );\n    } else if (\n        htmlElement.querySelectorAll(\n            \".o_control_panel_main_buttons .o_list_button_create\"\n        ).length\n    ) {\n        return click(\n            htmlElement,\n            \".o_control_panel_main_buttons .o_list_button_create\"\n        );\n    } else {\n        throw new Error(\"No edit button found to be clicked.\");\n    }\n}\n\nexport function clickEdit(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_list_button_edit\").length) {\n        return click(htmlElement, \".o_list_button_edit\");\n    } else {\n        throw new Error(\"No edit button found to be clicked.\");\n    }\n}\n\nexport async function clickSave(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_form_status_indicator\").length) {\n        await mouseEnter(htmlElement, \".o_form_status_indicator\");\n    }\n    if (htmlElement.querySelectorAll(\".o_form_button_save\").length) {\n        return click(htmlElement, \".o_form_button_save\");\n    }\n    const listSaveButtons = htmlElement.querySelectorAll(\".o_list_button_save\");\n    if (listSaveButtons.length) {\n        return listSaveButtons.length >= 2 ? click(listSaveButtons[1]) : click(listSaveButtons[0]);\n    } else {\n        throw new Error(\"No save button found to be clicked.\");\n    }\n}\n\nexport async function clickDiscard(htmlElement) {\n    if (htmlElement.querySelectorAll(\".o_form_status_indicator\").length) {\n        await mouseEnter(htmlElement, \".o_form_status_indicator\");\n    }\n    if (htmlElement.querySelectorAll(\".o_form_button_cancel\").length) {\n        return click(htmlElement, \".o_form_button_cancel\");\n    } else if ($(htmlElement).find(\".o_list_button_discard:visible\").length) {\n        return click($(htmlElement).find(\".o_list_button_discard:visible\").get(0));\n    } else {\n        throw new Error(\"No discard button found to be clicked.\");\n    }\n}\n\n/**\n * Trigger pointerenter and mouseenter events on the given target. If no\n * coordinates are given, the event is located by default\n * in the middle of the target to simplify the test process\n *\n * @param {Element} el\n * @param {string} selector\n * @param {Object} coordinates position of the mouseenter event\n */\nexport async function mouseEnter(el, selector, coordinates) {\n    const target = el.querySelector(selector) || el;\n    const atPos = coordinates || {\n        clientX: target.getBoundingClientRect().left + target.getBoundingClientRect().width / 2,\n        clientY: target.getBoundingClientRect().top + target.getBoundingClientRect().height / 2,\n    };\n    return triggerEvents(target, null, [\"pointerenter\", \"mouseenter\"], atPos);\n}\n\n/**\n * Trigger pointerleave and mouseleave events on the given target.\n *\n * @param {Element} el\n * @param {string} selector\n */\nexport async function mouseLeave(el, selector) {\n    const target = el.querySelector(selector) || el;\n    return triggerEvents(target, null, [\"pointerleave\", \"mouseleave\"]);\n}\n\nexport async function editInput(el, selector, value) {\n    const input = findElement(el, selector);\n    if (!(input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement)) {\n        throw new Error(\"Only 'input' and 'textarea' elements can be edited with 'editInput'.\");\n    }\n    if (\n        ![\"text\", \"textarea\", \"email\", \"search\", \"color\", \"number\", \"file\", \"tel\"].includes(\n            input.type\n        )\n    ) {\n        throw new Error(`Type \"${input.type}\" not supported by 'editInput'.`);\n    }\n\n    const eventOpts = {};\n    if (input.type === \"file\") {\n        const files = Array.isArray(value) ? value : [value];\n        const dataTransfer = new DataTransfer();\n        for (const file of files) {\n            if (!(file instanceof File)) {\n                throw new Error(`File input value should be one or several File objects.`);\n            }\n            dataTransfer.items.add(file);\n        }\n        input.files = dataTransfer.files;\n        eventOpts.skipVisibilityCheck = true;\n    } else {\n        input.value = value;\n    }\n\n    await triggerEvents(input, null, [\"input\", \"change\"], eventOpts);\n\n    if (input.type === \"file\") {\n        // Need to wait for the file to be loaded by the input\n        await nextTick();\n        await nextTick();\n    }\n}\n\nexport function editSelect(el, selector, value) {\n    const select = findElement(el, selector);\n    if (select.tagName !== \"SELECT\") {\n        throw new Error(\"Only select tag can be edited with selectInput.\");\n    }\n    select.value = value;\n    return triggerEvent(select, null, \"change\");\n}\n\nexport async function editSelectMenu(el, selector, value) {\n    const dropdown = el.querySelector(selector);\n    await click(dropdown.querySelector(\".dropdown-toggle\"));\n    for (const item of Array.from(el.querySelectorAll(\".o_select_menu_menu .dropdown-item\"))) {\n        if (item.textContent === value) {\n            return click(item);\n        }\n    }\n}\n\n/**\n * Triggers an hotkey properly disregarding the operating system.\n *\n * @param {string} hotkey\n * @param {boolean} addOverlayModParts\n * @param {KeyboardEventInit} eventAttrs\n */\nexport async function triggerHotkey(hotkey, addOverlayModParts = false, eventAttrs = {}) {\n    eventAttrs.key = hotkey.split(\"+\").pop();\n\n    if (/shift/i.test(hotkey)) {\n        eventAttrs.shiftKey = true;\n    }\n\n    if (/control/i.test(hotkey)) {\n        if (isMacOS()) {\n            eventAttrs.metaKey = true;\n        } else {\n            eventAttrs.ctrlKey = true;\n        }\n    }\n\n    if (/alt/i.test(hotkey) || addOverlayModParts) {\n        if (isMacOS()) {\n            eventAttrs.ctrlKey = true;\n        } else {\n            eventAttrs.altKey = true;\n        }\n    }\n\n    if (!(\"bubbles\" in eventAttrs)) {\n        eventAttrs.bubbles = true;\n    }\n\n    const [keydownEvent, keyupEvent] = await triggerEvents(\n        document.activeElement,\n        null,\n        [\n            [\"keydown\", eventAttrs],\n            [\"keyup\", eventAttrs],\n        ],\n        { skipVisibilityCheck: true }\n    );\n\n    return { keydownEvent, keyupEvent };\n}\n\nexport function mockDownload(cb) {\n    patchWithCleanup(download, { _download: cb });\n}\n\nexport const hushConsole = Object.create(null);\nfor (const propName of Object.keys(window.console)) {\n    hushConsole[propName] = () => {};\n}\n\nexport function mockSendBeacon(mock) {\n    patchWithCleanup(navigator, {\n        sendBeacon: (url, blob) => {\n            return mock(url, blob) !== false;\n        },\n    });\n}\n\nexport function mockTimeout() {\n    const timeouts = new Map();\n    let currentTime = 0;\n    let id = 1;\n    patchWithCleanup(browser, {\n        setTimeout(fn, delay = 0) {\n            timeouts.set(id, { fn, scheduledFor: delay + currentTime, id });\n            return id++;\n        },\n        clearTimeout(id) {\n            timeouts.delete(id);\n        },\n    });\n    return {\n        execRegisteredTimeouts() {\n            for (const { fn } of timeouts.values()) {\n                fn();\n            }\n            timeouts.clear();\n        },\n        async advanceTime(duration) {\n            // wait here so all microtasktick scheduled in this frame can be\n            // executed and possibly register their own timeout\n            await nextTick();\n            currentTime += duration;\n            for (const { fn, scheduledFor, id } of timeouts.values()) {\n                if (scheduledFor <= currentTime) {\n                    fn();\n                    timeouts.delete(id);\n                }\n            }\n            // wait here to make sure owl can update the UI\n            await nextTick();\n        },\n    };\n}\n\nexport function mockAnimationFrame() {\n    const callbacks = new Map();\n    let currentTime = 0;\n    let id = 1;\n    patchWithCleanup(browser, {\n        requestAnimationFrame(fn) {\n            callbacks.set(id, { fn, scheduledFor: 16 + currentTime, id });\n            return id++;\n        },\n        cancelAnimationFrame(id) {\n            callbacks.delete(id);\n        },\n        performance: { now: () => currentTime },\n    });\n    return {\n        execRegisteredAnimationFrames() {\n            for (const { fn } of callbacks.values()) {\n                fn(currentTime);\n            }\n            callbacks.clear();\n        },\n        async advanceFrame(count = 1) {\n            // wait here so all microtasktick scheduled in this frame can be\n            // executed and possibly register their own timeout\n            await nextTick();\n            currentTime += 16 * count;\n            for (const { fn, scheduledFor, id } of callbacks.values()) {\n                if (scheduledFor <= currentTime) {\n                    fn(currentTime);\n                    callbacks.delete(id);\n                }\n            }\n            // wait here to make sure owl can update the UI\n            await nextTick();\n        },\n    };\n}\n\nexport async function mount(Comp, target, config = {}) {\n    let { props, env } = config;\n    env = env || {};\n    const configuration = {\n        env,\n        getTemplate,\n        test: true,\n        props,\n        customDirectives,\n        globalValues,\n    };\n    if (env.services && \"localization\" in env.services) {\n        configuration.translateFn = _t;\n    }\n    const app = new App(Comp, configuration);\n    registerCleanup(() => app.destroy());\n    return app.mount(target);\n}\n\nexport function destroy(comp) {\n    comp.__owl__.app.destroy();\n}\n\nexport function findChildren(comp, predicate = (e) => e) {\n    const queue = [];\n    [].unshift.apply(queue, Object.values(comp.__owl__.children));\n\n    while (queue.length > 0) {\n        const curNode = queue.pop();\n        if (predicate(curNode)) {\n            return curNode;\n        }\n        [].unshift.apply(queue, Object.values(curNode.component.__owl__.children));\n    }\n}\n\n// partial replacement of t-ref on component\nexport function useChild() {\n    const node = useComponent().__owl__;\n    const setChild = () => {\n        const componentNode = Object.values(node.children)[0];\n        node.component.child = componentNode.component;\n    };\n    onMounted(setChild);\n    onPatched(setChild);\n}\n\nexport function useLogLifeCycle(logFn, name = \"\") {\n    const component = useComponent();\n    let loggedName = `${component.constructor.name}`;\n    if (name) {\n        loggedName = `${component.constructor.name} ${name}`;\n    }\n    onError(() => {\n        logFn(`onError ${loggedName}`);\n    });\n    onMounted(() => {\n        logFn(`onMounted ${loggedName}`);\n    });\n    onPatched(() => {\n        logFn(`onPatched ${loggedName}`);\n    });\n    onRendered(() => {\n        logFn(`onRendered ${loggedName}`);\n    });\n    onWillDestroy(() => {\n        logFn(`onWillDestroy ${loggedName}`);\n    });\n    onWillPatch(() => {\n        logFn(`onWillPatch ${loggedName}`);\n    });\n    onWillRender(() => {\n        logFn(`onWillRender ${loggedName}`);\n    });\n    onWillStart(() => {\n        logFn(`onWillStart ${loggedName}`);\n    });\n    onWillUnmount(() => {\n        logFn(`onWillUnmount ${loggedName}`);\n    });\n    onWillUpdateProps(() => {\n        logFn(`onWillUpdateProps ${loggedName}`);\n    });\n}\n\n/**\n * Returns the list of nodes containing n2 (included) that do not contain n1.\n *\n * @param {Node} n1\n * @param {Node} n2\n * @returns {Node[]}\n */\nfunction getDifferentParents(n1, n2) {\n    const parents = [n2];\n    while (parents[0].parentNode) {\n        const parent = parents[0].parentNode;\n        if (parent.contains(n1)) {\n            break;\n        }\n        parents.unshift(parent);\n    }\n    return parents;\n}\n\n/**\n * Helper performing a drag and drop sequence.\n *\n * - 'from' is used to determine the element on which the drag will start;\n * - 'target' will determine the element on which the first one will be dropped.\n *\n * The first element will be dragged by its center, and will be dropped on the\n * bottom-right inner pixel of the target element. This behavior covers both\n * cases of appending the first element to the end of a list (toSelector =\n * target list) or moving it at the position of another element, effectively\n * placing the first element before the second (toSelector = other element).\n *\n * A position can be given to drop the first element above, below, or on the\n * side of the second (default is inside, as specified above).\n *\n * Note that only the last event is awaited, since all the others are\n * considered to be synchronous.\n *\n * @param {Element | string} from\n * @param {Element | string} to\n * @param {Position} [position]\n */\nexport async function dragAndDrop(from, to, position) {\n    const { drop } = await drag(from);\n    await drop(to, position);\n}\n\n/**\n * Helper performing a drag.\n *\n * - the 'from' selector is used to determine the element on which the drag will\n *  start;\n * - the 'target' selector will determine the element on which the dragged element will be\n * moved.\n *\n * Returns a drop function\n *\n * @param {Element | string} from\n */\nexport async function drag(from, pointerType = \"mouse\") {\n    const assertIsDragging = (fn, endDrag) => {\n        return {\n            async [fn.name](...args) {\n                if (dragEndReason) {\n                    throw new Error(\n                        `Cannot execute drag helper '${fn.name}': drag sequence has been ended by '${dragEndReason}'.`\n                    );\n                }\n                await fn(...args);\n                if (endDrag) {\n                    dragEndReason = fn.name;\n                }\n            },\n        }[fn.name];\n    };\n\n    const cancel = assertIsDragging(async function cancel() {\n        await triggerEvent(window, null, \"keydown\", { key: \"Escape\" });\n    }, true);\n\n    /**\n     * @param {Element | string} [to]\n     * @param {Position} [position]\n     */\n    const drop = assertIsDragging(async function drop(to, position) {\n        if (to) {\n            await moveTo(to, position);\n        }\n        await triggerEvent(target || source, null, \"pointerup\", targetPosition);\n    }, true);\n\n    /**\n     * @param {Element | string} selector\n     */\n    const getEl = (selector) =>\n        selector instanceof Element ? selector : fixture.querySelector(selector);\n\n    /**\n     * @param {Position} [position]\n     */\n    const getTargetPosition = (position) => {\n        const tRect = target.getBoundingClientRect();\n        const tPos = {\n            clientX: Math.floor(tRect.x),\n            clientY: Math.floor(tRect.y),\n        };\n        if (position && typeof position === \"object\") {\n            // x and y coordinates start from the element's initial coordinates\n            tPos.clientX += position.x || 0;\n            tPos.clientY += position.y || 0;\n        } else {\n            const positions = typeof position === \"string\" ? position.split(\"-\") : [];\n\n            // X position\n            if (positions.includes(\"left\")) {\n                tPos.clientX -= 1;\n            } else if (positions.includes(\"right\")) {\n                tPos.clientX += Math.ceil(tRect.width) + 1;\n            } else {\n                tPos.clientX += Math.floor(tRect.width / 2);\n            }\n\n            // Y position\n            if (positions.includes(\"top\")) {\n                tPos.clientY -= 1;\n            } else if (positions.includes(\"bottom\")) {\n                tPos.clientY += Math.ceil(tRect.height) + 1;\n            } else {\n                tPos.clientY += Math.floor(tRect.height / 2);\n            }\n        }\n        return tPos;\n    };\n\n    /**\n     * @param {Element | string} [to]\n     * @param {Position} [position]\n     */\n    const moveTo = assertIsDragging(async function moveTo(to, position) {\n        target = getEl(to);\n        if (!target) {\n            return;\n        }\n\n        // Recompute target position\n        targetPosition = getTargetPosition(position);\n\n        // Move, enter and drop the element on the target\n        await triggerEvent(source, null, \"pointermove\", { ...targetPosition, button: -1 });\n\n        // \"pointerenter\" is fired on every parent of `target` that do not contain\n        // `from` (typically: different parent lists).\n        for (const parent of getDifferentParents(source, target)) {\n            triggerEvent(parent, null, \"pointerenter\", targetPosition);\n        }\n        await nextTick();\n\n        return dragHelpers;\n    }, false);\n\n    const dragHelpers = { cancel, drop, moveTo };\n    const fixture = getFixture();\n\n    const source = getEl(from instanceof Element ? from : fixture.querySelector(from));\n    const sourceRect = source.getBoundingClientRect();\n\n    let dragEndReason = null;\n    let target;\n    let targetPosition;\n\n    // Pointer down on main target\n    await triggerEvent(source, null, \"pointerdown\", {\n        pointerType,\n        clientX: sourceRect.x + sourceRect.width / 2,\n        clientY: sourceRect.y + sourceRect.height / 2,\n    });\n\n    return dragHelpers;\n}\n\n/**\n * Returns the dropdown menu for a specific toggler.\n *\n * @param {HTMLElement} target\n * @param {String|HTMLElement} togglerSelector\n * @returns {HTMLElement|undefined}\n */\nexport function getDropdownMenu(target, togglerSelector) {\n    if (!(target instanceof HTMLElement)) {\n        throw new Error(`getDropdownMenu: target is not an HTMLElement.`);\n    }\n    let el =\n        togglerSelector instanceof HTMLElement\n            ? togglerSelector\n            : target.querySelector(togglerSelector);\n\n    if (el && !el.classList.contains(\"o-dropdown\")) {\n        el = el.querySelector(\".o-dropdown\");\n    }\n    if (!el) {\n        throw new Error(`getDropdownMenu: Could not find element \"${togglerSelector}\".`);\n    }\n    return getPopoverForTarget(el);\n}\n\nexport async function clickDropdown(target, fieldName) {\n    const dropdownInput = target.querySelector(`[name='${fieldName}'] .dropdown input`);\n    dropdownInput.focus();\n    await nextTick();\n    await click(dropdownInput);\n}\n\nexport async function clickOpenedDropdownItem(target, fieldName, itemContent) {\n    const dropdowns = target.querySelectorAll(`[name='${fieldName}'] .dropdown .dropdown-menu`);\n    if (dropdowns.length === 0) {\n        throw new Error(`No dropdown found for field ${fieldName}`);\n    } else if (dropdowns.length > 1) {\n        throw new Error(`Found ${dropdowns.length} dropdowns for field ${fieldName}`);\n    }\n    const dropdownItems = dropdowns[0].querySelectorAll(\"li\");\n    const indexToClick = Array.from(dropdownItems)\n        .map((html) => html.textContent)\n        .indexOf(itemContent);\n    if (indexToClick === -1) {\n        throw new Error(`The element '${itemContent}' does not exist in the dropdown`);\n    }\n    await click(dropdownItems[indexToClick]);\n}\n\nexport async function selectDropdownItem(target, fieldName, itemContent) {\n    await clickDropdown(target, fieldName);\n    await clickOpenedDropdownItem(target, fieldName, itemContent);\n}\n\nexport function getNodesTextContent(nodes) {\n    return Array.from(nodes).map((n) => n.textContent);\n}\n\n/**\n * Click to open the dropdown on a many2one\n */\nexport async function clickOpenM2ODropdown(el, fieldName, selector) {\n    const m2oSelector = `${selector || \"\"} .o_field_many2one[name=${fieldName}] input`;\n    const matches = el.querySelectorAll(m2oSelector);\n    if (matches.length !== 1) {\n        throw new Error(\n            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`\n        );\n    }\n\n    await click(matches[0]);\n    return matches[0];\n}\n\n/**\n * Click on the active (highlighted) selection in a m2o dropdown.\n */\n// TO FIX\nexport async function clickM2OHighlightedItem(el, fieldName, selector) {\n    const m2oSelector = `${selector || \"\"} .o_field_many2one[name=${fieldName}] input`;\n    // const $dropdown = $(m2oSelector).autocomplete('widget');\n    const matches = el.querySelectorAll(m2oSelector);\n    if (matches.length !== 1) {\n        throw new Error(\n            `cannot open m2o: selector ${selector} has been found ${matches.length} instead of 1`\n        );\n    }\n    // clicking on an li (no matter which one), will select the focussed one\n    return click(matches[0].parentElement.querySelector(\"li\"));\n}\n\n// X2Many\nexport async function addRow(target, selector) {\n    await click(target.querySelector(`${selector ? selector : \"\"} .o_field_x2many_list_row_add a`));\n}\n\nexport async function removeRow(target, index) {\n    await click(target.querySelectorAll(\".o_list_record_remove\")[index]);\n}\n", "/** @odoo-module alias=@web/../tests/utils default=false */\n\nimport { isVisible } from \"@web/core/utils/ui\";\nimport { registerCleanup } from \"@web/../tests/helpers/cleanup\";\nimport {\n    click as webClick,\n    getFixture,\n    makeDeferred,\n    triggerEvents as webTriggerEvents,\n} from \"@web/../tests/helpers/utils\";\n\n/**\n * Create a fake object 'dataTransfer', linked to some files,\n * which is passed to drag and drop events.\n *\n * @param {Object[]} files\n * @returns {Object}\n */\nfunction createFakeDataTransfer(files) {\n    return {\n        dropEffect: \"all\",\n        effectAllowed: \"all\",\n        files,\n        items: [],\n        types: [\"Files\"],\n    };\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then clicks on it.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options] forwarded to `contains`\n * @param {boolean} [options.shiftKey]\n */\nexport async function click(selector, options = {}) {\n    const { shiftKey } = options;\n    delete options.shiftKey;\n    await contains(selector, { click: { shiftKey }, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then dragenters `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dragenterFiles(selector, files, options) {\n    await contains(selector, { dragenterFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then dragovers `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dragoverFiles(selector, files, options) {\n    await contains(selector, { dragoverFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then drops `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function dropFiles(selector, files, options) {\n    await contains(selector, { dropFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then inputs `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function inputFiles(selector, files, options) {\n    await contains(selector, { inputFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then pastes `files` on it.\n *\n * @param {string} selector\n * @param {Object[]} files\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function pasteFiles(selector, files, options) {\n    await contains(selector, { pasteFiles: files, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then focuses on it.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function focus(selector, options) {\n    await contains(selector, { setFocus: true, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then inserts the given `content`.\n *\n * @param {string} selector\n * @param {string} content\n * @param {ContainsOptions} [options] forwarded to `contains`\n * @param {boolean} [options.replace=false]\n */\nexport async function insertText(selector, content, options = {}) {\n    const { replace = false } = options;\n    delete options.replace;\n    await contains(selector, { ...options, insertText: { content, replace } });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then sets its `scrollTop` to the given value.\n *\n * @param {string} selector\n * @param {number|\"bottom\"} scrollTop\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function scroll(selector, scrollTop, options) {\n    await contains(selector, { setScroll: scrollTop, ...options });\n}\n\n/**\n * Waits until exactly one element matching the given `selector` is present in\n * `options.target` and then triggers `event` on it.\n *\n * @param {string} selector\n * @param {(import(\"@web/../tests/helpers/utils\").EventType|[import(\"@web/../tests/helpers/utils\").EventType, EventInit])[]} events\n * @param {ContainsOptions} [options] forwarded to `contains`\n */\nexport async function triggerEvents(selector, events, options) {\n    await contains(selector, { triggerEvents: events, ...options });\n}\n\nfunction log(ok, message) {\n    if (window.QUnit) {\n        QUnit.assert.ok(ok, message);\n    } else {\n        if (ok) {\n            console.log(message);\n        } else {\n            console.error(message);\n        }\n    }\n}\n\nlet hasUsedContainsPositively = false;\nif (window.QUnit) {\n    QUnit.testStart(() => (hasUsedContainsPositively = false));\n}\n/**\n * @typedef {[string, ContainsOptions]} ContainsTuple tuple representing params of the contains\n *  function, where the first element is the selector, and the second element is the options param.\n * @typedef {Object} ContainsOptions\n * @property {ContainsTuple} [after] if provided, the found element(s) must be after the element\n *  matched by this param.\n * @property {ContainsTuple} [before] if provided, the found element(s) must be before the element\n *  matched by this param.\n * @property {Object} [click] if provided, clicks on the first found element\n * @property {ContainsTuple|ContainsTuple[]} [contains] if provided, the found element(s) must\n *  contain the provided sub-elements.\n * @property {number} [count=1] numbers of elements to be found to declare the contains check\n *  as successful. Elements are counted after applying all other filters.\n * @property {Object[]} [dragenterFiles] if provided, dragenters the given files on the found element\n * @property {Object[]} [dragoverFiles] if provided, dragovers the given files on the found element\n * @property {Object[]} [dropFiles] if provided, drops the given files on the found element\n * @property {Object[]} [inputFiles] if provided, inputs the given files on the found element\n * @property {{content:string, replace:boolean}} [insertText] if provided, adds to (or replace) the\n *  value of the first found element by the given content.\n * @property {ContainsTuple} [parent] if provided, the found element(s) must have as\n *  parent the node matching the parent parameter.\n * @property {Object[]} [pasteFiles] if provided, pastes the given files on the found element\n * @property {number|\"bottom\"} [scroll] if provided, the scrollTop of the found element(s)\n *  must match.\n *  Note: when using one of the scrollTop options, it is advised to ensure the height is not going\n *  to change soon, by checking with a preceding contains that all the expected elements are in DOM.\n * @property {boolean} [setFocus] if provided, focuses the first found element.\n * @property {boolean} [shadowRoot] if provided, targets the shadowRoot of the found elements.\n * @property {number|\"bottom\"} [setScroll] if provided, sets the scrollTop on the first found\n *  element.\n * @property {HTMLElement} [target=getFixture()]\n * @property {string[]} [triggerEvents] if provided, triggers the given events on the found element\n * @property {string} [text] if provided, the textContent of the found element(s) or one of their\n *  descendants must match. Use `textContent` option for a match on the found element(s) only.\n * @property {string} [textContent] if provided, the textContent of the found element(s) must match.\n *  Prefer `text` option for a match on the found element(s) or any of their descendants, usually\n *  allowing for a simpler and less specific selector.\n * @property {string} [value] if provided, the input value of the found element(s) must match.\n *  Note: value changes are not observed directly, another mutation must happen to catch them.\n * @property {boolean} [visible] if provided, the found element(s) must be (in)visible\n */\nclass Contains {\n    /**\n     * @param {string} selector\n     * @param {ContainsOptions} [options={}]\n     */\n    constructor(selector, options = {}) {\n        this.selector = selector;\n        this.options = options;\n        this.options.count ??= 1;\n        this.options.targetParam = this.options.target;\n        this.options.target ??= getFixture();\n        let selectorMessage = `${this.options.count} of \"${this.selector}\"`;\n        if (this.options.visible !== undefined) {\n            selectorMessage = `${selectorMessage} ${\n                this.options.visible ? \"visible\" : \"invisible\"\n            }`;\n        }\n        if (this.options.targetParam) {\n            selectorMessage = `${selectorMessage} inside a specific target`;\n        }\n        if (this.options.parent) {\n            selectorMessage = `${selectorMessage} inside a specific parent`;\n        }\n        if (this.options.contains) {\n            selectorMessage = `${selectorMessage} with a specified sub-contains`;\n        }\n        if (this.options.text !== undefined) {\n            selectorMessage = `${selectorMessage} with text \"${this.options.text}\"`;\n        }\n        if (this.options.textContent !== undefined) {\n            selectorMessage = `${selectorMessage} with textContent \"${this.options.textContent}\"`;\n        }\n        if (this.options.value !== undefined) {\n            selectorMessage = `${selectorMessage} with value \"${this.options.value}\"`;\n        }\n        if (this.options.scroll !== undefined) {\n            selectorMessage = `${selectorMessage} with scroll \"${this.options.scroll}\"`;\n        }\n        if (this.options.after !== undefined) {\n            selectorMessage = `${selectorMessage} after a specified element`;\n        }\n        if (this.options.before !== undefined) {\n            selectorMessage = `${selectorMessage} before a specified element`;\n        }\n        this.selectorMessage = selectorMessage;\n        if (this.options.contains && !Array.isArray(this.options.contains[0])) {\n            this.options.contains = [this.options.contains];\n        }\n        if (this.options.count) {\n            hasUsedContainsPositively = true;\n        } else if (!hasUsedContainsPositively) {\n            throw new Error(\n                `Starting a test with \"contains\" of count 0 for selector \"${this.selector}\" is useless because it might immediately resolve. Start the test by checking that an expected element actually exists.`\n            );\n        }\n        /** @type {string} */\n        this.successMessage = undefined;\n        /** @type {function} */\n        this.executeError = undefined;\n    }\n\n    /**\n     * Starts this contains check, either immediately resolving if there is a\n     * match, or registering appropriate listeners and waiting until there is a\n     * match or a timeout (resolving or rejecting respectively).\n     *\n     * Success or failure messages will be logged with QUnit as well.\n     *\n     * @returns {Promise}\n     */\n    run() {\n        this.done = false;\n        this.def = makeDeferred();\n        this.scrollListeners = new Set();\n        this.onScroll = () => this.runOnce(\"after scroll\");\n        if (!this.runOnce(\"immediately\")) {\n            this.timer = setTimeout(\n                () => this.runOnce(\"Timeout of 5 seconds\", { crashOnFail: true }),\n                5000\n            );\n            this.observer = new MutationObserver((mutations) => {\n                try {\n                    this.runOnce(\"after mutations\");\n                } catch (e) {\n                    this.def.reject(e); // prevents infinite loop in case of programming error\n                }\n            });\n            this.observer.observe(this.options.target, {\n                attributes: true,\n                childList: true,\n                subtree: true,\n            });\n            registerCleanup(() => {\n                if (!this.done) {\n                    this.runOnce(\"Test ended\", { crashOnFail: true });\n                }\n            });\n        }\n        return this.def;\n    }\n\n    /**\n     * Runs this contains check once, immediately returning the result (or\n     * undefined), and possibly resolving or rejecting the main promise\n     * (and printing QUnit log) depending on options.\n     * If undefined is returned it means the check was not successful.\n     *\n     * @param {string} whenMessage\n     * @param {Object} [options={}]\n     * @param {boolean} [options.crashOnFail=false]\n     * @param {boolean} [options.executeOnSuccess=true]\n     * @returns {HTMLElement[]|undefined}\n     */\n    runOnce(whenMessage, { crashOnFail = false, executeOnSuccess = true } = {}) {\n        const res = this.select();\n        if (res?.length === this.options.count || crashOnFail) {\n            // clean before doing anything else to avoid infinite loop due to side effects\n            this.observer?.disconnect();\n            clearTimeout(this.timer);\n            for (const el of this.scrollListeners ?? []) {\n                el.removeEventListener(\"scroll\", this.onScroll);\n            }\n            this.done = true;\n        }\n        if (res?.length === this.options.count) {\n            this.successMessage = `Found ${this.selectorMessage} (${whenMessage})`;\n            if (executeOnSuccess) {\n                this.executeAction(res[0]);\n            }\n            return res;\n        } else {\n            this.executeError = () => {\n                let message = `Failed to find ${this.selectorMessage} (${whenMessage}).`;\n                message = res\n                    ? `${message} Found ${res.length} instead.`\n                    : `${message} Parent not found.`;\n                if (this.parentContains) {\n                    if (this.parentContains.successMessage) {\n                        log(true, this.parentContains.successMessage);\n                    } else {\n                        this.parentContains.executeError();\n                    }\n                }\n                log(false, message);\n                this.def?.reject(new Error(message));\n                for (const childContains of this.childrenContains || []) {\n                    if (childContains.successMessage) {\n                        log(true, childContains.successMessage);\n                    } else {\n                        childContains.executeError();\n                    }\n                }\n            };\n            if (crashOnFail) {\n                this.executeError();\n            }\n        }\n    }\n\n    /**\n     * Executes the action(s) given to this constructor on the found element,\n     * prints the success messages, and resolves the main deferred.\n\n     * @param {HTMLElement} el\n     */\n    executeAction(el) {\n        let message = this.successMessage;\n        if (this.options.click) {\n            message = `${message} and clicked it`;\n            webClick(el, undefined, {\n                mouseEventInit: this.options.click,\n                skipDisabledCheck: true,\n                skipVisibilityCheck: true,\n            });\n        }\n        if (this.options.dragenterFiles) {\n            message = `${message} and dragentered ${this.options.dragenterFiles.length} file(s)`;\n            const ev = new Event(\"dragenter\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dragenterFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.dragoverFiles) {\n            message = `${message} and dragovered ${this.options.dragoverFiles.length} file(s)`;\n            const ev = new Event(\"dragover\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dragoverFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.dropFiles) {\n            message = `${message} and dropped ${this.options.dropFiles.length} file(s)`;\n            const ev = new Event(\"drop\", { bubbles: true });\n            Object.defineProperty(ev, \"dataTransfer\", {\n                value: createFakeDataTransfer(this.options.dropFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.inputFiles) {\n            message = `${message} and inputted ${this.options.inputFiles.length} file(s)`;\n            // could not use _createFakeDataTransfer as el.files assignation will only\n            // work with a real FileList object.\n            const dataTransfer = new window.DataTransfer();\n            for (const file of this.options.inputFiles) {\n                dataTransfer.items.add(file);\n            }\n            el.files = dataTransfer.files;\n            /**\n             * Changing files programatically is not supposed to trigger the event but\n             * it does in Chrome versions before 73 (which is on runbot), so in that\n             * case there is no need to make a manual dispatch, because it would lead to\n             * the files being added twice.\n             */\n            const versionRaw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./);\n            const chromeVersion = versionRaw ? parseInt(versionRaw[2], 10) : false;\n            if (!chromeVersion || chromeVersion >= 73) {\n                el.dispatchEvent(new Event(\"change\"));\n            }\n        }\n        if (this.options.insertText !== undefined) {\n            message = `${message} and inserted text \"${this.options.insertText.content}\" (replace: ${this.options.insertText.replace})`;\n            el.focus();\n            if (this.options.insertText.replace) {\n                el.value = \"\";\n                el.dispatchEvent(new window.KeyboardEvent(\"keydown\", { key: \"Backspace\" }));\n                el.dispatchEvent(new window.KeyboardEvent(\"keyup\", { key: \"Backspace\" }));\n                el.dispatchEvent(new window.InputEvent(\"input\"));\n            }\n            for (const char of this.options.insertText.content) {\n                el.value += char;\n                el.dispatchEvent(new window.KeyboardEvent(\"keydown\", { key: char }));\n                el.dispatchEvent(new window.KeyboardEvent(\"keyup\", { key: char }));\n                el.dispatchEvent(new window.InputEvent(\"input\"));\n            }\n            el.dispatchEvent(new window.InputEvent(\"change\"));\n        }\n        if (this.options.pasteFiles) {\n            message = `${message} and pasted ${this.options.pasteFiles.length} file(s)`;\n            const ev = new Event(\"paste\", { bubbles: true });\n            Object.defineProperty(ev, \"clipboardData\", {\n                value: createFakeDataTransfer(this.options.pasteFiles),\n            });\n            el.dispatchEvent(ev);\n        }\n        if (this.options.setFocus) {\n            message = `${message} and focused it`;\n            el.focus();\n        }\n        if (this.options.setScroll !== undefined) {\n            message = `${message} and set scroll to \"${this.options.setScroll}\"`;\n            el.scrollTop =\n                this.options.setScroll === \"bottom\" ? el.scrollHeight : this.options.setScroll;\n        }\n        if (this.options.triggerEvents) {\n            message = `${message} and triggered \"${this.options.triggerEvents.join(\", \")}\" events`;\n            webTriggerEvents(el, null, this.options.triggerEvents, {\n                skipVisibilityCheck: true,\n            });\n        }\n        if (this.parentContains) {\n            log(true, this.parentContains.successMessage);\n        }\n        log(true, message);\n        for (const childContains of this.childrenContains) {\n            log(true, childContains.successMessage);\n        }\n        this.def?.resolve();\n    }\n\n    /**\n     * Returns the found element(s) according to this constructor setup.\n     * If undefined is returned it means the parent cannot be found\n     *\n     * @returns {HTMLElement[]|undefined}\n     */\n    select() {\n        const target = this.selectParent();\n        if (!target) {\n            return;\n        }\n        const baseRes = [...target.querySelectorAll(this.selector)]\n            .map((el) => (this.options.shadowRoot ? el.shadowRoot : el))\n            .filter((el) => el);\n        /** @type {Contains[]} */\n        this.childrenContains = [];\n        const res = baseRes.filter((el, currentIndex) => {\n            let condition =\n                (this.options.textContent === undefined ||\n                    el.textContent.trim() === this.options.textContent) &&\n                (this.options.value === undefined || el.value === this.options.value) &&\n                (this.options.scroll === undefined ||\n                    (this.options.scroll === \"bottom\"\n                        ? Math.abs(el.scrollHeight - el.clientHeight - el.scrollTop) <= 1\n                        : Math.abs(el.scrollTop - this.options.scroll) <= 1));\n            if (condition && this.options.text !== undefined) {\n                if (\n                    el.textContent.trim() !== this.options.text &&\n                    [...el.querySelectorAll(\"*\")].every(\n                        (el) => el.textContent.trim() !== this.options.text\n                    )\n                ) {\n                    condition = false;\n                }\n            }\n            if (condition && this.options.contains) {\n                for (const param of this.options.contains) {\n                    const childContains = new Contains(param[0], { ...param[1], target: el });\n                    if (\n                        !childContains.runOnce(`as child of el ${currentIndex + 1})`, {\n                            executeOnSuccess: false,\n                        })\n                    ) {\n                        condition = false;\n                    }\n                    this.childrenContains.push(childContains);\n                }\n            }\n            if (condition && this.options.visible !== undefined) {\n                if (isVisible(el) !== this.options.visible) {\n                    condition = false;\n                }\n            }\n            if (condition && this.options.after) {\n                const afterContains = new Contains(this.options.after[0], {\n                    ...this.options.after[1],\n                    target,\n                });\n                const afterEl = afterContains.runOnce(`as \"after\"`, {\n                    executeOnSuccess: false,\n                })?.[0];\n                if (\n                    !afterEl ||\n                    !(el.compareDocumentPosition(afterEl) & Node.DOCUMENT_POSITION_PRECEDING)\n                ) {\n                    condition = false;\n                }\n                this.childrenContains.push(afterContains);\n            }\n            if (condition && this.options.before) {\n                const beforeContains = new Contains(this.options.before[0], {\n                    ...this.options.before[1],\n                    target,\n                });\n                const beforeEl = beforeContains.runOnce(`as \"before\"`, {\n                    executeOnSuccess: false,\n                })?.[0];\n                if (\n                    !beforeEl ||\n                    !(el.compareDocumentPosition(beforeEl) & Node.DOCUMENT_POSITION_FOLLOWING)\n                ) {\n                    condition = false;\n                }\n                this.childrenContains.push(beforeContains);\n            }\n            return condition;\n        });\n        if (\n            this.options.scroll !== undefined &&\n            this.scrollListeners &&\n            baseRes.length === this.options.count &&\n            res.length !== this.options.count\n        ) {\n            for (const el of baseRes) {\n                if (!this.scrollListeners.has(el)) {\n                    this.scrollListeners.add(el);\n                    el.addEventListener(\"scroll\", this.onScroll);\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Returns the found element that should act as the target (parent) for the\n     * main selector.\n     * If undefined is returned it means the parent cannot be found.\n     *\n     * @returns {HTMLElement|undefined}\n     */\n    selectParent() {\n        if (this.options.parent) {\n            this.parentContains = new Contains(this.options.parent[0], {\n                ...this.options.parent[1],\n                target: this.options.target,\n            });\n            return this.parentContains.runOnce(`as parent`, { executeOnSuccess: false })?.[0];\n        }\n        return this.options.target;\n    }\n}\n\n/**\n * Waits until `count` elements matching the given `selector` are present in\n * `options.target`.\n *\n * @param {string} selector\n * @param {ContainsOptions} [options]\n * @returns {Promise}\n */\nexport async function contains(selector, options) {\n    await new Contains(selector, options).run();\n}\n\nconst stepState = {\n    expectedSteps: null,\n    deferred: null,\n    timeout: null,\n    currentSteps: [],\n\n    clear() {\n        clearTimeout(this.timeout);\n        this.timeout = null;\n        this.deferred = null;\n        this.currentSteps = [];\n        this.expectedSteps = null;\n    },\n\n    check({ crashOnFail = false } = {}) {\n        const success =\n            this.expectedSteps.length === this.currentSteps.length &&\n            this.expectedSteps.every((s, i) => s === this.currentSteps[i]);\n        if (!success && !crashOnFail) {\n            return;\n        }\n        QUnit.config.current.assert.verifySteps(this.expectedSteps);\n        if (success) {\n            this.deferred.resolve();\n        } else {\n            this.deferred.reject(new Error(\"Steps do not match.\"));\n        }\n        this.clear();\n    },\n};\n\nif (window.QUnit) {\n    QUnit.testStart(() =>\n        registerCleanup(() => {\n            if (stepState.expectedSteps) {\n                stepState.check({ crashOnFail: true });\n            } else {\n                stepState.clear();\n            }\n        })\n    );\n}\n\n/**\n * Indicate the completion of a test step. This step must then be verified by\n * calling `assertSteps`.\n *\n * @param {string} step\n */\nexport function step(step) {\n    stepState.currentSteps.push(step);\n    QUnit.config.current.assert.step(step);\n    if (stepState.expectedSteps) {\n        stepState.check();\n    }\n}\n\n/**\n * Wait for the given steps to be executed or for the timeout to be reached.\n *\n * @param {string[]} steps\n */\nexport function assertSteps(steps) {\n    if (stepState.expectedSteps) {\n        stepState.check({ crashOnFail: true });\n    }\n    stepState.expectedSteps = steps;\n    stepState.deferred = makeDeferred();\n    stepState.timeout = setTimeout(() => stepState.check({ crashOnFail: true }), 2000);\n    stepState.check();\n    return stepState.deferred;\n}\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"test_favorite_management\", {\n    url: \"/odoo/apps\",\n    steps: () => [\n        {\n            trigger:\n                \".o_kanban_renderer:not(:has(.o_kanban_record:contains(France - Localizations)))\",\n        },\n        {\n            trigger: \".o_facet_remove\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_renderer:has(.o_kanban_record:contains(France - Localizations))\",\n        },\n        {\n            trigger: \".o_searchview_dropdown_toggler\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_favorite_menu .o_accordion > .o_menu_item\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_favorite_menu .o_accordion_values .o_input\",\n            run: \"edit Apps1\",\n        },\n        {\n            trigger: \".o_save_favorite\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_searchview_facet .o_facet_value:contains(Apps1)\",\n        },\n        {\n            trigger: \".o_group_by_menu > .o-dropdown-item:contains(Category)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_header:contains(Account Charts)\",\n        },\n        {\n            trigger: \".o_favorite_menu .o_accordion_values .o_input\",\n            run: \"edit Apps2\",\n        },\n        {\n            trigger: \".o_save_favorite\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_favorite_menu .o-dropdown-item:contains(Apps2)\",\n        },\n        {\n            trigger: \".o_favorite_menu .o-dropdown-item:contains(Apps1) i:not(:visible)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_field_domain > div > div\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_tree_editor_row:contains(New Rule) > a\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_form_button_save\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_back_button > a\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_facet_values:contains('Apps2')\",\n        },\n        {\n            trigger: \".o_kanban_header:contains(Account Charts)\",\n        },\n        {\n            trigger: \".o_searchview_dropdown_toggler\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_favorite_menu .o-dropdown-item:contains(Apps1)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_record:not(.o_kanban_ghost):only\",\n        },\n        {\n            trigger: \".o_favorite_menu .o-dropdown-item:contains(Apps1) i:not(:visible)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_form_view .o_cp_action_menus .o-dropdown\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_popover > .o-dropdown-item:contains(Delete)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_technical_modal button:contains(Delete)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_searchview_dropdown_toggler\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_favorite_menu .o-dropdown-item:contains(Apps2)\",\n        },\n        {\n            content: \"There should not be any facet inside the search bar\",\n            trigger: \"body:not(:has(.o_searchview_facet))\",\n        },\n        {\n            content: \"The Apps1 filter should be deleted\",\n            trigger: \"body:not(:has(.o_favorite_menu .o-dropdown-item:contains(Apps1)))\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"test_user_group_settings\", {\n    url: \"/odoo/settings?debug=assets,tests\",\n    steps: () => [\n        // create new privileges\n        {\n            trigger: 'button[data-menu-xmlid=\"base.menu_users\"]',\n            content: \"open user menu\",\n            run: \"click\",\n        },\n        {\n            trigger: 'a[data-menu-xmlid=\"base.menu_action_res_groups_privilege\"]',\n            content: \"open privilege menu\",\n            run: \"click\",\n        },\n        {\n            trigger: 'th.o_group_name:contains(\"Master Data\")',\n        },\n        {\n            trigger: \"button.o_list_button_add\",\n            content: \"click on new button\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_field_char[name=\"name\"] input',\n            content: \"insert a privilege name\",\n            run: \"edit Privi Foo\",\n        },\n        {\n            trigger: \".o_field_x2many_list_row_add a\",\n            content: \"add groups (open modal)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_create_button\",\n            content: \"create the first group\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_field_char[name=\"name\"] input[placeholder=\"Group Name\"]',\n            content: \"insert the first group name\",\n            run: \"edit Bar User\",\n        },\n        {\n            trigger: \"footer .o_form_button_save_new\",\n            content: \"create the second group\",\n            run: \"click\",\n        },\n        {\n            trigger: \"body .o_notebook_content:contains(bar user)\",\n        },\n        {\n            trigger: '.o_field_char[name=\"name\"] input[placeholder=\"Group Name\"]',\n            content: \"insert the second group name\",\n            run: \"edit Bar Manager\",\n        },\n        {\n            trigger: 'a[name=\"inherit_groups\"]',\n            content: \"get implied groups\",\n            run: \"click\",\n        },\n        {\n            trigger: 'div[name=\"implied_ids\"] .o_field_x2many_list_row_add a',\n            content: \"switch to implied\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_searchview_input\",\n            content: \"search 'Bar' groups\",\n            run: \"edit Bar\",\n        },\n        {\n            trigger: \".o_searchview_autocomplete .o-dropdown-item.focus\",\n            content: \"Validate search\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_data_cell:contains(\"Bar User\"):last',\n            content: \"click to implied group 'Bar User'\",\n            run: \"click\",\n        },\n        {\n            trigger: \"footer .o_form_button_save\",\n            content: \"save group and close modal\",\n            run: \"click\",\n        },\n        {\n            trigger:\n                \"body:not(:has(.modal:visible)) .o_notebook_content:contains(bar user):contains(bar manager)\",\n        },\n        // and the new manager group to the demo user\n        {\n            trigger: 'button[data-menu-xmlid=\"base.menu_users\"]',\n            content: \"open user menu\",\n            run: \"click\",\n        },\n        {\n            trigger: 'a[data-menu-xmlid=\"base.menu_action_res_users\"]',\n            content: \"open users & companies menu\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_list_renderer:contains(marc demo):contains(mitchell admin)\",\n        },\n        {\n            trigger: '.o_data_row:contains(Marc Demo) .o_field_cell[name=\"name\"]',\n            content: \"open users menu\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_last_breadcrumb_item:contains(\"Marc Demo\")',\n            content: \"check if is demo user\",\n        },\n        {\n            trigger:\n                '.o_field_widget[name=\"group_ids\"] .o_cell:has(label:contains(\"Privi Foo\")) + .o_cell .o_select_menu input',\n            content: \"Add 'Bar Manager' access to demo user\",\n            run: `click`,\n        },\n        {\n            trigger: `.o-dropdown--menu .o_select_menu_item:contains(\"Bar Manager\")`,\n            run: \"click\",\n        },\n        // open group information button (popover)\n        {\n            trigger:\n                '.o_field_widget[name=\"group_ids\"] .o_cell:has(label:contains(\"Privi Foo\")) + .o_cell .o_group_info_button',\n            content: \"open group information for the new group\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_popover:contains(\"Privi Foo\") a:contains(\"Bar Manager\")',\n            content: \"open the group from the info button\",\n            run: \"click\",\n        },\n        // check if demo user has this group\n        {\n            trigger: '.o_last_breadcrumb_item:contains(\"Bar Manager\")',\n            content: \"check if is Bar Manager group\",\n        },\n        {\n            trigger: '.o_field_many2many[name=\"user_ids\"] .o_data_cell:contains(\"Marc Demo\")',\n            content: \"check if demo user has this group\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { WORKER_STATE } from \"@bus/workers/websocket_worker\";\nimport { whenReady } from \"@odoo/owl\";\n\nfunction logout() {\n    return [\n        {\n            trigger: \".o_web_client .o_navbar\",\n            async run() {\n                await whenReady();\n                await new Promise((resolve) => requestAnimationFrame(resolve));\n                await new Promise((resolve) => {\n                    const bus = odoo.__WOWL_DEBUG__.root.env.services.bus_service;\n                    bus.addEventListener(\"BUS:CONNECT\", resolve, { once: true });\n                    if (bus.workerState === WORKER_STATE.CONNECTED) {\n                        resolve();\n                    }\n                });\n            },\n        },\n        {\n            content: \"check we're logged in\",\n            trigger: \".o_user_menu .dropdown-toggle\",\n            run: \"click\",\n        },\n        {\n            content: \"click the Log out button\",\n            trigger: \".dropdown-item[data-menu=logout]\",\n            run: \"click\",\n            expectUnloadPage: true,\n        },\n        {\n            // Wait and check we are logged out\n            // o_database_list is used in the case website is not installed and only portal is.\n            trigger: \".oe_website_login_container, .o_database_list\",\n        },\n    ];\n}\n\nregistry.category(\"web_tour.tours\").add(\"test_user_switch\", {\n    url: \"/odoo\",\n    steps: () => [\n        ...logout(),\n        {\n            content: \"check if the login input is empty\",\n            trigger: \"input#login:empty\",\n        },\n        {\n            content: \"check if the password input is empty\",\n            trigger: \"input#password:empty\",\n        },\n        {\n            content: \"Should contains the user switch button\",\n            trigger: \".oe_login_form .o_user_switch_btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on Marc Demo on the quick login page\",\n            trigger:\n                \".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')\",\n            run: \"click\",\n        },\n        {\n            content: \"Check user choice button to back on the quick login page\",\n            trigger: \".oe_login_form .o_user_switch_btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Display the login form\",\n            trigger: \".o_user_switch .fa-user-circle-o\",\n            run: \"click\",\n        },\n        {\n            content: \"fill the login\",\n            trigger: \"input#login\",\n            run: \"edit admin\",\n        },\n        {\n            content: \"fill the password\",\n            trigger: \"input#password\",\n            run: \"edit admin\",\n        },\n        {\n            content: \"click on login button\",\n            trigger: 'button:contains(\"Log in\")',\n            run: \"click\",\n            expectUnloadPage: true,\n        },\n        ...logout(),\n        {\n            content: \"Check if there is Mitchell Admin in user list selection\",\n            trigger: \".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')\",\n        },\n        {\n            content: \"Check if there is Marc Demo in user list selection\",\n            trigger: \".o_user_switch .list-group-item:nth-child(2):contains('Marc Demo')\",\n        },\n        {\n            content: \"Choice demo\",\n            trigger: \".o_user_switch .list-group-item:contains('Marc Demo')\",\n            run: \"click\",\n        },\n        {\n            content: \"check the login for demo\",\n            trigger: \"input#login:value('demo')\",\n        },\n        {\n            content: \"fill the password\",\n            trigger: \"input#password\",\n            run: \"edit demo\",\n        },\n        {\n            content: \"Check back button to back on the quick login page\",\n            trigger: \".oe_login_form .o_user_switch_btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Check have 2 users\",\n            trigger: \".o_user_switch .list-group-item:nth-child(2)\",\n        },\n        {\n            content: \"Click on Mitchell Admin\",\n            trigger: \".o_user_switch .list-group-item:nth-child(1):contains('Mitchell Admin')\",\n            run: \"click\",\n        },\n        {\n            content: \"check the login for admin\",\n            trigger: \"input#login:value('admin')\",\n        },\n        {\n            content: \"fill the password\",\n            trigger: \"input#password\",\n            run: \"edit admin\",\n        },\n        {\n            content: \"Check back button to back on the quick login page\",\n            trigger: \".oe_login_form .o_user_switch_btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Display the login form\",\n            trigger: \".o_user_switch .fa-user-circle-o\",\n            run: \"click\",\n        },\n        {\n            content: \"the login form is display\",\n            trigger: \"form.oe_login_form:not(.d-none)\",\n        },\n        {\n            content: \"check if the login input is empty\",\n            trigger: \"input#login:empty\",\n        },\n        {\n            content: \"check if the password input is empty\",\n            trigger: \"input#password:empty\",\n        },\n        {\n            content: \"Back to user switch\",\n            trigger: \".oe_login_form .o_user_switch_btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Remove the admin user from page\",\n            trigger: \".o_user_switch .d-flex:first-child .fa-times\",\n            run: \"click\",\n        },\n        {\n            content: \"only one user is left on quick login\",\n            trigger:\n                \".o_user_switch:not(:has(.list-group-item:nth-child(2))) .list-group-item:contains('Marc Demo')\",\n        },\n    ],\n});\n", "export class TourHelpers {\n    constructor(anchor) {\n        this.anchor = anchor;\n        this.delay = 20;\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                const value = Reflect.get(target, prop, receiver);\n                if (typeof value === \"function\" && prop !== \"constructor\") {\n                    return value.bind(target);\n                }\n                return value;\n            },\n        });\n    }\n}\n", "/** @odoo-module */\n\nimport { getTag, isFirefox, isInstanceOf, isIterable, parseRegExp } from \"../hoot_dom_utils\";\nimport { waitUntil } from \"./time\";\n\n/**\n * @typedef {number | [number, number] | {\n *  w?: number;\n *  h?: number;\n *  width?: number;\n *  height?: number;\n * }} Dimensions\n *\n * @typedef {{\n *  root?: Target;\n *  tabbable?: boolean;\n * }} FocusableOptions\n *\n * @typedef {{\n *  keepInlineTextNodes?: boolean;\n *  tabSize?: number;\n *  type?: \"html\" | \"xml\";\n * }} FormatXmlOptions\n *\n * @typedef {{\n *  inline: boolean;\n *  level: number;\n *  value: MarkupLayerValue;\n * }} MarkupLayer\n *\n * @typedef {{\n *  close?: string;\n *  open?: string;\n *  textContent?: string;\n * }} MarkupLayerValue\n *\n * @typedef {(node: Node, index: number, nodes: Node[]) => boolean | Node} NodeFilter\n *\n * @typedef {(node: Node, selector: string) => Node[]} NodeGetter\n *\n * @typedef {string | string[] | number | boolean | File[]} NodeValue\n *\n * @typedef {number | [number, number] | {\n *  x?: number;\n *  y?: number;\n *  left?: number;\n *  top?: number,\n *  clientX?: number;\n *  clientY?: number;\n *  pageX?: number;\n *  pageY?: number;\n *  screenX?: number;\n *  screenY?: number;\n * }} Position\n *\n * @typedef {(content: string) => QueryFilter} PseudoClassPredicateBuilder\n *\n * @typedef {string | number | NodeFilter} QueryFilter\n *\n * @typedef {{\n *  contains?: string;\n *  count?: number;\n *  displayed?: boolean;\n *  empty?: boolean;\n *  eq?: number;\n *  first?: boolean;\n *  focusable?: boolean;\n *  has?: boolean;\n *  hidden?: boolean;\n *  iframe?: boolean;\n *  interactive?: boolean;\n *  last?: boolean;\n *  not?: boolean;\n *  only?: boolean;\n *  root?: HTMLElement;\n *  scrollable?: ScrollAxis;\n *  selected?: boolean;\n *  shadow?: boolean;\n *  value?: boolean;\n *  viewPort?: boolean;\n *  visible?: boolean;\n * }} QueryOptions\n *\n * @typedef {{\n *  trimPadding?: boolean;\n * }} QueryRectOptions\n *\n * @typedef {{\n *  inline?: boolean;\n *  raw?: boolean;\n * }} QueryTextOptions\n *\n * @typedef {\"both\" | \"x\" | \"y\"} ScrollAxis\n *\n * @typedef {import(\"./time\").WaitOptions} WaitOptions\n */\n\n/**\n * @template T\n * @typedef {T | Iterable<T>} MaybeIterable\n */\n\n/**\n * @template [T=Node]\n * @typedef {MaybeIterable<T> | string | null | undefined | false} Target\n */\n\n//-----------------------------------------------------------------------------\n// Global\n//-----------------------------------------------------------------------------\n\nconst {\n    document,\n    DOMParser,\n    Error,\n    innerWidth,\n    innerHeight,\n    Map,\n    MutationObserver,\n    Number: { isInteger: $isInteger, isNaN: $isNaN, parseInt: $parseInt, parseFloat: $parseFloat },\n    Object: { entries: $entries, keys: $keys, values: $values },\n    RegExp,\n    Set,\n    String: { raw: $raw },\n    window,\n} = globalThis;\n\n//-----------------------------------------------------------------------------\n// Internal\n//-----------------------------------------------------------------------------\n\n/**\n * @param {Iterable<QueryFilter>} filters\n * @param {Node[]} nodes\n */\nfunction applyFilters(filters, nodes) {\n    for (const filter of filters) {\n        const filteredGroupNodes = [];\n        for (let i = 0; i < nodes.length; i++) {\n            const result = matchFilter(filter, nodes, i);\n            if (result === true) {\n                filteredGroupNodes.push(nodes[i]);\n            } else if (result) {\n                filteredGroupNodes.push(result);\n            }\n        }\n        nodes = filteredGroupNodes;\n        if (globalFilterDescriptors.has(filter)) {\n            globalFilterDescriptors.get(filter).push(nodes.length);\n        } else if (selectorFilterDescriptors.has(filter)) {\n            selectorFilterDescriptors.get(filter).push(nodes.length);\n        }\n    }\n    return nodes;\n}\n\nfunction compilePseudoClassRegex() {\n    const customKeys = [...customPseudoClasses.keys()].filter((k) => k !== \"has\" && k !== \"not\");\n    return new RegExp(`:(${customKeys.join(\"|\")})`);\n}\n\n/**\n * @param {Element[]} elements\n * @param {string} selector\n */\nfunction elementsMatch(elements, selector) {\n    if (!elements.length) {\n        return false;\n    }\n    return parseSelector(selector).some((selectorParts) => {\n        const [baseSelector, ...filters] = selectorParts.at(-1);\n        for (let i = 0; i < elements.length; i++) {\n            if (baseSelector && !elements[i].matches(baseSelector)) {\n                return false;\n            }\n            if (!filters.every((filter) => matchFilter(filter, elements, i))) {\n                return false;\n            }\n        }\n        return true;\n    });\n}\n\n/**\n * @param {QueryOptions} options\n */\nfunction ensureCount(options) {\n    options = { ...options };\n    if (!(\"eq\" in options || \"first\" in options || \"last\" in options)) {\n        options.first = true;\n    }\n    return options;\n}\n\n/**\n * @param {Node} node\n * @returns {Element | null}\n */\nfunction ensureElement(node) {\n    if (node) {\n        if (isDocument(node)) {\n            return node.documentElement;\n        }\n        if (isWindow(node)) {\n            return node.document.documentElement;\n        }\n        if (isElement(node)) {\n            return node;\n        }\n    }\n    return null;\n}\n\n/**\n * @param {Iterable<Node>} nodes\n * @param {number} level\n * @param {boolean} [keepInlineTextNodes]\n */\nfunction extractLayers(nodes, level, keepInlineTextNodes) {\n    /** @type {MarkupLayer[]} */\n    const layers = [];\n    for (const node of nodes) {\n        if (node.nodeType === Node.COMMENT_NODE) {\n            continue;\n        }\n        if (node.nodeType === Node.TEXT_NODE) {\n            const textContent = node.nodeValue.replaceAll(/\\n/g, \"\");\n            const trimmedTextContent = textContent.trim();\n            if (trimmedTextContent) {\n                const inline = textContent === trimmedTextContent;\n                layers.push({ inline, level, value: { textContent: trimmedTextContent } });\n            }\n            continue;\n        }\n        const [open, close] = node.outerHTML.replace(`>${node.innerHTML}<`, \">\\n<\").split(\"\\n\");\n        const layer = { inline: false, level, value: { open, close } };\n        layers.push(layer);\n        const childLayers = extractLayers(node.childNodes, level + 1, false);\n        if (keepInlineTextNodes && childLayers.length === 1 && childLayers[0].inline) {\n            layer.value.textContent = childLayers[0].value.textContent;\n        } else {\n            layers.push(...childLayers);\n        }\n    }\n    return layers;\n}\n\n/**\n * @param {Iterable<Node>} nodesToFilter\n */\nfunction filterUniqueNodes(nodesToFilter) {\n    /** @type {Node[]} */\n    const nodes = [];\n    for (const node of nodesToFilter) {\n        if (isQueryableNode(node) && !nodes.includes(node)) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n\n/**\n * @param {MarkupLayer[]} layers\n * @param {number} tabSize\n */\nfunction generateStringFromLayers(layers, tabSize) {\n    const result = [];\n    let layerIndex = 0;\n    while (layers.length > 0) {\n        const layer = layers[layerIndex];\n        const { level, value } = layer;\n        const pad = \" \".repeat(tabSize * level);\n        let nextLayerIndex = layerIndex + 1;\n        if (value.open) {\n            if (value.textContent) {\n                // node with inline textContent (no wrapping white-spaces)\n                result.push(`${pad}${value.open}${value.textContent}${value.close}`);\n                layers.splice(layerIndex, 1);\n                nextLayerIndex--;\n            } else {\n                result.push(`${pad}${value.open}`);\n                delete value.open;\n            }\n        } else {\n            if (value.close) {\n                result.push(`${pad}${value.close}`);\n            } else if (value.textContent) {\n                result.push(`${pad}${value.textContent}`);\n            }\n            layers.splice(layerIndex, 1);\n            nextLayerIndex--;\n        }\n        if (nextLayerIndex >= layers.length) {\n            layerIndex = nextLayerIndex - 1;\n            continue;\n        }\n        const nextLayer = layers[nextLayerIndex];\n        if (nextLayerIndex === 0 || nextLayer.level > layers[nextLayerIndex - 1].level) {\n            layerIndex = nextLayerIndex;\n        } else {\n            layerIndex = nextLayerIndex - 1;\n        }\n    }\n    return result.join(\"\\n\");\n}\n\n/**\n * @param {[string, string, number][]} modifierInfo\n */\nfunction getFiltersDescription(modifierInfo) {\n    const description = [];\n    for (const [modifier, content, count = 0] of modifierInfo) {\n        const makeLabel = MODIFIER_SUFFIX_LABELS[modifier];\n        const elements = plural(\"element\", count);\n        if (typeof makeLabel === \"function\") {\n            description.push(`${count} ${elements} ${makeLabel(content)}`);\n        } else {\n            description.push(`${count} ${modifier} ${elements}`);\n        }\n        if (!count) {\n            // Stop at first null count to avoid situations like:\n            // \"found 0 elements, including 0 visible elements, including 0 ...\"\n            break;\n        }\n    }\n    return description;\n}\n\n/**\n * @param {Node} node\n */\nfunction getInlineNodeText(node) {\n    return getNodeText(node, { inline: true });\n}\n\n/**\n * @param {Node} node\n * @returns {NodeValue}\n */\nfunction getNodeContent(node) {\n    switch (getTag(node)) {\n        case \"input\":\n        case \"option\":\n        case \"textarea\":\n            return getNodeValue(node);\n        case \"select\":\n            return [...node.selectedOptions].map(getNodeValue).join(\",\");\n    }\n    return getNodeText(node);\n}\n\n/** @type {NodeFilter} */\nfunction getNodeIframe(node) {\n    // Note: should only apply on `iframe` elements\n    /** @see parseSelector */\n    const doc = node.contentDocument;\n    return doc && doc.readyState !== \"loading\" ? doc : false;\n}\n\n/** @type {NodeFilter} */\nfunction getNodeShadowRoot(node) {\n    return node.shadowRoot;\n}\n\n/**\n * @param {string} pseudoClass\n */\nfunction getQueryFilter(pseudoClass, content) {\n    const makeQueryFilter = customPseudoClasses.get(pseudoClass);\n    try {\n        return makeQueryFilter(content);\n    } catch (err) {\n        let message = `error while parsing pseudo-class ':${pseudoClass}'`;\n        const cause = String(err?.message || err);\n        if (cause) {\n            message += `: ${cause}`;\n        }\n        throw new HootDomError(message);\n    }\n}\n\n/**\n * @param {string} string\n */\nfunction getStringContent(string) {\n    return string.match(R_QUOTE_CONTENT)?.[2] || string;\n}\n\nfunction getWaitForMessage() {\n    const message = `expected at least 1 element after %timeout%ms and ${lastQueryMessage}`;\n    lastQueryMessage = \"\";\n    return message;\n}\n\nfunction getWaitForNoneMessage() {\n    const message = `expected 0 elements after %timeout%ms and ${lastQueryMessage}`;\n    lastQueryMessage = \"\";\n    return message;\n}\n\n/**\n *\n * @param {number} count\n * @param {Parameters<NodeFilter>[0]} _node\n * @param {Parameters<NodeFilter>[1]} _i\n * @param {Parameters<NodeFilter>[2]} nodes\n */\nfunction hasNodeCount(count, _node, _i, nodes) {\n    return count === nodes.length;\n}\n\n/**\n * @param {string} [char]\n */\nfunction isChar(char) {\n    return !!char && R_CHAR.test(char);\n}\n\n/**\n * @template T\n * @param {T} object\n * @returns {T extends Document ? true : false}\n */\nfunction isDocument(object) {\n    return object?.nodeType === Node.DOCUMENT_NODE;\n}\n\n/**\n * @template T\n * @param {T} object\n * @returns {T extends Element ? true: false}\n */\nfunction isElement(object) {\n    return object?.nodeType === Node.ELEMENT_NODE;\n}\n\n/**\n * @param {string} selector\n * @param {Node} node\n */\nfunction isNodeHaving(selector, node) {\n    return !!_queryAll(selector, { root: node }).length;\n}\n\n/** @type {NodeFilter} */\nfunction isNodeHidden(node) {\n    return !isNodeVisible(node);\n}\n\n/** @type {NodeFilter} */\nfunction isNodeInteractive(node) {\n    return (\n        getStyle(node).pointerEvents !== \"none\" &&\n        !node.closest?.(\"[inert]\") &&\n        !getParentFrame(node)?.inert\n    );\n}\n\n/**\n * @param {string} selector\n * @param {Node} node\n */\nfunction isNodeNotMatching(selector, node) {\n    return !matches(node, selector);\n}\n\n/** @type {NodeFilter} */\nfunction isNodeSelected(node) {\n    return !!node.selected;\n}\n\n/** @type {NodeFilter} */\nfunction isOnlyNode(_node, _i, nodes) {\n    return nodes.length === 1;\n}\n\n/**\n * @param {Node} node\n */\nfunction isQueryableNode(node) {\n    return QUERYABLE_NODE_TYPES.includes(node.nodeType);\n}\n\n/**\n * @param {Element} [el]\n */\nfunction isRootElement(el) {\n    return el && R_ROOT_ELEMENT.test(el.nodeName || \"\");\n}\n\n/**\n * @param {Element} el\n */\nfunction isShadowRoot(el) {\n    return el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !!el.host;\n}\n\n/**\n * @template T\n * @param {T} object\n * @returns {T extends Window ? true : false}\n */\nfunction isWindow(object) {\n    return object?.window === object && object.constructor.name === \"Window\";\n}\n\n/**\n * @param {string} [char]\n */\nfunction isWhiteSpace(char) {\n    return !!char && R_HORIZONTAL_WHITESPACE.test(char);\n}\n\n/**\n * @param {(node: Node) => NodeValue} getContent\n * @param {boolean} exact\n */\nfunction makePseudoClassMatcher(getContent, exact) {\n    return function makePartialMatcher(content) {\n        const regex = parseRegExp(content);\n        if (isInstanceOf(regex, RegExp)) {\n            return function stringMatches(node) {\n                return regex.test(String(getContent(node)));\n            };\n        } else {\n            const lowerContent = content.toLowerCase();\n            if (exact) {\n                return function stringEquals(node) {\n                    return String(getContent(node)).toLowerCase() === lowerContent;\n                };\n            } else {\n                return function stringContains(node) {\n                    return String(getContent(node)).toLowerCase().includes(lowerContent);\n                };\n            }\n        }\n    };\n}\n\n/**\n *\n * @param {QueryFilter} filter\n * @param {Node[]} nodes\n * @param {number} index\n */\nfunction matchFilter(filter, nodes, index) {\n    if (typeof filter === \"number\") {\n        if (filter < 0) {\n            return filter + nodes.length === index;\n        } else {\n            return filter === index;\n        }\n    }\n    const node = nodes[index];\n    if (typeof filter === \"function\") {\n        return filter(node, index, nodes);\n    } else {\n        return !!node.matches?.(String(filter));\n    }\n}\n\n/**\n * flatMap implementation supporting NodeList iterables.\n *\n * @param {Iterable<Node>} nodes\n * @param {(node: Node) => Node | Iterable<Node> | null | undefined} flatMapFn\n */\nfunction nodeFlatMap(nodes, flatMapFn) {\n    /** @type {Node[]} */\n    const result = [];\n    for (const node of nodes) {\n        const nodeList = flatMapFn(node);\n        if (isNode(nodeList)) {\n            result.push(nodeList);\n        } else if (isIterable(nodeList)) {\n            result.push(...nodeList);\n        }\n    }\n    return result;\n}\n\n/**\n * @template T\n * @param {T} value\n * @param {(keyof T)[]} propsA\n * @param {(keyof T)[]} propsB\n * @returns {[number, number]}\n */\nfunction parseNumberTuple(value, propsA, propsB) {\n    let result = [];\n    if (value && typeof value === \"object\") {\n        if (isIterable(value)) {\n            [result[0], result[1]] = [...value];\n        } else {\n            for (const prop of propsA) {\n                result[0] ??= value[prop];\n            }\n            for (const prop of propsB) {\n                result[1] ??= value[prop];\n            }\n        }\n    } else {\n        result = [value, value];\n    }\n    return result.map($parseFloat);\n}\n\n/**\n * @template {any[]} T\n * @param {T} args\n * @returns {string | T}\n */\nfunction parseRawArgs(args) {\n    return args[0]?.raw ? [$raw(...args)] : args;\n}\n\n/**\n * Parses a given selector string into a list of selector groups.\n *\n * - the return value is a list of selector `group` objects (representing comma-separated\n *  selectors);\n * - a `group` is composed of one or more `part` objects (representing space-separated\n *  selector parts inside of a group);\n * - a `part` is composed of a base selector (string) and zero or more 'filters' (predicates).\n *\n * @param {string} selector\n */\nfunction parseSelector(selector) {\n    /**\n     * @param {string} selector\n     */\n    function addToSelector(selector) {\n        registerChar = false;\n        const index = currentPart.length - 1;\n        if (typeof currentPart[index] === \"string\") {\n            currentPart[index] += selector;\n        } else {\n            currentPart.push(selector);\n        }\n    }\n\n    /** @type {(string | ReturnType<PseudoClassPredicateBuilder>)[]} */\n    const firstPart = [\"\"];\n    const firstGroup = [firstPart];\n    const groups = [firstGroup];\n    const parens = [0, 0];\n\n    let currentGroup = groups.at(-1);\n    let currentPart = currentGroup.at(-1);\n    let currentPseudo = null;\n    let currentQuote = null;\n    let registerChar = true;\n\n    for (let i = 0; i < selector.length; i++) {\n        const char = selector[i];\n        registerChar = true;\n        switch (char) {\n            // Group separator (comma)\n            case \",\": {\n                if (!currentQuote && !currentPseudo) {\n                    groups.push([[\"\"]]);\n                    currentGroup = groups.at(-1);\n                    currentPart = currentGroup.at(-1);\n                    registerChar = false;\n                }\n                break;\n            }\n            // Part separator (white space)\n            case \" \":\n            case \"\\t\":\n            case \"\\n\":\n            case \"\\r\":\n            case \"\\f\":\n            case \"\\v\": {\n                if (!currentQuote && !currentPseudo) {\n                    if (currentPart[0] || currentPart.length > 1) {\n                        // Only push new part if the current one is not empty\n                        // (has at least 1 character OR 1 pseudo-class filter)\n                        currentGroup.push([\"\"]);\n                        currentPart = currentGroup.at(-1);\n                    }\n                    registerChar = false;\n                }\n                break;\n            }\n            // Quote delimiters\n            case `'`:\n            case `\"`: {\n                if (char === currentQuote) {\n                    currentQuote = null;\n                } else if (!currentQuote) {\n                    currentQuote = char;\n                }\n                break;\n            }\n            // Combinators\n            case \">\":\n            case \"+\":\n            case \"~\": {\n                if (!currentQuote && !currentPseudo) {\n                    while (isWhiteSpace(selector[i + 1])) {\n                        i++;\n                    }\n                    addToSelector(char);\n                }\n                break;\n            }\n            // Pseudo classes\n            case \":\": {\n                if (!currentQuote && !currentPseudo) {\n                    let pseudo = \"\";\n                    while (isChar(selector[i + 1])) {\n                        pseudo += selector[++i];\n                    }\n                    if (customPseudoClasses.has(pseudo)) {\n                        if (selector[i + 1] === \"(\") {\n                            parens[0]++;\n                            i++;\n                            registerChar = false;\n                        }\n                        currentPseudo = [pseudo, \"\"];\n                    } else {\n                        addToSelector(char + pseudo);\n                    }\n                }\n                break;\n            }\n            // Parentheses\n            case \"(\": {\n                if (!currentQuote) {\n                    parens[0]++;\n                }\n                break;\n            }\n            case \")\": {\n                if (!currentQuote) {\n                    parens[1]++;\n                }\n                break;\n            }\n        }\n\n        if (currentPseudo) {\n            if (parens[0] === parens[1]) {\n                const [pseudo, content] = currentPseudo;\n                if (pseudo === \"iframe\" && !currentPart[0].startsWith(\"iframe\")) {\n                    // Special case: to optimise the \":iframe\" pseudo class, we\n                    // always select actual `iframe` elements.\n                    // Note that this may create \"impossible\" tag names (like \"iframediv\")\n                    // but this pseudo won't work on non-iframe elements anyway.\n                    currentPart[0] = `iframe${currentPart[0]}`;\n                }\n                const filter = getQueryFilter(pseudo, getStringContent(content));\n                selectorFilterDescriptors.set(filter, [pseudo, content]);\n                currentPart.push(filter);\n                currentPseudo = null;\n            } else if (registerChar) {\n                currentPseudo[1] += selector[i];\n            }\n        } else if (registerChar) {\n            addToSelector(selector[i]);\n        }\n    }\n\n    return groups;\n}\n\n/**\n * @param {string} xmlString\n * @param {\"html\" | \"xml\"} type\n */\nfunction parseXml(xmlString, type) {\n    const wrapperTag = type === \"html\" ? \"body\" : \"templates\";\n    const doc = parser.parseFromString(\n        `<${wrapperTag}>${xmlString}</${wrapperTag}>`,\n        `text/${type}`\n    );\n    if (doc.getElementsByTagName(\"parsererror\").length) {\n        const trimmed = xmlString.length > 80 ? xmlString.slice(0, 80) + \"\u2026\" : xmlString;\n        throw new HootDomError(\n            `error while parsing ${trimmed}: ${getNodeText(\n                doc.getElementsByTagName(\"parsererror\")[0]\n            )}`\n        );\n    }\n    return doc.getElementsByTagName(wrapperTag)[0].childNodes;\n}\n\n/**\n * Converts a CSS pixel value to a number, removing the 'px' part.\n *\n * @param {string} val\n */\nfunction pixelValueToNumber(val) {\n    return $parseFloat(val.endsWith(\"px\") ? val.slice(0, -2) : val);\n}\n\n/**\n * @param {string} word\n * @param {number} count\n */\nfunction plural(word, count) {\n    return count === 1 ? word : `${word}s`;\n}\n\n/**\n * @param {Node[]} nodes (assumed not empty)\n * @param {string} selector\n */\nfunction queryWithCustomSelector(nodes, selector) {\n    const selectorGroups = parseSelector(selector);\n    const foundNodes = [];\n    for (const selectorParts of selectorGroups) {\n        let groupNodes = nodes;\n        for (const selectorPart of selectorParts) {\n            let baseSelector = selectorPart[0];\n            let nodeGetter;\n            switch (baseSelector[0]) {\n                case \"+\": {\n                    nodeGetter = NEXT_SIBLING;\n                    break;\n                }\n                case \">\": {\n                    nodeGetter = DIRECT_CHILDREN;\n                    break;\n                }\n                case \"~\": {\n                    nodeGetter = NEXT_SIBLINGS;\n                    break;\n                }\n            }\n\n            // Slices modifier (if any)\n            if (nodeGetter) {\n                baseSelector = baseSelector.slice(1);\n            }\n            nodeGetter ||= DESCENDANTS;\n\n            // Retrieve nodes from current group nodes\n            const currentGroupNodes = nodeFlatMap(groupNodes, (node) =>\n                nodeGetter(node, baseSelector)\n            );\n\n            // Filter/replace nodes based on custom pseudo-classes\n            groupNodes = applyFilters(selectorPart.slice(1), currentGroupNodes);\n        }\n\n        foundNodes.push(...groupNodes);\n    }\n\n    return filterUniqueNodes(foundNodes);\n}\n\n/**\n * Creates a query message if needed, with all the information available used to\n * gather the given nodes (base selector and count of nodes matching it, then each\n * modifier applied as a filter with each associated count).\n *\n * Returns the resulting message only if the final count of nodes doesn't match\n * the given expected count.\n *\n * @param {Node[]} filteredNodes\n * @param {number} [expectedCount]\n */\nfunction registerQueryMessage(filteredNodes, expectedCount) {\n    lastQueryMessage = \"\";\n    const filteredCount = filteredNodes.length;\n    const invalidCount = $isInteger(expectedCount) && filteredCount !== expectedCount;\n    if (shouldRegisterQueryMessage || invalidCount) {\n        const globalModifierInfo = [...globalFilterDescriptors.values()];\n\n        // First message part: final count\n        lastQueryMessage += `found ${filteredCount} ${plural(\"element\", filteredCount)}`;\n        if (invalidCount) {\n            lastQueryMessage += ` instead of ${expectedCount}`;\n        }\n\n        // Next message part: initial element count (with selector if string)\n        const rootModifierInfo = globalModifierInfo.shift();\n        const [, rootContent, initialCount = 0] = rootModifierInfo;\n        if (typeof rootContent === \"string\") {\n            lastQueryMessage += `: ${initialCount} matching ${JSON.stringify(rootContent)}`;\n            if (selectorFilterDescriptors.size) {\n                // Selector filters will only be available with a custom selector\n                const selectorModifierInfo = [...selectorFilterDescriptors.values()];\n                lastQueryMessage += ` (${getFiltersDescription(selectorModifierInfo).join(\" > \")})`;\n            }\n        } else if (filteredCount !== initialCount) {\n            // Do not report count if same as announced initially\n            lastQueryMessage += `: ${initialCount} ${plural(\"element\", initialCount)}`;\n        }\n        if (initialCount) {\n            // Next message parts: each count associated with each modifier\n            lastQueryMessage += getFiltersDescription(globalModifierInfo)\n                .map((part) => `, including ${part}`)\n                .join(\"\");\n        }\n    } else {\n        lastQueryMessage = \"\";\n    }\n    if (queryAllLevel <= 1) {\n        globalFilterDescriptors.clear();\n        selectorFilterDescriptors.clear();\n    }\n    return invalidCount ? lastQueryMessage : \"\";\n}\n\n/**\n * Wrapper around '_queryAll' calls to ensure global variables are properly cleaned\n * up on any thrown error.\n *\n * @param {Target} target\n * @param {QueryOptions} options\n */\nfunction _guardedQueryAll(target, options) {\n    try {\n        return _queryAll(target, options);\n    } catch (error) {\n        queryAllLevel = 0;\n        shouldRegisterQueryMessage = false;\n        globalFilterDescriptors.clear();\n        selectorFilterDescriptors.clear();\n        throw error;\n    }\n}\n\n/**\n * @param {Target} target\n * @param {QueryOptions} options\n */\nfunction _queryAll(target, options) {\n    queryAllLevel++;\n\n    const { count, root, ...modifiers } = options || {};\n    if (count !== null && count !== undefined && (!$isInteger(count) || count <= 0)) {\n        throw new HootDomError(`invalid 'count' option: should be a positive integer`);\n    }\n\n    /** @type {Node[]} */\n    let nodes = [];\n    let selector;\n\n    if (typeof target === \"string\") {\n        if (target) {\n            nodes = root ? _queryAll(root) : [getDefaultRoot()];\n        }\n        selector = target.trim();\n        // HTMLSelectElement is iterable \u00af\\_(\u30c4)_/\u00af\n    } else if (isIterable(target) && !isNode(target)) {\n        nodes = filterUniqueNodes(target);\n    } else if (target) {\n        nodes = filterUniqueNodes([target]);\n    }\n\n    globalFilterDescriptors.set(\"root\", [\"\", target]);\n    if (selector && nodes.length) {\n        if (rCustomPseudoClass.test(selector)) {\n            nodes = queryWithCustomSelector(nodes, selector);\n        } else {\n            nodes = filterUniqueNodes(nodeFlatMap(nodes, (node) => DESCENDANTS(node, selector)));\n        }\n    }\n    globalFilterDescriptors.get(\"root\").push(nodes.length);\n\n    if (modifiers.visible && modifiers.displayed) {\n        throw new HootDomError(\n            `cannot use more than one visibility modifier ('visible' implies 'displayed')`\n        );\n    }\n\n    // Apply option modifiers on matching nodes\n    const modifierFilters = [];\n    for (const [modifier, content] of $entries(modifiers)) {\n        if (content === false || !customPseudoClasses.has(modifier)) {\n            continue;\n        }\n        const filter = getQueryFilter(modifier, content);\n        modifierFilters.push(filter);\n        globalFilterDescriptors.set(filter, [modifier, content]);\n    }\n    const filteredNodes = applyFilters(modifierFilters, nodes);\n\n    // Register query message (if needed), and/or throw an error accordingly\n    const message = registerQueryMessage(filteredNodes, count);\n    if (message) {\n        throw new HootDomError(message);\n    }\n\n    queryAllLevel--;\n\n    return filteredNodes;\n}\n\n/**\n * @param {Target} target\n * @param {QueryOptions} options\n */\nfunction _queryOne(target, options) {\n    return _guardedQueryAll(target, { ...options, count: 1 })[0];\n}\n\n/**\n * @param {Target} target\n * @param {QueryOptions} options\n * @param {boolean} isLast\n */\nfunction _waitForFirst(target, options, isLast) {\n    shouldRegisterQueryMessage = isLast;\n    const result = _guardedQueryAll(target, options)[0];\n    shouldRegisterQueryMessage = false;\n    return result;\n}\n\n/**\n * @param {Target} target\n * @param {QueryOptions} options\n * @param {boolean} isLast\n */\nfunction _waitForNone(target, options, isLast) {\n    shouldRegisterQueryMessage = isLast;\n    const result = _guardedQueryAll(target, options).length === 0;\n    shouldRegisterQueryMessage = false;\n    return result;\n}\n\nclass HootDomError extends Error {\n    name = \"HootDomError\";\n}\n\n// Regexes\nconst R_CHAR = /[\\w-]/;\n/** \\s without \\n and \\v */\nconst R_HORIZONTAL_WHITESPACE =\n    /[\\r\\t\\f \\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]+/g;\nconst R_LINEBREAK = /\\s*\\n+\\s*/g;\nconst R_QUOTE_CONTENT = /^\\s*(['\"])?([^]*?)\\1\\s*$/;\nconst R_ROOT_ELEMENT = /^(HTML|HEAD|BODY)$/;\nconst R_SCROLLABLE_OVERFLOW = /\\bauto\\b|\\bscroll\\b/;\n\nconst MODIFIER_SUFFIX_LABELS = {\n    contains: (content) => `with text \"${content}\"`,\n    eq: (content) => `at index ${content}`,\n    has: (content) => `containing selector \"${content}\"`,\n    not: (content) => `not matching \"${content}\"`,\n    value: (content) => `with value \"${content}\"`,\n    viewPort: () => \"in viewport\",\n};\n\nconst QUERYABLE_NODE_TYPES = [Node.ELEMENT_NODE, Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE];\n\nconst parser = new DOMParser();\n\n// Node getters\n\n/** @type {NodeGetter} */\nfunction DIRECT_CHILDREN(node, selector) {\n    const children = [];\n    for (const childNode of node.childNodes) {\n        if (childNode.matches?.(selector)) {\n            children.push(childNode);\n        }\n    }\n    return children;\n}\n\n/** @type {NodeGetter} */\nfunction DESCENDANTS(node, selector) {\n    return node.querySelectorAll?.(selector || \"*\");\n}\n\n/** @type {NodeGetter} */\nfunction NEXT_SIBLING(node, selector) {\n    const sibling = node.nextElementSibling;\n    return sibling?.matches?.(selector) && sibling;\n}\n\n/** @type {NodeGetter} */\nfunction NEXT_SIBLINGS(node, selector) {\n    const siblings = [];\n    while ((node = node.nextElementSibling)) {\n        if (node.matches?.(selector)) {\n            siblings.push(node);\n        }\n    }\n    return siblings;\n}\n\n/** @type {Map<QueryFilter, [string, string | null, number]>} */\nconst globalFilterDescriptors = new Map();\n/** @type {Map<QueryFilter, [string, string | null, number]>} */\nconst selectorFilterDescriptors = new Map();\n/** @type {Map<HTMLElement, { callbacks: Set<MutationCallback>, observer: MutationObserver }>} */\nconst observers = new Map();\nconst currentDimensions = {\n    width: innerWidth,\n    height: innerHeight,\n};\nlet getDefaultRoot = () => document;\nlet lastQueryMessage = \"\";\nlet shouldRegisterQueryMessage = false;\nlet queryAllLevel = 0;\n\n//-----------------------------------------------------------------------------\n// Pseudo classes\n//-----------------------------------------------------------------------------\n\n/** @type {Map<string, PseudoClassPredicateBuilder>} */\nconst customPseudoClasses = new Map();\n\ncustomPseudoClasses\n    .set(\"contains\", makePseudoClassMatcher(getInlineNodeText, false))\n    .set(\"count\", (strCount) => {\n        const count = $parseInt(strCount);\n        if (!$isInteger(count) || count <= 0) {\n            throw new HootDomError(`expected count to be a positive integer (got \"${strCount}\")`);\n        }\n        return hasNodeCount.bind(null, count);\n    })\n    .set(\"displayed\", () => isNodeDisplayed)\n    .set(\"empty\", () => isEmpty)\n    .set(\"eq\", (strIndex) => {\n        const index = $parseInt(strIndex);\n        if (!$isInteger(index)) {\n            throw new HootDomError(`expected index to be an integer (got \"${strIndex}\")`);\n        }\n        return index;\n    })\n    .set(\"first\", () => 0)\n    .set(\"focusable\", () => isNodeFocusable)\n    .set(\"has\", (selector) => isNodeHaving.bind(null, selector))\n    .set(\"hidden\", () => isNodeHidden)\n    .set(\"iframe\", () => getNodeIframe)\n    .set(\"interactive\", () => isNodeInteractive)\n    .set(\"last\", () => -1)\n    .set(\"not\", (selector) => isNodeNotMatching.bind(null, selector))\n    .set(\"only\", () => isOnlyNode)\n    .set(\"scrollable\", (axis) => isNodeScrollable.bind(null, axis))\n    .set(\"selected\", () => isNodeSelected)\n    .set(\"shadow\", () => getNodeShadowRoot)\n    .set(\"text\", makePseudoClassMatcher(getInlineNodeText, true))\n    .set(\"value\", makePseudoClassMatcher(getNodeValue, false))\n    .set(\"viewPort\", () => isNodeInViewPort)\n    .set(\"visible\", () => isNodeVisible);\n\nconst rCustomPseudoClass = compilePseudoClassRegex();\n\n//-----------------------------------------------------------------------------\n// Internal exports (inside Hoot/Hoot-DOM)\n//-----------------------------------------------------------------------------\n\nexport function cleanupDOM() {\n    // Dimensions\n    currentDimensions.width = innerWidth;\n    currentDimensions.height = innerHeight;\n\n    // Observers\n    const remainingObservers = observers.size;\n    if (remainingObservers) {\n        for (const { observer } of observers.values()) {\n            observer.disconnect();\n        }\n        observers.clear();\n    }\n}\n\n/**\n * @param {Node | () => Node} node\n */\nexport function defineRootNode(node) {\n    if (typeof node === \"function\") {\n        getDefaultRoot = node;\n    } else if (node) {\n        getDefaultRoot = () => node;\n    } else {\n        getDefaultRoot = () => document;\n    }\n}\n\nexport function getCurrentDimensions() {\n    return currentDimensions;\n}\n\n/**\n * @param {Node} [node]\n * @returns {Document}\n */\nexport function getDocument(node) {\n    if (!node) {\n        return document;\n    }\n    return isDocument(node) ? node : node.ownerDocument || document;\n}\n\n/**\n * @param {Node} node\n * @param {string} attribute\n * @returns {string | null}\n */\nexport function getNodeAttribute(node, attribute) {\n    return node.getAttribute?.(attribute) ?? null;\n}\n\n/**\n * @param {Node} node\n * @returns {NodeValue}\n */\nexport function getNodeValue(node) {\n    switch (node.type) {\n        case \"checkbox\":\n        case \"radio\":\n            return node.checked;\n        case \"file\":\n            return [...node.files];\n        case \"number\":\n        case \"range\":\n            return node.valueAsNumber;\n        case \"date\":\n        case \"datetime-local\":\n        case \"month\":\n        case \"time\":\n        case \"week\":\n            return node.valueAsDate.toISOString();\n    }\n    return node.value;\n}\n\n/**\n * @param {Node} node\n * @param {QueryRectOptions} [options]\n */\nexport function getNodeRect(node, options) {\n    if (!isElement(node)) {\n        return new DOMRect();\n    }\n\n    /** @type {DOMRect} */\n    const rect = node.getBoundingClientRect();\n    const parentFrame = getParentFrame(node);\n    if (parentFrame) {\n        const parentRect = getNodeRect(parentFrame);\n        rect.x -= parentRect.x;\n        rect.y -= parentRect.y;\n    }\n\n    if (!options?.trimPadding) {\n        return rect;\n    }\n\n    const style = getStyle(node);\n    const { x, y, width, height } = rect;\n    const [pl, pr, pt, pb] = [\"left\", \"right\", \"top\", \"bottom\"].map((side) =>\n        pixelValueToNumber(style.getPropertyValue(`padding-${side}`))\n    );\n\n    return new DOMRect(x + pl, y + pt, width - (pl + pr), height - (pt + pb));\n}\n\n/**\n * @param {Node} node\n * @param {QueryTextOptions} [options]\n * @returns {string}\n */\nexport function getNodeText(node, options) {\n    let content;\n    if (typeof node.innerText === \"string\") {\n        content = node.innerText;\n    } else {\n        content = node.textContent;\n    }\n    if (!options?.raw) {\n        content = content.replace(R_HORIZONTAL_WHITESPACE, \" \").trim();\n    }\n    if (options?.inline) {\n        content = content.replace(R_LINEBREAK, \" \");\n    }\n    return content;\n}\n\n/**\n * @param {Node} node\n * @returns {Node | null}\n */\nexport function getInteractiveNode(node) {\n    let currentEl = ensureElement(node);\n    if (!currentEl) {\n        return null;\n    }\n    while (currentEl && !isNodeInteractive(currentEl)) {\n        currentEl = currentEl.parentElement;\n    }\n    return currentEl;\n}\n\n/**\n * @template {Node} T\n * @param {T} node\n * @returns {T extends Element ? CSSStyleDeclaration : null}\n */\nexport function getStyle(node) {\n    return isElement(node) ? getComputedStyle(node) : null;\n}\n\n/**\n * @param {Node} [node]\n * @returns {Window}\n */\nexport function getWindow(node) {\n    if (!node) {\n        return window;\n    }\n    return isWindow(node) ? node : getDocument(node).defaultView;\n}\n\n/**\n * @param {Node} node\n * @returns {boolean}\n */\nexport function isCheckable(node) {\n    switch (getTag(node)) {\n        case \"input\":\n            return node.type === \"checkbox\" || node.type === \"radio\";\n        case \"label\":\n            return isCheckable(node.control);\n        default:\n            return false;\n    }\n}\n\n/**\n * @param {unknown} value\n * @returns {boolean}\n */\nexport function isEmpty(value) {\n    if (!value) {\n        return true;\n    }\n    if (typeof value === \"object\") {\n        if (isNode(value)) {\n            return isEmpty(getNodeContent(value));\n        }\n        if (!isIterable(value)) {\n            value = $keys(value);\n        }\n        return [...value].length === 0;\n    }\n    return false;\n}\n\n/**\n * Returns whether the given object is an {@link EventTarget}.\n *\n * @template T\n * @param {T} object\n * @returns {T extends EventTarget ? true : false}\n * @example\n *  isEventTarget(window); // true\n * @example\n *  isEventTarget(new App()); // false\n */\nexport function isEventTarget(object) {\n    return object && typeof object.addEventListener === \"function\";\n}\n\n/**\n * Returns whether the given object is a {@link Node} object.\n * Note that it is independant from the {@link Node} class itself to support\n * cross-window checks.\n *\n * @template T\n * @param {T} object\n * @returns {T extends Node ? true : false}\n */\nexport function isNode(object) {\n    return object && typeof object.nodeType === \"number\" && typeof object.nodeName === \"string\";\n}\n\n/**\n * @param {Node} node\n */\nexport function isNodeCssVisible(node) {\n    const element = ensureElement(node);\n    if (element === getDefaultRoot() || isRootElement(element)) {\n        return true;\n    }\n    const style = getStyle(element);\n    if (style?.visibility === \"hidden\" || style?.opacity === \"0\") {\n        return false;\n    }\n    const parent = element.parentNode;\n    return !parent || isNodeCssVisible(isShadowRoot(parent) ? parent.host : parent);\n}\n\n/**\n * @param {Window | Node} node\n */\nexport function isNodeDisplayed(node) {\n    const element = ensureElement(node);\n    if (!isInDOM(element)) {\n        return false;\n    }\n    if (isRootElement(element) || element.offsetParent || element.closest(\"svg\")) {\n        return true;\n    }\n    // `position=fixed` elements in Chrome do not have an `offsetParent`\n    return !isFirefox() && getStyle(element)?.position === \"fixed\";\n}\n\n/**\n * @param {Node} node\n * @param {FocusableOptions} [options]\n */\nexport function isNodeFocusable(node, options) {\n    return (\n        isNodeDisplayed(node) &&\n        node.matches?.(FOCUSABLE_SELECTOR) &&\n        (!options?.tabbable || node.tabIndex >= 0)\n    );\n}\n\n/**\n * @param {Window | Node} node\n */\nexport function isNodeInViewPort(node) {\n    const element = ensureElement(node);\n    const { x, y } = getNodeRect(element);\n\n    return y > 0 && y < currentDimensions.height && x > 0 && x < currentDimensions.width;\n}\n\n/**\n * @param {ScrollAxis} axis\n * @param {Window | Node} node\n */\nexport function isNodeScrollable(axis, node) {\n    if (!isElement(node)) {\n        return false;\n    }\n    const isScrollableX = node.clientWidth < node.scrollWidth;\n    const isScrollableY = node.clientHeight < node.scrollHeight;\n    switch (axis) {\n        case \"both\": {\n            if (!isScrollableX || !isScrollableY) {\n                return false;\n            }\n            break;\n        }\n        case \"x\": {\n            if (!isScrollableX) {\n                return false;\n            }\n            break;\n        }\n        case \"y\": {\n            if (!isScrollableY) {\n                return false;\n            }\n            break;\n        }\n        default: {\n            // Check for any scrollable axis\n            if (!isScrollableX && !isScrollableY) {\n                return false;\n            }\n        }\n    }\n    const overflow = getStyle(node).getPropertyValue(\"overflow\");\n    if (R_SCROLLABLE_OVERFLOW.test(overflow)) {\n        return true;\n    }\n    return false;\n}\n\n/**\n * @param {Window | Node} node\n */\nexport function isNodeVisible(node) {\n    const element = ensureElement(node);\n\n    // Must be displayed and not hidden by CSS\n    if (!isNodeDisplayed(element) || !isNodeCssVisible(element)) {\n        return false;\n    }\n\n    let visible = false;\n\n    // Check size (width & height)\n    const { width, height } = getNodeRect(element);\n    visible = width > 0 && height > 0;\n\n    // Check content (if display=contents)\n    if (!visible && getStyle(element)?.display === \"contents\") {\n        for (const child of element.childNodes) {\n            if (isNodeVisible(child)) {\n                return true;\n            }\n        }\n    }\n\n    return visible;\n}\n\n/**\n * @param {Dimensions} dimensions\n * @returns {[number, number]}\n */\nexport function parseDimensions(dimensions) {\n    return parseNumberTuple(dimensions, [\"width\", \"w\"], [\"height\", \"h\"]);\n}\n\n/**\n * @param {Position} position\n * @returns {[number, number]}\n */\nexport function parsePosition(position) {\n    return parseNumberTuple(\n        position,\n        [\"x\", \"left\", \"clientX\", \"pageX\", \"screenX\"],\n        [\"y\", \"top\", \"clientY\", \"pageY\", \"screenY\"]\n    );\n}\n\n/**\n * @param {number} width\n * @param {number} height\n */\nexport function setDimensions(width, height) {\n    const defaultRoot = getDefaultRoot();\n    if (!$isNaN(width)) {\n        currentDimensions.width = width;\n        defaultRoot.style?.setProperty(\"width\", `${width}px`, \"important\");\n    }\n    if (!$isNaN(height)) {\n        currentDimensions.height = height;\n        defaultRoot.style?.setProperty(\"height\", `${height}px`, \"important\");\n    }\n}\n\n/**\n * @param {Node} node\n * @param {{ object?: boolean }} [options]\n * @returns {string | string[]}\n */\nexport function toSelector(node, options) {\n    const parts = {\n        tag: node.nodeName.toLowerCase(),\n    };\n    if (node.id) {\n        parts.id = `#${node.id}`;\n    }\n    if (node.classList?.length) {\n        parts.class = `.${[...node.classList].join(\".\")}`;\n    }\n    return options?.object ? parts : $values(parts).join(\"\");\n}\n\n// Following selector is based on this spec:\n// https://html.spec.whatwg.org/multipage/interaction.html#dom-tabindex\nexport const FOCUSABLE_SELECTOR = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button:enabled\",\n    \"details > summary:first-of-type\",\n    \"iframe\",\n    \"input:enabled\",\n    \"select:enabled\",\n    \"textarea:enabled\",\n    \"[tabindex]\",\n    \"[contenteditable=true]\",\n].join(\",\");\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Returns a standardized representation of the given `string` value as a human-readable\n * XML string template (or HTML if the `type` option is `\"html\"`).\n *\n * @param {string} value\n * @param {FormatXmlOptions} [options]\n * @returns {string}\n */\nexport function formatXml(value, options) {\n    const nodes = parseXml(value, options?.type || \"xml\");\n    const layers = extractLayers(nodes, 0, options?.keepInlineTextNodes ?? false);\n    return generateStringFromLayers(layers, options?.tabSize ?? 4);\n}\n\n/**\n * Returns the active element in the given document. Further checks are performed\n * in the following cases:\n * - the given node is an iframe (checks in its content document);\n * - the given node has a shadow root (checks in that shadow root document);\n * - the given node is the body of an iframe (checks in the parent document).\n *\n * @param {Node} [node]\n */\nexport function getActiveElement(node) {\n    const doc = getDocument(node);\n    const view = doc.defaultView;\n    const { activeElement } = doc;\n    const { contentDocument, shadowRoot } = activeElement;\n\n    if (contentDocument && contentDocument.activeElement !== contentDocument.body) {\n        // Active element is an \"iframe\" element (with an active element other than its own body):\n        if (contentDocument.activeElement === contentDocument.body) {\n            // Active element is the body of the iframe:\n            // -> returns that element\n            return contentDocument.activeElement;\n        } else {\n            // Active element is something else than the body:\n            // -> get the active element inside the iframe document\n            return getActiveElement(contentDocument);\n        }\n    }\n\n    if (shadowRoot) {\n        // Active element has a shadow root:\n        // -> get the active element inside its root\n        return shadowRoot.activeElement;\n    }\n\n    if (activeElement === doc.body && view !== view.parent) {\n        // Active element is the body of an iframe:\n        // -> get the active element of its parent frame (recursively)\n        return getActiveElement(view.parent.document);\n    }\n\n    return activeElement;\n}\n\n/**\n * Returns the list of focusable elements in the given parent, sorted by their `tabIndex`\n * property.\n *\n * @see {@link isFocusable} for more information\n * @param {FocusableOptions} [options]\n * @returns {Element[]}\n * @example\n *  getFocusableElements();\n */\nexport function getFocusableElements(options) {\n    const parent = _queryOne(options?.root || getDefaultRoot());\n    if (typeof parent.querySelectorAll !== \"function\") {\n        return [];\n    }\n    const byTabIndex = {};\n    for (const element of parent.querySelectorAll(FOCUSABLE_SELECTOR)) {\n        const { tabIndex } = element;\n        if ((options?.tabbable && tabIndex < 0) || !isNodeDisplayed(element)) {\n            continue;\n        }\n        if (!byTabIndex[tabIndex]) {\n            byTabIndex[tabIndex] = [];\n        }\n        byTabIndex[tabIndex].push(element);\n    }\n    const withTabIndexZero = byTabIndex[0] || [];\n    delete byTabIndex[0];\n    return [...$values(byTabIndex).flat(), ...withTabIndexZero];\n}\n\n/**\n * Returns the next focusable element after the current active element if it is\n * contained in the given parent.\n *\n * @see {@link getFocusableElements}\n * @param {FocusableOptions} [options]\n * @returns {Element | null}\n * @example\n *  getPreviousFocusableElement();\n */\nexport function getNextFocusableElement(options) {\n    const parent = _queryOne(options?.root || getDefaultRoot());\n    const focusableEls = getFocusableElements({ ...options, parent });\n    const index = focusableEls.indexOf(getActiveElement(parent));\n    return focusableEls[index + 1] || null;\n}\n\n/**\n * Returns the parent `<iframe>` of a given node (if any).\n *\n * @param {Node} node\n * @returns {HTMLIFrameElement | null}\n */\nexport function getParentFrame(node) {\n    const doc = getDocument(node);\n    if (!doc) {\n        return null;\n    }\n    const view = doc.defaultView;\n    if (view !== view.parent) {\n        for (const iframe of view.parent.document.getElementsByTagName(\"iframe\")) {\n            if (iframe.contentWindow === view) {\n                return iframe;\n            }\n        }\n    }\n    return null;\n}\n\n/**\n * Returns the previous focusable element before the current active element if it is\n * contained in the given parent.\n *\n * @see {@link getFocusableElements}\n * @param {FocusableOptions} [options]\n * @returns {Element | null}\n * @example\n *  getPreviousFocusableElement();\n */\nexport function getPreviousFocusableElement(options) {\n    const parent = _queryOne(options?.root || getDefaultRoot());\n    const focusableEls = getFocusableElements({ ...options, parent });\n    const index = focusableEls.indexOf(getActiveElement(parent));\n    return index < 0 ? focusableEls.at(-1) : focusableEls[index - 1] || null;\n}\n\n/**\n * Checks whether a target is displayed, meaning that it has an offset parent and\n * is contained in the current document.\n *\n * Note that it does not mean that the target is \"visible\" (it can still be hidden\n * by CSS properties such as `width`, `opacity`, `visiblity`, etc.).\n *\n * @param {Target} target\n * @returns {boolean}\n */\nexport function isDisplayed(target) {\n    return _guardedQueryAll(target, { displayed: true }).length > 0;\n}\n\n/**\n * Returns whether the given node is editable, meaning that it is an `\":enabled\"`\n * `<input>` or `<textarea>` {@link Element};\n *\n * Note: this does **NOT** support elements with `contenteditable=\"true\"`.\n *\n * @param {Node} node\n * @returns {boolean}\n * @example\n *  isEditable(document.querySelector(\"input\")); // true\n * @example\n *  isEditable(document.body); // false\n */\nexport function isEditable(node) {\n    return (\n        isElement(node) &&\n        !node.matches?.(\":disabled\") &&\n        [\"input\", \"textarea\"].includes(getTag(node))\n    );\n}\n\n/**\n * Returns whether an element is focusable. Focusable elements are either:\n * - `<a>` or `<area>` elements with an `href` attribute;\n * - *enabled* `<button>`, `<input>`, `<select>` and `<textarea>` elements;\n * - `<iframe>` elements;\n * - any element with its `contenteditable` attribute set to `\"true\"`.\n *\n * A focusable element must also not have a `tabIndex` property set to less than 0.\n *\n * @see {@link FOCUSABLE_SELECTOR}\n * @param {Target} target\n * @returns {boolean}\n */\nexport function isFocusable(target) {\n    return _guardedQueryAll(target, { focusable: true }).length > 0;\n}\n\n/**\n * Returns whether the given target is contained in the current root document.\n *\n * @param {Window | Node} target\n * @returns {boolean}\n * @example\n *  isInDOM(queryFirst(\"div\")); // true\n * @example\n *  isInDOM(document.createElement(\"div\")); // Not attached -> false\n */\nexport function isInDOM(target) {\n    return ensureElement(target)?.isConnected;\n}\n\n/**\n * Checks whether a target is *at least partially* visible in the current viewport.\n *\n * @param {Target} target\n * @returns {boolean}\n */\nexport function isInViewPort(target) {\n    return _guardedQueryAll(target, { viewPort: true }).length > 0;\n}\n\n/**\n * Returns whether an element is scrollable.\n *\n * @param {Target} target\n * @param {ScrollAxis} [axis]\n * @returns {boolean}\n */\nexport function isScrollable(target, axis) {\n    return _guardedQueryAll(target, { scrollable: axis }).length > 0;\n}\n\n/**\n * Checks whether a target is visible, meaning that it is \"displayed\" (see {@link isDisplayed}),\n * has a non-zero width and height, and is not hidden by \"opacity\" or \"visibility\"\n * CSS properties.\n *\n * Note that it does not account for:\n *  - the position of the target in the viewport (e.g. negative x/y coordinates)\n *  - the color of the target (e.g. transparent text with no background).\n *\n * @param {Target} target\n * @returns {boolean}\n */\nexport function isVisible(target) {\n    return _guardedQueryAll(target, { visible: true }).length > 0;\n}\n\n/**\n * Equivalent to the native `node.matches(selector)`, with a few differences:\n * - it can take any {@link Target} (strings, nodes and iterable of nodes);\n * - it supports custom pseudo-classes, such as \":contains\" or \":visible\".\n *\n * @param {Target} target\n * @param {string} selector\n * @returns {boolean}\n * @example\n *  matches(\"input[name=surname]\", \":value(John)\");\n * @example\n *  matches(buttonEl, \":contains(Submit)\");\n */\nexport function matches(target, selector) {\n    return elementsMatch(_guardedQueryAll(target), selector);\n}\n\n/**\n * Listens for DOM mutations on a given target.\n *\n * This helper has 2 main advantages over directly calling the native MutationObserver:\n * - it ensures a single observer is created for a given target, even if multiple\n *  callbacks are registered;\n * - it keeps track of these observers, which allows to check whether an observer\n *  is still running while it should not, and to disconnect all running observers\n *  at once.\n *\n * @param {HTMLElement} target\n * @param {MutationCallback} callback\n */\nexport function observe(target, callback) {\n    if (observers.has(target)) {\n        observers.get(target).callbacks.add(callback);\n    } else {\n        const callbacks = new Set([callback]);\n        const observer = new MutationObserver((mutations, observer) => {\n            for (const callback of callbacks) {\n                callback(mutations, observer);\n            }\n        });\n        observer.observe(target, {\n            attributes: true,\n            characterData: true,\n            childList: true,\n            subtree: true,\n        });\n        observers.set(target, { callbacks, observer });\n    }\n\n    return function disconnect() {\n        if (!observers.has(target)) {\n            return;\n        }\n        const { callbacks, observer } = observers.get(target);\n        callbacks.delete(callback);\n        if (!callbacks.size) {\n            observer.disconnect();\n            observers.delete(target);\n        }\n    };\n}\n\n/**\n * Returns a list of nodes matching the given {@link Target}.\n * This function can either be used as a **template literal tag** (only supports\n * string selector without options) or invoked the usual way.\n *\n * The target can be:\n * - a {@link Node} (or an iterable of nodes), or {@link Window} object;\n * - a {@link Document} object (which will be converted to its body);\n * - a string representing a *custom selector* (which will be queried in the `root` option);\n *\n * This function allows all string selectors supported by the native {@link Element.querySelector}\n * along with some additional custom pseudo-classes:\n *\n * - `:contains(text)`: matches nodes whose *text content* includes the given *text*.\n *      * The match is **partial** and **case-insensitive**;\n *      * Given *text* also supports regular expressions (e.g. `:contains(/^foo.+/)`).\n * - `:count`: return nodes if their count match the given *count*.\n *      If not matching, an error is thrown;\n * - `:displayed`: matches nodes that are \"displayed\" (see {@link isDisplayed});\n * - `:empty`: matches nodes that have an empty *content* (**value** or **inner text**);\n * - `:eq(n)`: matches the *nth* node (0-based index);\n * - `:first`: matches the first node matching the selector (regardless of its actual\n *  DOM siblings);\n * - `:focusable`: matches nodes that can be focused (see {@link isFocusable});\n * - `:hidden`: matches nodes that are **not** \"visible\" (see {@link isVisible});\n * - `:interactive`: matches nodes that are not affected by 'pointer-events: none'\n * - `:iframe`: matches nodes that are `<iframe>` elements, and returns their `body`\n *  if it is ready;\n * - `:last`: matches the last node matching the selector (regardless of its actual\n *  DOM siblings);\n * - `:selected`: matches nodes that are selected (e.g. `<option>` elements);\n * - `:shadow`: matches nodes that have shadow roots, and returns their shadow root;\n * - `:scrollable(axis)`: matches nodes that are scrollable (see {@link isScrollable});\n * - `:text(text)`: matches nodes whose *content* is strictly equal to the given *text*;\n *      * The match is **exact**, and **case-insensitive**;\n *      * Given *text* also supports regular expressions (e.g. `:text(/^foo.+/)`).\n * - `:value(value)`: matches nodes whose *value* is strictly equal to the given *value*;\n *      * The match is **partial**, and **case-insensitive**;\n *      * Given *value* also supports regular expressions (e.g. `:value(/^foo.+/)`).\n * - `:viewPort`: matches nodes that are contained in the current view port (see\n *  {@link isInViewPort});\n * - `:visible`: matches nodes that are \"visible\" (see {@link isVisible});\n *\n * An `options` object can be specified to filter[1] the results:\n * - `root`: the root node to query the selector in (defaults to the current fixture);\n * - any of the *custom pseudo-classes* can be given as an option, with the value\n *  being a boolean for standalone pseudo-classes (e.g. `{ empty: true }`), or a\n *  string for the others (e.g. `{ contains: \"text\" }`).\n *\n * [1] these filters (except for `count` and `root`) achieve the same result as\n *  using their homonym pseudo-classes on the final group of the given selector\n *  string (e.g. ```queryAll`ul > li:visible`;``` = ```queryAll(\"ul > li\", { visible: true })```).\n *\n * @param {Target} target\n * @param {QueryOptions} [options]\n * @returns {Element[]}\n * @example\n *  // regular selectors\n *  queryAll`window`; // -> []\n *  queryAll`input#name`; // -> [input]\n *  queryAll`div`; // -> [div, div, ...]\n *  queryAll`ul > li`; // -> [li, li, ...]\n * @example\n *  // custom selectors\n *  queryAll`div:visible:contains(Lorem ipsum)`; // -> [div, div, ...]\n *  queryAll`div:visible:contains(${/^L\\w+\\si.*m$/})`; // -> [div, div, ...]\n *  queryAll`:focusable`; // -> [a, button, input, ...]\n *  queryAll`.o_iframe:iframe p`; // -> [p, p, ...] (inside iframe)\n *  queryAll`#editor:shadow div`; // -> [div, div, ...] (inside shadow DOM)\n * @example\n *  // with options\n *  queryAll(`div:first`, { count: 1 }); // -> [div]\n *  queryAll(`div`, { root: queryOne`iframe` }); // -> [div, div, ...]\n *  // the next 2 queries will return the same results\n *  queryAll(`button:visible`); // -> [button, button, ...]\n *  queryAll(`button`, { visible: true }); // -> [button, button, ...]\n */\nexport function queryAll(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _guardedQueryAll(target, options);\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns a list of the\n * *attribute values* of the matching nodes.\n *\n * @param {Target} target\n * @param {string} attribute\n * @param {QueryOptions} [options]\n * @returns {string[]}\n */\nexport function queryAllAttributes(target, attribute, options) {\n    return _guardedQueryAll(target, options).map((node) => getNodeAttribute(node, attribute));\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns a list of the\n * *properties* of the matching nodes.\n *\n * @param {Target} target\n * @param {string} property\n * @param {QueryOptions} [options]\n * @returns {any[]}\n */\nexport function queryAllProperties(target, property, options) {\n    return _guardedQueryAll(target, options).map((node) => node[property]);\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns a list of the\n * {@link DOMRect} of the matching nodes.\n *\n * There are a few differences with the native {@link Element.getBoundingClientRect}:\n * - rects take their positions relative to the top window element (instead of their\n *  parent `<iframe>` if any);\n * - they can be trimmed to remove padding with the `trimPadding` option.\n *\n * @param {Target} target\n * @param {QueryOptions & QueryRectOptions} [options]\n * @returns {DOMRect[]}\n */\nexport function queryAllRects(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _guardedQueryAll(target, options).map(getNodeRect);\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns a list of the\n * *texts* of the matching nodes.\n *\n * @param {Target} target\n * @param {QueryOptions & QueryTextOptions} [options]\n * @returns {string[]}\n */\nexport function queryAllTexts(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _guardedQueryAll(target, options).map((node) => getNodeText(node, options));\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns a list of the\n * *values* of the matching nodes.\n *\n * @param {Target} target\n * @param {QueryOptions} [options]\n * @returns {NodeValue[]}\n */\nexport function queryAllValues(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _guardedQueryAll(target, options).map(getNodeValue);\n}\n\n/**\n * Performs a {@link queryOne} with the given arguments, with a default 'first'\n * option, to ensure that *at least* one element is returned.\n *\n * 'first' can be overridden by 'last' or 'eq' if needed.\n *\n * @param {Target} target\n * @param {QueryOptions} [options]\n * @returns {Node}\n */\nexport function queryAny(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _queryOne(target, ensureCount(options));\n}\n\n/**\n * Performs a {@link queryOne} with the given arguments and returns the value of\n * the given *attribute* of the matching node.\n *\n * @param {Target} target\n * @param {string} attribute\n * @param {QueryOptions} [options]\n * @returns {string | null}\n */\nexport function queryAttribute(target, attribute, options) {\n    return getNodeAttribute(_queryOne(target, options), attribute);\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments and returns the first result\n * or `null`.\n *\n * @param {Target} target\n * @param {QueryOptions} options\n * @returns {Element | null}\n */\nexport function queryFirst(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return _guardedQueryAll(target, options)[0] || null;\n}\n\n/**\n * Performs a {@link queryAll} with the given arguments, along with a forced `count: 1`\n * option to ensure only one node matches the given {@link Target}.\n *\n * The returned value is a single node instead of a list of nodes.\n *\n * @param {Target} target\n * @param {Omit<QueryOptions, \"count\">} [options]\n * @returns {Element}\n */\nexport function queryOne(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    if ($isInteger(options?.count)) {\n        throw new HootDomError(\n            `cannot call \\`queryOne\\` with 'count'=${options.count}: did you mean to use \\`queryAll\\`?`\n        );\n    }\n    return _queryOne(target, options);\n}\n\n/**\n * Performs a {@link queryOne} with the given arguments and returns the {@link DOMRect}\n * of the matching node.\n *\n * There are a few differences with the native {@link Element.getBoundingClientRect}:\n * - rects take their positions relative to the top window element (instead of their\n *  parent `<iframe>` if any);\n * - they can be trimmed to remove padding with the `trimPadding` option.\n *\n * @param {Target} target\n * @param {QueryOptions & QueryRectOptions} [options]\n * @returns {DOMRect}\n */\nexport function queryRect(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return getNodeRect(_queryOne(target, options), options);\n}\n\n/**\n * Performs a {@link queryOne} with the given arguments and returns the *text* of\n * the matching node.\n *\n * @param {Target} target\n * @param {QueryOptions & QueryTextOptions} [options]\n * @returns {string}\n */\nexport function queryText(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return getNodeText(_queryOne(target, options), options);\n}\n\n/**\n * Performs a {@link queryOne} with the given arguments and returns the *value* of\n * the matching node.\n *\n * @param {Target} target\n * @param {QueryOptions} [options]\n * @returns {NodeValue}\n */\nexport function queryValue(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return getNodeValue(_queryOne(target, options));\n}\n\n/**\n * Combination of {@link queryAll} and {@link waitUntil}: waits for a given target\n * to match elements in the DOM and returns the first matching node when it appears\n * (or immediately if it is already present).\n *\n * @see {@link queryAll}\n * @see {@link waitUntil}\n * @param {Target} target\n * @param {QueryOptions & WaitOptions} [options]\n * @returns {Promise<Element>}\n * @example\n *  const button = await waitFor(`button`);\n *  button.click();\n */\nexport function waitFor(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return waitUntil(_waitForFirst.bind(null, target, options), {\n        message: getWaitForMessage,\n        ...options,\n    });\n}\n\n/**\n * Opposite of {@link waitFor}: waits for a given target to disappear from the DOM\n * (resolves instantly if the selector is already missing).\n *\n * @see {@link waitFor}\n * @param {Target} target\n * @param {QueryOptions & WaitOptions} [options]\n * @returns {Promise<number>}\n * @example\n *  await waitForNone(`button`);\n */\nexport function waitForNone(target, options) {\n    [target, options] = parseRawArgs(arguments);\n    return waitUntil(_waitForNone.bind(null, target, options), {\n        message: getWaitForNoneMessage,\n        ...options,\n    });\n}\n", "/** @odoo-module */\n\nimport { getColorHex, getTag, isFirefox, isInstanceOf, isIterable } from \"../hoot_dom_utils\";\nimport {\n    getActiveElement,\n    getDocument,\n    getInteractiveNode,\n    getNextFocusableElement,\n    getNodeRect,\n    getNodeValue,\n    getParentFrame,\n    getPreviousFocusableElement,\n    getStyle,\n    getWindow,\n    isCheckable,\n    isEditable,\n    isEventTarget,\n    isNode,\n    isNodeFocusable,\n    parseDimensions,\n    parsePosition,\n    queryAll,\n    queryAny,\n    setDimensions,\n    toSelector,\n} from \"./dom\";\nimport { microTick } from \"./time\";\n\n/**\n * @typedef {Target | Promise<Target>} AsyncTarget\n *\n * @typedef {\"auto\" | \"blur\" | \"enter\" | \"tab\" | false} ConfirmAction\n *\n * @typedef {{\n *  dataTransfer?: DataTransfer;\n *  dropEffect: \"none\" | \"copy\" | \"link\" | \"move\";\n *  effectAllowed?: \"none\" | \"copy\" | \"copyLink\" | \"copyMove\" | \"link\" | \"linkMove\" | \"move\" | \"all\" | \"uninitialized\";\n *  files?: File[];\n *  items?: [string, string][];\n * }} DataTransferOptions\n *\n * @typedef {{\n *  cancel: (options?: EventOptions) => Promise<EventList>;\n *  drop: (to?: AsyncTarget | DragOptions, options?: DragOptions) => Promise<EventList>;\n *  moveTo: (to?: AsyncTarget | DragOptions, options?: DragOptions) => Promise<DragHelpers>;\n * }} DragHelpers\n *\n * @typedef {PointerOptions & DataTransferOptions} DragOptions\n *\n * @typedef {import(\"./dom\").Position} Position\n *\n * @typedef {import(\"./dom\").Dimensions} Dimensions\n *\n * @typedef {((ev: Event) => boolean) | EventType} EventListPredicate\n *\n * @typedef {{\n *  eventInit?: EventInit;\n * }} EventOptions generic event options\n *\n * @typedef {{\n *  clientX: number;\n *  clientY: number;\n *  pageX: number;\n *  pageY: number;\n *  screenX: number;\n *  screenY: number;\n * }} EventPosition\n *\n * @typedef {keyof HTMLElementEventMap | keyof WindowEventMap} EventType\n *\n * @typedef {EventOptions & {\n *  confirm?: ConfirmAction;\n *  composition?: boolean;\n *  instantly?: boolean;\n * }} FillOptions\n *\n * @typedef {string | number | MaybeIterable<File>} InputValue\n *\n * @typedef {EventOptions & KeyboardEventInit} KeyboardOptions\n *\n * @typedef {string | string[]} KeyStrokes\n *\n * @typedef {EventOptions & QueryOptions & {\n *  button?: number,\n *  position?: Side | `${Side}-${Side}` | Position;\n *  relative?: boolean;\n * }} PointerOptions\n *\n * @typedef {import(\"./dom\").QueryOptions} QueryOptions\n *\n * @typedef {EventOptions & QueryOptions & {\n *  force?: boolean;\n *  initiator?: \"keyboard\" | \"scrollbar\" | \"wheel\" | null;\n *  relative?: boolean;\n * }} ScrollOptions\n *\n * @typedef {EventOptions & {\n *  target: AsyncTarget;\n * }} SelectOptions\n *\n * @typedef {\"bottom\" | \"left\" | \"right\" | \"top\"} Side\n */\n\n/**\n * @template [T=EventInit]\n * @typedef {T & {\n *  target: EventTarget;\n *  type: EventType;\n * }} FullEventInit\n */\n\n/**\n * @template T\n * @typedef {T | Iterable<T>} MaybeIterable\n */\n\n/**\n * @template [T=Node]\n * @typedef {import(\"./dom\").Target<T>} Target\n */\n\n//-----------------------------------------------------------------------------\n// Global\n//-----------------------------------------------------------------------------\n\nconst {\n    AnimationEvent,\n    ClipboardEvent,\n    CompositionEvent,\n    console: { dir: $dir, groupCollapsed: $groupCollapsed, groupEnd: $groupEnd, log: $log },\n    DataTransfer,\n    document,\n    DragEvent,\n    Error,\n    ErrorEvent,\n    Event,\n    File,\n    FocusEvent,\n    HashChangeEvent,\n    KeyboardEvent,\n    Math: { ceil: $ceil, max: $max, min: $min },\n    MouseEvent,\n    Number: { isInteger: $isInteger, isNaN: $isNaN, parseFloat: $parseFloat },\n    Object: {\n        assign: $assign,\n        create: $create,\n        defineProperties: $defineProperties,\n        values: $values,\n    },\n    PointerEvent,\n    PromiseRejectionEvent,\n    String,\n    SubmitEvent,\n    Touch,\n    TouchEvent,\n    TypeError,\n    WheelEvent,\n} = globalThis;\n/** @type {Document[\"createRange\"]} */\nconst $createRange = document.createRange.bind(document);\nconst $toString = Object.prototype.toString;\n\n//-----------------------------------------------------------------------------\n// Internal\n//-----------------------------------------------------------------------------\n\n/**\n * @param {Event} ev\n */\nfunction cancelTrustedEvent(ev) {\n    if (ev.isTrusted && runTime.eventsToIgnore.includes(ev.type)) {\n        runTime.eventsToIgnore.splice(runTime.eventsToIgnore.indexOf(ev.type), 1);\n        ev.stopPropagation();\n        ev.stopImmediatePropagation();\n        ev.preventDefault();\n    }\n}\n\n/**\n * @param {HTMLElement} target\n * @param {number} start\n * @param {number} end\n */\nasync function changeSelection(target, start, end) {\n    if (!isNil(start) && !isNil(target.selectionStart)) {\n        target.selectionStart = start;\n    }\n    if (!isNil(end) && !isNil(target.selectionEnd)) {\n        target.selectionEnd = end;\n    }\n}\n\n/**\n * @param {HTMLElement} target\n * @param {number} x\n */\nfunction constrainScrollX(target, x) {\n    let { offsetWidth, scrollWidth } = target;\n    const document = getDocument(target);\n    if (target === document || target === document.documentElement) {\n        // <html> elements in iframes consider the width of the <iframe> element\n        const iframe = getParentFrame(target);\n        if (iframe) {\n            ({ offsetWidth } = iframe);\n        }\n    }\n    const maxScrollLeft = scrollWidth - offsetWidth;\n    const { direction } = getStyle(target);\n    const [min, max] = direction === \"rtl\" ? [-maxScrollLeft, 0] : [0, maxScrollLeft];\n    return $min($max(x, min), max);\n}\n\n/**\n * @param {HTMLElement} target\n * @param {number} y\n */\nfunction constrainScrollY(target, y) {\n    let { offsetHeight, scrollHeight } = target;\n    const document = getDocument(target);\n    if (target === document || target === document.documentElement) {\n        // <html> elements in iframes consider the height of the <iframe> element\n        const iframe = getParentFrame(target);\n        if (iframe) {\n            ({ offsetHeight } = iframe);\n        }\n    }\n    return $min($max(y, 0), scrollHeight - offsetHeight);\n}\n\n/**\n * @param {DataTransferOptions} options\n */\nfunction createDataTransfer(options) {\n    const dataTransfer = isInstanceOf(options?.dataTransfer, DataTransfer)\n        ? options.dataTransfer\n        : new DataTransfer();\n    for (const file of options?.files || []) {\n        if (!isInstanceOf(file, File)) {\n            throw new TypeError(`'DataTransfer.files' list only accepts 'File' objects`);\n        }\n        dataTransfer.items.add(file);\n    }\n    for (const [data, type] of options?.items || []) {\n        dataTransfer.items.add(data, type);\n    }\n\n    $defineProperties(dataTransfer, {\n        dropEffect: { value: options?.dropEffect || \"none\", writable: true },\n        effectAllowed: { value: options?.effectAllowed || \"all\", writable: true },\n    });\n\n    return dataTransfer;\n}\n\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement} target\n */\nfunction deleteSelection(target) {\n    const { selectionStart, selectionEnd, value } = target;\n    return value.slice(0, selectionStart) + value.slice(selectionEnd);\n}\n\n/**\n * @template {EventTarget} T\n * @param {{\n *  target: T;\n *  events: EventType[];\n *  additionalEvents?: EventType[];\n *  callback?: (target: T) => any;\n *  options?: EventInit;\n * }} params\n */\nasync function dispatchAndIgnore({ target, events, additionalEvents = [], callback, options }) {\n    for (const eventType of [...events, ...additionalEvents]) {\n        runTime.eventsToIgnore.push(eventType);\n    }\n    if (callback) {\n        callback(target);\n    }\n    for (const eventType of events) {\n        await _dispatch(target, eventType, options);\n    }\n}\n\n/**\n *\n * @param {EventTarget} target\n * @param {EventType} eventType\n * @param {PointerEventInit} eventInit\n * @param {{\n *  mouse?: [EventType, MouseEventInit];\n *  touch?: [EventType, TouchEventInit];\n * }} additionalEvents\n */\nasync function dispatchPointerEvent(target, eventType, eventInit, { mouse, touch }) {\n    const pointerEvent = await _dispatch(target, eventType, eventInit);\n    let prevented = isPrevented(pointerEvent);\n    if (hasTouch()) {\n        if (touch && runTime.pointerDownTarget) {\n            const [touchEventType, touchEventInit] = touch;\n            await _dispatch(runTime.pointerDownTarget, touchEventType, touchEventInit || eventInit);\n        }\n    } else {\n        if (mouse && !prevented) {\n            const [mouseEventType, mouseEventInit] = mouse;\n            const mouseEvent = await _dispatch(target, mouseEventType, mouseEventInit || eventInit);\n            prevented = isPrevented(mouseEvent);\n        }\n    }\n    return prevented;\n}\n\n/**\n * @param {Iterable<Event>} events\n * @param {EventType} eventType\n * @param {EventInit} eventInit\n */\nasync function dispatchRelatedEvents(events, eventType, eventInit) {\n    for (const event of events) {\n        if (!event.target || isPrevented(event)) {\n            break;\n        }\n        await _dispatch(event.target, eventType, eventInit);\n    }\n}\n\n/**\n * @template T\n * @param {MaybeIterable<T>} value\n * @returns {T[]}\n */\nfunction ensureArray(value) {\n    return isIterable(value) ? [...value] : [value];\n}\n\nfunction getCurrentEvents() {\n    const eventType = currentEventTypes.at(-1);\n    if (!eventType) {\n        return [];\n    }\n    currentEvents[eventType] ||= [];\n    return currentEvents[eventType];\n}\n\nfunction getDefaultRunTimeValue() {\n    return {\n        isComposing: false,\n\n        // Data transfers\n        /** @type {DataTransfer | null} */\n        clipboardData: null,\n        /** @type {DataTransfer | null} */\n        dataTransfer: null,\n\n        // Drag & drop\n        canStartDrag: false,\n        isDragging: false,\n        lastDragOverCancelled: false,\n\n        // Pointer\n        clickCount: 0,\n        key: null,\n        /** @type {HTMLElement | null} */\n        pointerDownTarget: null,\n        pointerDownTimeout: 0,\n        /** @type {HTMLElement | null} */\n        pointerTarget: null,\n        /** @type {EventPosition | {}} */\n        position: {},\n        /** @type {HTMLElement | null} */\n        previousPointerDownTarget: null,\n        /** @type {EventPosition | {}} */\n        touchStartPosition: {},\n\n        // File\n        fileInput: null,\n\n        // Buttons\n        buttons: 0,\n\n        // Modifier keys\n        modifierKeys: {},\n\n        /**\n         * Ignored events (\"select\" by default since it is sometimes dispatched by\n         * focusing an input).\n         * @type {EventType[]}\n         */\n        eventsToIgnore: [],\n    };\n}\n\n/**\n * Returns the list of nodes containing n2 (included) that do not contain n1.\n *\n * @param {Element} [el1]\n * @param {Element} [el2]\n */\nfunction getDifferentParents(el1, el2) {\n    if (!el1 && !el2) {\n        // No given elements => no parents\n        return [];\n    } else if (!el1 && el2) {\n        // No first element => only parents of second element\n        [el1, el2] = [el2, el1];\n    }\n    const parents = [el2 || el1];\n    while (parents[0].parentElement) {\n        const parent = parents[0].parentElement;\n        if (el2 && parent.contains(el1)) {\n            break;\n        }\n        parents.unshift(parent);\n    }\n    return parents;\n}\n\n/**\n * @template {typeof Event} T\n * @param {EventType} eventType\n * @returns {[T, ((attrs: FullEventInit) => EventInit), number]}\n */\nfunction getEventConstructor(eventType) {\n    switch (eventType) {\n        // Mouse events\n        case \"dblclick\":\n        case \"mousedown\":\n        case \"mouseup\":\n        case \"mousemove\":\n        case \"mouseover\":\n        case \"mouseout\":\n            return [MouseEvent, mapMouseEvent, BUBBLES | CANCELABLE | VIEW];\n        case \"mouseenter\":\n        case \"mouseleave\":\n            return [MouseEvent, mapMouseEvent, VIEW];\n\n        // Pointer events\n        case \"auxclick\":\n        case \"click\":\n        case \"contextmenu\":\n        case \"pointerdown\":\n        case \"pointerup\":\n        case \"pointermove\":\n        case \"pointerover\":\n        case \"pointerout\":\n            return [PointerEvent, mapPointerEvent, BUBBLES | CANCELABLE | VIEW];\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"pointercancel\":\n            return [PointerEvent, mapPointerEvent, VIEW];\n\n        // Focus events\n        case \"blur\":\n        case \"focus\":\n            return [FocusEvent, mapEvent];\n        case \"focusin\":\n        case \"focusout\":\n            return [FocusEvent, mapEvent, BUBBLES];\n\n        // Clipboard events\n        case \"cut\":\n        case \"copy\":\n        case \"paste\":\n            return [ClipboardEvent, mapEvent, BUBBLES];\n\n        // Keyboard events\n        case \"keydown\":\n        case \"keyup\":\n            return [KeyboardEvent, mapKeyboardEvent, BUBBLES | CANCELABLE | VIEW];\n\n        // Drag events\n        case \"drag\":\n        case \"dragend\":\n        case \"dragenter\":\n        case \"dragstart\":\n        case \"dragleave\":\n        case \"dragover\":\n        case \"drop\":\n            return [DragEvent, mapEvent, BUBBLES | CANCELABLE];\n\n        // Input events\n        case \"beforeinput\":\n            return [InputEvent, mapInputEvent, BUBBLES | CANCELABLE | VIEW];\n        case \"input\":\n            return [InputEvent, mapInputEvent, BUBBLES | VIEW];\n\n        // Composition events\n        case \"compositionstart\":\n        case \"compositionend\":\n            return [CompositionEvent, mapEvent, BUBBLES];\n\n        // Selection events\n        case \"select\":\n        case \"selectionchange\":\n            return [Event, mapEvent, BUBBLES];\n\n        // Touch events\n        case \"touchstart\":\n        case \"touchend\":\n        case \"touchmove\":\n            return [TouchEvent, mapTouchEvent, BUBBLES | CANCELABLE | VIEW];\n        case \"touchcancel\":\n            return [TouchEvent, mapTouchEvent, BUBBLES | VIEW];\n\n        // Resize events\n        case \"resize\":\n            return [Event, mapEvent];\n\n        // Submit events\n        case \"submit\":\n            return [SubmitEvent, mapEvent, BUBBLES | CANCELABLE];\n\n        // Wheel events\n        case \"wheel\":\n            return [WheelEvent, mapWheelEvent, BUBBLES | VIEW];\n\n        // Animation events\n        case \"animationcancel\":\n        case \"animationend\":\n        case \"animationiteration\":\n        case \"animationstart\": {\n            return [AnimationEvent, mapEvent, BUBBLES | CANCELABLE];\n        }\n\n        // Error events\n        case \"error\":\n            return [ErrorEvent, mapEvent];\n        case \"unhandledrejection\":\n            return [PromiseRejectionEvent, mapEvent, CANCELABLE];\n\n        // Unload events (BeforeUnloadEvent cannot be constructed)\n        case \"beforeunload\":\n            return [Event, mapEvent, CANCELABLE];\n        case \"unload\":\n            return [Event, mapEvent];\n\n        // URL events\n        case \"hashchange\":\n            return [HashChangeEvent, mapEvent];\n\n        // Default: base Event constructor\n        default:\n            return [Event, mapEvent, BUBBLES];\n    }\n}\n\n/**\n * @param {Node} [a]\n * @param {Node} [b]\n */\nfunction getFirstCommonParent(a, b) {\n    if (!a || !b || a.ownerDocument !== b.ownerDocument) {\n        return null;\n    }\n\n    const range = document.createRange();\n    range.setStart(a, 0);\n    range.setEnd(b, 0);\n\n    if (range.collapsed) {\n        // Re-arranges range if the first node comes after the second\n        range.setStart(b, 0);\n        range.setEnd(a, 0);\n    }\n\n    return range.commonAncestorContainer;\n}\n\n/**\n * Returns the interactive pointer target from a given element, unless the element\n * is falsy, or the 'interactive' option is set to `false`.\n *\n * If an 'originalTarget' is given, the helper will deliberately throw an error if\n * no interactive elements are found.\n *\n * @param {HTMLElement} element\n * @param {QueryOptions} options\n * @param {AsyncTarget} [originalTarget]\n */\nfunction getPointerTarget(element, options, originalTarget) {\n    if (!element || options?.interactive === false) {\n        return element;\n    }\n    const interactiveElement = getInteractiveNode(element);\n    if (!interactiveElement && originalTarget) {\n        queryAny(originalTarget, { ...options, interactive: true }); // Will throw if no elements are found\n    }\n    return interactiveElement;\n}\n\n/**\n * @param {HTMLElement} element\n * @param {PointerOptions} [options]\n */\nfunction getPosition(element, options) {\n    const { position, relative } = options || {};\n    const isString = typeof position === \"string\";\n    const [posX, posY] = parsePosition(position);\n\n    if (!isString && !relative && !$isNaN(posX) && !$isNaN(posY)) {\n        // Absolute position\n        return toEventPosition(posX, posY, position);\n    }\n\n    const { x, y, width, height } = getNodeRect(element);\n    let clientX = x;\n    let clientY = y;\n\n    if (isString) {\n        const positions = position.split(\"-\");\n\n        // X position\n        if (positions.includes(\"left\")) {\n            clientX -= 1;\n        } else if (positions.includes(\"right\")) {\n            clientX += $ceil(width) + 1;\n        } else {\n            clientX += width / 2;\n        }\n\n        // Y position\n        if (positions.includes(\"top\")) {\n            clientY -= 1;\n        } else if (positions.includes(\"bottom\")) {\n            clientY += $ceil(height) + 1;\n        } else {\n            clientY += height / 2;\n        }\n    } else {\n        // X position\n        if ($isNaN(posX)) {\n            clientX += width / 2;\n        } else {\n            if (relative) {\n                clientX += posX || 0;\n            } else {\n                clientX = posX || 0;\n            }\n        }\n\n        // Y position\n        if ($isNaN(posY)) {\n            clientY += height / 2;\n        } else {\n            if (relative) {\n                clientY += posY || 0;\n            } else {\n                clientY = posY || 0;\n            }\n        }\n    }\n\n    return toEventPosition(clientX, clientY, position);\n}\n\n/**\n * @param {HTMLInputElement | HTMLTextAreaElement} target\n */\nfunction getStringSelection(target) {\n    return (\n        $isInteger(target.selectionStart) &&\n        $isInteger(target.selectionEnd) &&\n        [target.selectionStart, target.selectionEnd].join(\",\")\n    );\n}\n\n/**\n * @param {Node} node\n * @param {...string} tagNames\n */\nfunction hasTagName(node, ...tagNames) {\n    return tagNames.includes(getTag(node));\n}\n\nfunction hasTouch() {\n    return (\n        globalThis.ontouchstart !== undefined || globalThis.matchMedia(\"(pointer:coarse)\").matches\n    );\n}\n\n/**\n * @param {Position | null} position\n */\nfunction isDifferentPosition(position) {\n    if (!runTime.position || !position) {\n        return runTime.position !== position;\n    }\n    for (const key in position) {\n        if (runTime.position[key] !== position[key]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * @param {unknown} object\n */\nfunction isDictionary(object) {\n    return $toString.call(object) === \"[object Object]\";\n}\n\n/**\n * @param {unknown} value\n */\nfunction isNil(value) {\n    return value === null || value === undefined;\n}\n\n/**\n * @param {Event} event\n */\nfunction isPrevented(event) {\n    return event && event.defaultPrevented;\n}\n\n/**\n * @param {KeyStrokes} keyStrokes\n * @param {KeyboardEventInit} [options]\n * @returns {KeyboardEventInit}\n */\nfunction parseKeyStrokes(keyStrokes, options) {\n    return (isIterable(keyStrokes) ? [...keyStrokes] : [keyStrokes]).map((key) => {\n        const lower = key.toLowerCase();\n        return {\n            ...options,\n            key: lower.length === 1 ? key : KEY_ALIASES[lower] || key,\n        };\n    });\n}\n\n/**\n * Redirects all 'submit' events to explicit network requests.\n *\n * This allows the `mockFetch` helper to take control over submit requests.\n *\n * @param {SubmitEvent} ev\n */\nfunction redirectSubmit(ev) {\n    if (isPrevented(ev)) {\n        return;\n    }\n\n    ev.preventDefault();\n\n    /** @type {HTMLFormElement} */\n    const form = ev.target;\n\n    globalThis.fetch(form.action, {\n        method: form.method,\n        body: new FormData(form, ev.submitter),\n    });\n}\n\n/**\n * @param {PointerEventInit} eventInit\n * @param {boolean} toggle\n */\nfunction registerButton(eventInit, toggle) {\n    let value = 0;\n    switch (eventInit.button) {\n        case btn.LEFT: {\n            // Main button (left button)\n            value = 1;\n            break;\n        }\n        case btn.MIDDLE: {\n            // Auxiliary button (middle button)\n            value = 4;\n            break;\n        }\n        case btn.RIGHT: {\n            // Secondary button (right button)\n            value = 2;\n            break;\n        }\n        case btn.BACK: {\n            // Fourth button (Browser Back)\n            value = 8;\n            break;\n        }\n        case btn.FORWARD: {\n            // Fifth button (Browser Forward)\n            value = 16;\n            break;\n        }\n    }\n\n    runTime.buttons = $max(runTime.buttons + (toggle ? value : -value), 0);\n}\n\n/**\n * @param {Event} ev\n */\nfunction registerFileInput({ target }) {\n    const actualTarget = target.shadowRoot ? target.shadowRoot.activeElement : target;\n    if (getTag(actualTarget) === \"input\" && actualTarget.type === \"file\") {\n        runTime.fileInput = actualTarget;\n    } else {\n        runTime.fileInput = null;\n    }\n}\n\n/**\n * @param {EventTarget} target\n * @param {string} initialValue\n * @param {ConfirmAction} confirmAction\n */\nasync function registerForChange(target, initialValue, confirmAction) {\n    function dispatchChange() {\n        return target.value !== initialValue && _dispatch(target, \"change\");\n    }\n\n    confirmAction &&= confirmAction.toLowerCase();\n    if (confirmAction === \"auto\") {\n        confirmAction = getTag(target) === \"input\" ? \"enter\" : \"blur\";\n    }\n    if (getTag(target) === \"input\") {\n        changeTargetListeners.push(\n            on(target, \"keydown\", (ev) => {\n                if (isPrevented(ev) || ev.key !== \"Enter\") {\n                    return;\n                }\n                removeChangeTargetListeners();\n                afterNextDispatch = dispatchChange;\n            })\n        );\n    } else if (confirmAction === \"enter\") {\n        throw new HootInteractionError(\n            `\"enter\" confirm action is only supported on <input/> elements`\n        );\n    }\n\n    changeTargetListeners.push(\n        on(target, \"blur\", () => {\n            removeChangeTargetListeners();\n            dispatchChange();\n        }),\n        on(target, \"change\", removeChangeTargetListeners)\n    );\n\n    switch (confirmAction) {\n        case \"blur\": {\n            await _hover(\n                getDocument(target).body,\n                { position: { x: 0, y: 0 } },\n                { originalTarget: target }\n            );\n            await _click();\n            break;\n        }\n        case \"enter\": {\n            await _press(target, { key: \"Enter\" });\n            break;\n        }\n        case \"tab\": {\n            await _press(target, { key: \"Tab\" });\n            break;\n        }\n    }\n}\n\n/**\n * @param {KeyboardEventInit} eventInit\n * @param {boolean} toggle\n */\nfunction registerSpecialKey(eventInit, toggle) {\n    switch (eventInit.key) {\n        case \"Alt\": {\n            runTime.modifierKeys.altKey = toggle;\n            break;\n        }\n        case \"Control\": {\n            runTime.modifierKeys.ctrlKey = toggle;\n            break;\n        }\n        case \"Meta\": {\n            runTime.modifierKeys.metaKey = toggle;\n            break;\n        }\n        case \"Shift\": {\n            runTime.modifierKeys.shiftKey = toggle;\n            break;\n        }\n    }\n}\n\nfunction removeChangeTargetListeners() {\n    while (changeTargetListeners.length) {\n        changeTargetListeners.pop()();\n    }\n}\n\n/**\n * @param {HTMLElement | null} target\n * @param {QueryOptions} [options]\n */\nfunction setPointerDownTarget(target, options) {\n    if (runTime.pointerDownTarget) {\n        runTime.previousPointerDownTarget = runTime.pointerDownTarget;\n    }\n    runTime.pointerDownTarget = getPointerTarget(target, options);\n    runTime.canStartDrag = false;\n}\n\n/**\n * @param {string} type\n * @param {EventOptions} type\n */\nfunction setupEvents(type, options) {\n    currentEventTypes.push(type);\n    $assign(currentEventInit, options?.eventInit);\n\n    return function finalizeEvents() {\n        for (const eventType in currentEventInit) {\n            delete currentEventInit[eventType];\n        }\n        const events = new EventList(getCurrentEvents());\n        const currentType = currentEventTypes.pop();\n        delete currentEvents[currentType];\n        if (!allowLogs) {\n            return events;\n        }\n        const groupName = [\n            `%c[${type}]%c dispatched`,\n            `color: ${getColorHex(\"purple\")}`,\n            \"\",\n            events.length,\n            `events`,\n        ];\n        $groupCollapsed(...groupName);\n        for (const event of events) {\n            /** @type {string[]} */\n            const colors = [getColorHex(\"text-report-html-tag\")];\n\n            const typeList = [event.type];\n            if (event.key) {\n                typeList.push(event.key);\n            } else if (event.button) {\n                typeList.push(event.button);\n            }\n            [...Array(typeList.length)].forEach(() =>\n                colors.push(getColorHex(\"text-report-string\"))\n            );\n\n            const typeString = typeList.map((t) => `%c\"${t}\"%c`).join(\", \");\n            let message = `%c${event.constructor.name}%c<${typeString}>`;\n            if (event.__bubbleCount) {\n                message += ` (${event.__bubbleCount})`;\n            }\n            const target = event.__originalTarget || event.target;\n            if (isNode(target)) {\n                const targetParts = toSelector(target, { object: true });\n                colors.push(getColorHex(\"text-report-html-tag\"));\n                if (targetParts.id) {\n                    colors.push(getColorHex(\"text-report-html-id\"));\n                }\n                if (targetParts.class) {\n                    colors.push(getColorHex(\"text-report-html-class\"));\n                }\n                const targetString = $values(targetParts)\n                    .map((part) => `%c${part}%c`)\n                    .join(\"\");\n                message += ` @${targetString}`;\n            }\n            const messageColors = colors.flatMap((color) => [\n                `color: ${color}; font-weight: normal`,\n                \"\",\n            ]);\n\n            $groupCollapsed(message, ...messageColors);\n            $dir(event);\n            $log(target);\n            $groupEnd();\n        }\n        $groupEnd();\n\n        return events;\n    };\n}\n\n/**\n * @param {number} clientX\n * @param {number} clientY\n * @param {Partial<EventPosition>} [position]\n */\nfunction toEventPosition(clientX, clientY, position) {\n    clientX ||= 0;\n    clientY ||= 0;\n    return {\n        clientX,\n        clientY,\n        pageX: position?.pageX ?? clientX,\n        pageY: position?.pageY ?? clientY,\n        screenX: position?.screenX ?? clientX,\n        screenY: position?.screenY ?? clientY,\n    };\n}\n\n/**\n * @param {EventTarget} target\n * @param {PointerEventInit} pointerInit\n */\nasync function triggerClick(target, pointerInit) {\n    if (target.disabled) {\n        return;\n    }\n    const eventType = (pointerInit.button ?? 0) === btn.LEFT ? \"click\" : \"auxclick\";\n    const clickEvent = await _dispatch(target, eventType, pointerInit);\n    if (isPrevented(clickEvent)) {\n        return;\n    }\n    if (isFirefox()) {\n        // Thanks Firefox\n        switch (getTag(target)) {\n            case \"label\": {\n                /**\n                 * @firefox\n                 * Special action: label 'Click'\n                 *  On: unprevented 'click' on a <label/>\n                 *  Do: triggers a 'click' event on the first <input/> descendant\n                 */\n                target = target.control;\n                if (target) {\n                    await triggerClick(target, pointerInit);\n                }\n                break;\n            }\n            case \"option\": {\n                /**\n                 * @firefox\n                 * Special action: option 'Click'\n                 *  On: unprevented 'click' on an <option/>\n                 *  Do: triggers a 'change' event on the parent <select/>\n                 */\n                const parent = target.parentElement;\n                if (parent && getTag(parent) === \"select\") {\n                    await _dispatch(parent, \"change\");\n                }\n                break;\n            }\n        }\n    }\n}\n\n/**\n * @param {EventTarget} target\n * @param {DragEventInit} eventInit\n */\nasync function triggerDrag(target, eventInit) {\n    await _dispatch(target, \"drag\", eventInit);\n    // Only \"dragover\" being prevented is taken into account for \"drop\" events\n    const dragOverEvent = await _dispatch(target, \"dragover\", eventInit);\n    return isPrevented(dragOverEvent);\n}\n\n/**\n * @param {EventTarget} target\n */\nasync function triggerFocus(target) {\n    const previous = getActiveElement(target);\n    if (previous === target) {\n        return;\n    }\n    if (previous !== target.ownerDocument.body) {\n        await dispatchAndIgnore({\n            target: previous,\n            events: [\"blur\", \"focusout\"],\n            callback: (el) => el.blur(),\n            options: { relatedTarget: target },\n        });\n    }\n    if (isNodeFocusable(target)) {\n        const previousSelection = getStringSelection(target);\n        await dispatchAndIgnore({\n            target,\n            events: [\"focus\", \"focusin\"],\n            additionalEvents: [\"select\"],\n            callback: (el) => el.focus(),\n            options: { relatedTarget: previous },\n        });\n        if (previousSelection && previousSelection === getStringSelection(target)) {\n            changeSelection(target, target.value.length, target.value.length);\n        }\n    }\n}\n\n/**\n * @param {EventTarget} target\n * @param {FillOptions} [options]\n */\nasync function _clear(target, options) {\n    // Inputs and text areas\n    const initialValue = target.value;\n\n    // Simulates 2 key presses:\n    // - Control + A: selects all the text\n    // - Backspace: deletes the text\n    fullClear = true;\n    await _press(target, { ctrlKey: true, key: \"a\" });\n    await _press(target, { key: \"Backspace\" });\n    fullClear = false;\n\n    await registerForChange(target, initialValue, options?.confirm);\n}\n\n/**\n * @param {PointerOptions} [options]\n */\nasync function _click(options) {\n    await _pointerDown(options);\n    await _pointerUp(options);\n}\n\n/**\n * @template {EventType} T\n * @template {HTMLBodyElementEventMap[T]} I\n * @param {EventTarget} target\n * @param {T} type\n * @param {Partial<I> | { eventInit: Record<T, Partial<I>> }} [eventInit]\n * @returns {Promise<I>}\n */\nasync function _dispatch(target, type, eventInit) {\n    eventInit = { ...eventInit, ...currentEventInit[type] };\n    for (const key in eventInit) {\n        if (key in DEPRECATED_EVENT_PROPERTIES) {\n            throw new HootInteractionError(\n                `cannot dispatch \"${type}\" event: property \"${key}\" is deprecated, use \"${DEPRECATED_EVENT_PROPERTIES[key]}\" instead`\n            );\n        }\n    }\n\n    const [Constructor, processParams, flags] = getEventConstructor(type);\n    const params = processParams({\n        composed: true,\n        ...eventInit,\n        target,\n        type,\n    });\n    if (flags & BUBBLES) {\n        params.bubbles = true;\n    }\n    if (flags & CANCELABLE) {\n        params.cancelable = true;\n    }\n    if (flags & VIEW) {\n        params.view ||= getWindow(target);\n    }\n    const event = new Constructor(type, params);\n\n    target.dispatchEvent(event);\n    await Promise.resolve();\n\n    getCurrentEvents().push(event);\n\n    if (afterNextDispatch) {\n        const callback = afterNextDispatch;\n        afterNextDispatch = null;\n        await microTick().then(callback);\n    }\n\n    return event;\n}\n\n/**\n * @param {EventTarget} target\n * @param {InputValue} value\n * @param {FillOptions} [options]\n */\nasync function _fill(target, value, options) {\n    const initialValue = target.value;\n\n    if (getTag(target) === \"input\") {\n        switch (target.type) {\n            case \"color\": {\n                target.value = String(value);\n                await _dispatch(target, \"input\");\n                await _dispatch(target, \"change\");\n                return;\n            }\n            case \"file\": {\n                const files = ensureArray(value);\n                if (files.length > 1 && !target.multiple) {\n                    throw new HootInteractionError(\n                        `input[type=\"file\"] does not support multiple files`\n                    );\n                }\n                target.files = createDataTransfer({ files }).files;\n\n                await _dispatch(target, \"change\");\n                return;\n            }\n            case \"range\": {\n                const numberValue = $parseFloat(value);\n                if ($isNaN(numberValue)) {\n                    throw new TypeError(`input[type=\"range\"] only accept 'number' values`);\n                }\n\n                target.value = String(numberValue);\n                await _dispatch(target, \"input\");\n                await _dispatch(target, \"change\");\n                return;\n            }\n        }\n    }\n\n    if (options?.instantly) {\n        // Simulates filling the clipboard with the value (can be from external source)\n        globalThis.navigator.clipboard.writeText(value).catch();\n        await _press(target, { ctrlKey: true, key: \"v\" });\n    } else {\n        if (options?.composition) {\n            runTime.isComposing = true;\n            // Simulates the start of a composition\n            await _dispatch(target, \"compositionstart\");\n        }\n        for (const char of String(value)) {\n            const key = char.toLowerCase();\n            await _press(target, { key, shiftKey: key !== char });\n        }\n        if (options?.composition) {\n            runTime.isComposing = false;\n            // Simulates the end of a composition\n            await _dispatch(target, \"compositionend\");\n        }\n    }\n\n    await registerForChange(target, initialValue, options?.confirm);\n}\n\n/**\n * @param {EventTarget | null} target\n * @param {PointerOptions | null} options\n * @param {{ implicit?: boolean, originalTarget: AsyncTarget }} hoverOptions\n */\nasync function _hover(target, options, hoverOptions) {\n    const pointerTarget = getPointerTarget(target, options, hoverOptions.originalTarget);\n    const position = target && getPosition(target, options);\n\n    const previousPT = runTime.pointerTarget;\n    const previousPosition = runTime.position;\n\n    const isDifferentTarget = previousPT !== pointerTarget;\n\n    if (hoverOptions?.implicit && !isDifferentTarget && !isDifferentPosition(position)) {\n        // Implicit hover: do not perform hover if the pointer target is the same\n        // and the position didn't change.\n        return;\n    }\n    if (runTime.canStartDrag) {\n        /**\n         * Special action: drag start\n         *  On: unprevented 'pointerdown' on a draggable element (DESKTOP ONLY)\n         *  Do: triggers a 'dragstart' event\n         */\n        const dragStartEvent = await _dispatch(previousPT, \"dragstart\", {\n            dataTransfer: runTime.dataTransfer,\n        });\n\n        runTime.isDragging = !isPrevented(dragStartEvent);\n        runTime.canStartDrag = false;\n    }\n\n    runTime.pointerTarget = pointerTarget;\n    runTime.position = position;\n\n    if (\n        isDifferentTarget &&\n        previousPT &&\n        (!pointerTarget || !previousPT.contains(pointerTarget))\n    ) {\n        // Leaves previous target\n        const leaveEventInit = {\n            ...previousPosition,\n            relatedTarget: pointerTarget,\n            button: options?.button || 0,\n        };\n\n        if (runTime.isDragging) {\n            // If dragging, only drag events are triggered\n            const leaveEventInitWithDT = { ...leaveEventInit, dataTransfer: runTime.dataTransfer };\n            runTime.lastDragOverCancelled = await triggerDrag(previousPT, leaveEventInitWithDT);\n            await _dispatch(previousPT, \"dragleave\", leaveEventInitWithDT);\n        } else {\n            // Regular case: pointer events are triggered\n            await dispatchPointerEvent(previousPT, \"pointermove\", leaveEventInit, {\n                mouse: [\"mousemove\"],\n                touch: [\"touchmove\"],\n            });\n            await dispatchPointerEvent(previousPT, \"pointerout\", leaveEventInit, {\n                mouse: [\"mouseout\"],\n            });\n            const leaveEvents = await Promise.all(\n                getDifferentParents(pointerTarget, previousPT).map((element) =>\n                    _dispatch(element, \"pointerleave\", leaveEventInit)\n                )\n            );\n            if (!hasTouch()) {\n                await dispatchRelatedEvents(leaveEvents, \"mouseleave\", leaveEventInit);\n            }\n        }\n    }\n\n    if (!pointerTarget) {\n        return;\n    }\n\n    const enterEventInit = {\n        ...runTime.position,\n        relatedTarget: previousPT,\n        button: options?.button || 0,\n    };\n    if (runTime.isDragging) {\n        // If dragging, only drag events are triggered\n        const enterEventInitWithDT = { ...enterEventInit, dataTransfer: runTime.dataTransfer };\n        runTime.lastDragOverCancelled = false;\n        if (isDifferentTarget) {\n            const dragEnterEvent = await _dispatch(\n                pointerTarget,\n                \"dragenter\",\n                enterEventInitWithDT\n            );\n            runTime.lastDragOverCancelled = isPrevented(dragEnterEvent);\n        }\n        runTime.lastDragOverCancelled ||= await triggerDrag(pointerTarget, enterEventInitWithDT);\n    } else {\n        // Regular case: pointer events are triggered\n        if (isDifferentTarget) {\n            await dispatchPointerEvent(pointerTarget, \"pointerover\", enterEventInit, {\n                mouse: [\"mouseover\"],\n            });\n            const enterEvents = await Promise.all(\n                getDifferentParents(previousPT, pointerTarget).map((element) =>\n                    _dispatch(element, \"pointerenter\", enterEventInit)\n                )\n            );\n            if (!hasTouch()) {\n                await dispatchRelatedEvents(enterEvents, \"mouseenter\", enterEventInit);\n            }\n        }\n        await dispatchPointerEvent(pointerTarget, \"pointermove\", enterEventInit, {\n            mouse: [\"mousemove\"],\n            touch: [\"touchmove\"],\n        });\n    }\n}\n\n/**\n * @param {EventTarget} target\n * @param {KeyboardEventInit} eventInit\n */\nasync function _keyDown(target, eventInit) {\n    eventInit = { ...eventInit, ...currentEventInit.keydown };\n    registerSpecialKey(eventInit, true);\n\n    const repeat =\n        typeof eventInit.repeat === \"boolean\" ? eventInit.repeat : runTime.key === eventInit.key;\n    runTime.key = eventInit.key;\n    const keyDownEvent = await _dispatch(target, \"keydown\", { ...eventInit, repeat });\n\n    if (isPrevented(keyDownEvent)) {\n        return;\n    }\n\n    /**\n     * @param {string} toInsert\n     * @param {string} type\n     */\n    function insertValue(toInsert, type) {\n        const { selectionStart, selectionEnd, value } = target;\n        inputData = toInsert;\n        inputType = type;\n        if (isNil(selectionStart) && isNil(selectionEnd)) {\n            nextValue += toInsert;\n        } else {\n            nextValue = value.slice(0, selectionStart) + toInsert + value.slice(selectionEnd);\n            if (selectionStart === selectionEnd) {\n                nextSelectionStart = nextSelectionEnd = selectionStart + 1;\n            }\n        }\n    }\n\n    const { ctrlKey, key, shiftKey } = keyDownEvent;\n    const initialValue = target.value;\n    let inputData = null;\n    let inputType = null;\n    let nextSelectionEnd = null;\n    let nextSelectionStart = null;\n    let nextValue = initialValue;\n    let triggerSelect = false;\n\n    if (isEditable(target)) {\n        switch (key) {\n            case \"ArrowDown\":\n            case \"ArrowLeft\":\n            case \"ArrowUp\":\n            case \"ArrowRight\": {\n                const { selectionStart, selectionEnd, value } = target;\n                if (isNil(selectionStart) || isNil(selectionEnd)) {\n                    break;\n                }\n                const start = key === \"ArrowLeft\" || key === \"ArrowUp\";\n                let selectionTarget;\n                if (ctrlKey) {\n                    // Move to the start/end of the line\n                    selectionTarget = start ? 0 : value.length;\n                } else {\n                    // Move the cursor left or right\n                    selectionTarget = start ? selectionStart - 1 : selectionEnd + 1;\n                }\n                nextSelectionStart = nextSelectionEnd = $max(\n                    $min(selectionTarget, value.length),\n                    0\n                );\n                triggerSelect = shiftKey;\n                break;\n            }\n            case \"Backspace\": {\n                const { selectionStart, selectionEnd, value } = target;\n                if (fullClear) {\n                    // Remove all characters\n                    nextValue = \"\";\n                } else if (isNil(selectionStart) || isNil(selectionEnd)) {\n                    // Remove last character\n                    nextValue = value.slice(0, -1);\n                } else if (selectionStart === selectionEnd) {\n                    // Remove previous character from target value\n                    nextValue = value.slice(0, selectionStart - 1) + value.slice(selectionEnd);\n                } else {\n                    // Remove current selection from target value\n                    nextValue = deleteSelection(target);\n                }\n                inputType = \"deleteContentBackward\";\n                break;\n            }\n            case \"Delete\": {\n                const { selectionStart, selectionEnd, value } = target;\n                if (fullClear) {\n                    // Remove all characters\n                    nextValue = \"\";\n                } else if (isNil(selectionStart) || isNil(selectionEnd)) {\n                    // Remove first character\n                    nextValue = value.slice(1);\n                } else if (selectionStart === selectionEnd) {\n                    // Remove next character from target value\n                    nextValue = value.slice(0, selectionStart) + value.slice(selectionEnd + 1);\n                } else {\n                    // Remove current selection from target value\n                    nextValue = deleteSelection(target);\n                }\n                inputType = \"deleteContentForward\";\n                break;\n            }\n            case \"Enter\": {\n                if (target.tagName === \"TEXTAREA\") {\n                    // Insert new line\n                    insertValue(\"\\n\", \"insertLineBreak\");\n                }\n                break;\n            }\n            default: {\n                if (key.length === 1 && !ctrlKey) {\n                    // Character coming from the keystroke\n                    // ! TODO: Doesn't work with non-roman locales\n                    insertValue(\n                        shiftKey ? key.toUpperCase() : key.toLowerCase(),\n                        runTime.isComposing ? \"insertCompositionText\" : \"insertText\"\n                    );\n                }\n            }\n        }\n    }\n\n    switch (key) {\n        case \"a\": {\n            if (ctrlKey) {\n                // Select all\n                if (isEditable(target)) {\n                    nextSelectionStart = 0;\n                    nextSelectionEnd = target.value.length;\n                    triggerSelect = true;\n                } else {\n                    const selection = globalThis.getSelection();\n                    const range = $createRange();\n                    range.selectNodeContents(target);\n                    selection.removeAllRanges();\n                    selection.addRange(range);\n                }\n            }\n            break;\n        }\n        /**\n         * Special action: copy\n         *  On: unprevented 'Control + c' keydown\n         *  Do: copy current selection to clipboard\n         */\n        case \"c\": {\n            if (ctrlKey) {\n                // Get selection from window\n                const text = globalThis.getSelection().toString();\n                globalThis.navigator.clipboard.writeText(text).catch();\n\n                runTime.clipboardData = createDataTransfer(eventInit);\n                await _dispatch(target, \"copy\", { clipboardData: runTime.clipboardData });\n            }\n            break;\n        }\n        case \"Enter\": {\n            const tag = getTag(target);\n            const parentForm = target.closest(\"form\");\n            if (parentForm && target.type !== \"button\") {\n                /**\n                 * Special action: <form> 'Enter'\n                 *  On: unprevented 'Enter' keydown on any element that\n                 *      is not a <button type=\"button\"/> in a form element\n                 *  Do: triggers a 'submit' event on the form\n                 */\n                await _dispatch(parentForm, \"submit\");\n            } else if (\n                !keyDownEvent.repeat &&\n                (tag === \"a\" || tag === \"button\" || (tag === \"input\" && target.type === \"button\"))\n            ) {\n                /**\n                 * Special action: <a>, <button> or <input type=\"button\"> 'Enter'\n                 *  On: unprevented and unrepeated 'Enter' keydown on mentioned elements\n                 *  Do: triggers a 'click' event on the element\n                 */\n                await _dispatch(target, \"click\", { button: btn.LEFT });\n            }\n            break;\n        }\n        case \"Escape\": {\n            runTime.dataTransfer = null;\n            runTime.isDragging = false;\n            break;\n        }\n        /**\n         * Special action: shift focus\n         *  On: unprevented 'Tab' keydown\n         *  Do: focus next (or previous with 'Shift') focusable element\n         */\n        case \"Tab\": {\n            const next = shiftKey\n                ? getPreviousFocusableElement({ tabbable: true })\n                : getNextFocusableElement({ tabbable: true });\n            if (next) {\n                await triggerFocus(next);\n            }\n            break;\n        }\n        /**\n         * Special action: paste\n         *  On: unprevented 'Control + v' keydown on editable element\n         *  Do: paste current clipboard content to current element\n         */\n        case \"v\": {\n            if (ctrlKey && isEditable(target)) {\n                // Set target value (if possible)\n                try {\n                    nextValue = await globalThis.navigator.clipboard.readText();\n                } catch {\n                    // Ignore clipboard errors\n                }\n                inputType = \"insertFromPaste\";\n\n                await _dispatch(target, \"paste\", {\n                    clipboardData: runTime.clipboardData || createDataTransfer(eventInit),\n                });\n                runTime.clipboardData = null;\n            }\n            break;\n        }\n        /**\n         * Special action: cut\n         *  On: unprevented 'Control + x' keydown on editable element\n         *  Do: cut current selection to clipboard and remove selection\n         */\n        case \"x\": {\n            if (ctrlKey && isEditable(target)) {\n                // Get selection from window\n                const text = globalThis.getSelection().toString();\n                globalThis.navigator.clipboard.writeText(text).catch();\n\n                nextValue = deleteSelection(target);\n                inputType = \"deleteByCut\";\n\n                runTime.clipboardData = createDataTransfer(eventInit);\n                await _dispatch(target, \"cut\", { clipboardData: runTime.clipboardData });\n            }\n            break;\n        }\n    }\n\n    if (initialValue !== nextValue) {\n        target.value = nextValue;\n        const inputEventInit = {\n            data: inputData,\n            inputType,\n        };\n        const beforeInputEvent = await _dispatch(target, \"beforeinput\", inputEventInit);\n        if (!isPrevented(beforeInputEvent)) {\n            await _dispatch(target, \"input\", inputEventInit);\n        }\n    }\n    changeSelection(target, nextSelectionStart, nextSelectionEnd);\n    if (triggerSelect) {\n        await dispatchAndIgnore({\n            target,\n            events: [\"select\"],\n        });\n    }\n}\n\n/**\n * @param {EventTarget} target\n * @param {KeyboardEventInit} eventInit\n */\nasync function _keyUp(target, eventInit) {\n    eventInit = { ...eventInit, ...currentEventInit.keyup };\n    await _dispatch(target, \"keyup\", eventInit);\n\n    runTime.key = null;\n    registerSpecialKey(eventInit, false);\n\n    if (eventInit.key === \" \" && getTag(target) === \"input\" && target.type === \"checkbox\") {\n        /**\n         * Special action: input[type=checkbox] 'Space'\n         *  On: unprevented ' ' keydown on an <input type=\"checkbox\"/>\n         *  Do: triggers a 'click' event on the input\n         */\n        await triggerClick(target, { button: btn.LEFT });\n    }\n}\n\n/**\n * @param {DragOptions} [options]\n */\nasync function _pointerDown(options) {\n    setPointerDownTarget(runTime.pointerTarget, options);\n\n    if (options?.dataTransfer || options?.files || options?.items) {\n        runTime.dataTransfer = createDataTransfer(options);\n    }\n\n    const pointerDownTarget = runTime.pointerDownTarget;\n    const eventInit = {\n        ...runTime.position,\n        ...currentEventInit.pointerdown,\n        button: options?.button || btn.LEFT,\n    };\n\n    registerButton(eventInit, true);\n\n    if (pointerDownTarget !== runTime.previousPointerDownTarget) {\n        runTime.clickCount = 0;\n    }\n\n    runTime.touchStartPosition = { ...runTime.position };\n    runTime.touchStartTimeOffset = globalThis.Date.now();\n    const prevented = await dispatchPointerEvent(pointerDownTarget, \"pointerdown\", eventInit, {\n        mouse: !pointerDownTarget.disabled && [\n            \"mousedown\",\n            { ...eventInit, detail: runTime.clickCount + 1 },\n        ],\n        touch: [\"touchstart\"],\n    });\n\n    if (prevented) {\n        return;\n    }\n\n    // Focus the element (if focusable)\n    await triggerFocus(pointerDownTarget);\n\n    if (\n        eventInit.button === btn.LEFT &&\n        !hasTouch() &&\n        (pointerDownTarget.draggable || runTime.dataTransfer)\n    ) {\n        runTime.canStartDrag = true;\n    } else if (eventInit.button === btn.RIGHT) {\n        /**\n         * Special action: context menu\n         *  On: unprevented 'pointerdown' with right click and its related\n         *      event on an element\n         *  Do: triggers a 'contextmenu' event\n         */\n        await _dispatch(pointerDownTarget, \"contextmenu\", eventInit);\n    }\n}\n\n/**\n * @param {PointerOptions} [options]\n */\nasync function _pointerUp(options) {\n    const target = runTime.pointerTarget;\n    const isLongTap = globalThis.Date.now() - runTime.touchStartTimeOffset > LONG_TAP_DELAY;\n    const pointerDownTarget = runTime.pointerDownTarget;\n    const pointerUpTarget = getPointerTarget(target, options);\n    const eventInit = {\n        ...runTime.position,\n        ...currentEventInit.pointerup,\n        button: options?.button || btn.LEFT,\n    };\n\n    registerButton(eventInit, false);\n\n    if (runTime.isDragging) {\n        // If dragging, only drag events are triggered\n        const eventInitWithDT = { ...eventInit, dataTransfer: runTime.dataTransfer };\n        runTime.dataTransfer = null;\n        runTime.isDragging = false;\n        if (runTime.lastDragOverCancelled) {\n            /**\n             * Special action: drop\n             * - On: pointer up after a prevented 'dragover' or 'dragenter'\n             * - Do: triggers a 'drop' event on the target\n             */\n            await _dispatch(pointerUpTarget, \"drop\", eventInitWithDT);\n        }\n\n        await _dispatch(pointerUpTarget, \"dragend\", eventInitWithDT);\n        return;\n    }\n\n    const mouseEventInit = {\n        ...eventInit,\n        detail: runTime.clickCount + 1,\n    };\n    await dispatchPointerEvent(pointerUpTarget, \"pointerup\", eventInit, {\n        mouse: !pointerUpTarget.disabled && [\"mouseup\", mouseEventInit],\n        touch: [\"touchend\"],\n    });\n\n    const touchStartPosition = runTime.touchStartPosition;\n    runTime.touchStartPosition = {};\n\n    if (hasTouch() && (isDifferentPosition(touchStartPosition) || isLongTap)) {\n        // No further event is triggered:\n        // there was a swiping motion since the \"touchstart\" event\n        // or a long press was detected.\n        return;\n    }\n\n    let clickTarget;\n    if (hasTouch()) {\n        clickTarget = pointerDownTarget === pointerUpTarget && pointerUpTarget;\n    } else {\n        clickTarget = getFirstCommonParent(pointerUpTarget, pointerDownTarget);\n    }\n    if (clickTarget) {\n        await triggerClick(clickTarget, mouseEventInit);\n        if (mouseEventInit.button === btn.LEFT) {\n            runTime.clickCount++;\n            if (!hasTouch() && runTime.clickCount % 2 === 0) {\n                await _dispatch(clickTarget, \"dblclick\", mouseEventInit);\n            }\n        }\n    }\n\n    setPointerDownTarget(null, options);\n    if (runTime.pointerDownTimeout) {\n        globalThis.clearTimeout(runTime.pointerDownTimeout);\n    }\n    runTime.pointerDownTimeout = globalThis.setTimeout(() => {\n        // Use `globalThis.setTimeout` to potentially make use of the mock timeouts\n        // since the events run in the same temporal context as the tests\n        runTime.clickCount = 0;\n        runTime.pointerDownTimeout = 0;\n    }, DOUBLE_CLICK_DELAY);\n}\n\n/**\n * @param {EventTarget} target\n * @param {KeyboardEventInit} eventInit\n */\nasync function _press(target, eventInit) {\n    await _keyDown(target, eventInit);\n    await _keyUp(target, eventInit);\n}\n\n/**\n * @param {EventTarget} target\n * @param {string | number | (string | number)[]} value\n */\nasync function _select(target, value) {\n    const values = ensureArray(value).map(String);\n    let found = false;\n    for (const option of target.options) {\n        option.selected = values.includes(option.value);\n        found ||= option.selected;\n    }\n    if (!value) {\n        target.selectedIndex = -1;\n    } else if (!found) {\n        throw new HootInteractionError(\n            `error when calling \\`select()\\`: no option found with value \"${values.join(\", \")}\"`\n        );\n    }\n    await _dispatch(target, \"change\");\n}\n\nclass HootInteractionError extends Error {\n    name = \"HootInteractionError\";\n}\n\nconst btn = {\n    LEFT: 0,\n    MIDDLE: 1,\n    RIGHT: 2,\n    BACK: 3,\n    FORWARD: 4,\n};\nconst CAPTURE = { capture: true };\nconst DEPRECATED_EVENT_PROPERTIES = {\n    keyCode: \"key\",\n    which: \"key\",\n};\nconst DEPRECATED_EVENTS = {\n    keypress: \"keydown\",\n    mousewheel: \"wheel\",\n};\nconst DOUBLE_CLICK_DELAY = 500;\n\n/**\n * Ignore certain trusted events (dispatched by `focus()`, `scroll()`, etc.)\n * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}\n */\nconst GLOBAL_TRUSTED_EVENTS_CANCELERS = [\n    [\"blur\", cancelTrustedEvent, CAPTURE],\n    [\"focus\", cancelTrustedEvent, CAPTURE],\n    [\"focusin\", cancelTrustedEvent, CAPTURE],\n    [\"focusout\", cancelTrustedEvent, CAPTURE],\n    [\"scroll\", cancelTrustedEvent, CAPTURE],\n    [\"scrollend\", cancelTrustedEvent, CAPTURE],\n    [\"select\", cancelTrustedEvent, CAPTURE],\n];\n/**\n * Register file input on click & focus events\n * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}\n */\nconst GLOBAL_FILE_INPUT_REGISTERERS = [\n    [\"click\", registerFileInput, CAPTURE],\n    [\"focus\", registerFileInput, CAPTURE],\n];\n/**\n * Redirect events to other features\n * @type {[EventType, (event: Event) => any, AddEventListenerOptions][]}\n */\nconst GLOBAL_SUBMIT_FORWARDERS = [[\"submit\", redirectSubmit]];\n\nconst KEY_ALIASES = {\n    // case insensitive aliases\n    alt: \"Alt\",\n    arrowdown: \"ArrowDown\",\n    arrowleft: \"ArrowLeft\",\n    arrowright: \"ArrowRight\",\n    arrowup: \"ArrowUp\",\n    backspace: \"Backspace\",\n    control: \"Control\",\n    delete: \"Delete\",\n    enter: \"Enter\",\n    escape: \"Escape\",\n    meta: \"Meta\",\n    shift: \"Shift\",\n    tab: \"Tab\",\n\n    // Other aliases\n    caps: \"Shift\",\n    cmd: \"Meta\",\n    command: \"Meta\",\n    ctrl: \"Control\",\n    del: \"Delete\",\n    down: \"ArrowDown\",\n    esc: \"Escape\",\n    left: \"ArrowLeft\",\n    right: \"ArrowRight\",\n    space: \" \",\n    up: \"ArrowUp\",\n    win: \"Meta\",\n};\nconst LONG_TAP_DELAY = 500;\n\n/** @type {Record<string, Event[]>} */\nconst currentEvents = $create(null);\n/** @type {Record<EventType, EventInit>} */\nconst currentEventInit = $create(null);\n/** @type {string[]} */\nconst currentEventTypes = [];\n/** @type {(() => Promise<void>) | null} */\nlet afterNextDispatch = null;\nlet allowLogs = false;\nlet fullClear = false;\n\n// Keyboard global variables\nconst changeTargetListeners = [];\n\n// Other global variables\nconst runTime = getDefaultRunTimeValue();\n\n//-----------------------------------------------------------------------------\n// Event init attributes mappers\n//-----------------------------------------------------------------------------\n\nconst BUBBLES = 0b1;\nconst CANCELABLE = 0b10;\nconst VIEW = 0b100;\n\n// Generic mappers\n// ---------------\n\n/**\n * - does not bubble\n * - cannot be canceled\n * @param {FullEventInit} eventInit\n */\nfunction mapEvent(eventInit) {\n    return eventInit;\n}\n\n// Pointer, mouse & wheel event mappers\n// ------------------------------------\n\n/**\n * @param {FullEventInit<MouseEventInit>} eventInit\n */\nfunction mapMouseEvent(eventInit) {\n    return {\n        button: -1,\n        buttons: runTime.buttons,\n        clientX: eventInit.clientX ?? eventInit.pageX ?? eventInit.screenX ?? 0,\n        clientY: eventInit.clientY ?? eventInit.pageY ?? eventInit.screenY ?? 0,\n        ...runTime.modifierKeys,\n        ...eventInit,\n    };\n}\n\n/**\n * @param {FullEventInit<PointerEventInit>} eventInit\n */\nfunction mapPointerEvent(eventInit) {\n    return {\n        ...mapMouseEvent(eventInit),\n        button: btn.LEFT,\n        isPrimary: eventInit?.btn ? eventInit.btn === btn.LEFT : true,\n        pointerId: 1,\n        pointerType: hasTouch() ? \"touch\" : \"mouse\",\n        ...eventInit,\n    };\n}\n\n/**\n * @param {FullEventInit<WheelEventInit>} eventInit\n */\nfunction mapWheelEvent(eventInit) {\n    return {\n        ...mapMouseEvent(eventInit),\n        button: btn.LEFT,\n        ...eventInit,\n    };\n}\n\n// Touch event mappers\n// -------------------\n\n/**\n * @param {FullEventInit<TouchEventInit>} eventInit\n */\nfunction mapTouchEvent(eventInit) {\n    const touches = eventInit.targetTouches ||\n        eventInit.touches || [new Touch({ identifier: 0, ...eventInit })];\n    return {\n        ...eventInit,\n        changedTouches: eventInit.changedTouches || touches,\n        target: eventInit.target,\n        targetTouches: eventInit.targetTouches || touches,\n        touches: eventInit.touches || (eventInit.type === \"touchend\" ? [] : touches),\n    };\n}\n\n// Keyboard & input event mappers\n// ------------------------------\n\n/**\n * @param {FullEventInit<InputEventInit>} eventInit\n */\nfunction mapInputEvent(eventInit) {\n    return {\n        data: null,\n        isComposing: !!runTime.isComposing,\n        ...eventInit,\n    };\n}\n\n/**\n * @param {FullEventInit<KeyboardEventInit>} eventInit\n */\nfunction mapKeyboardEvent(eventInit) {\n    return {\n        isComposing: !!runTime.isComposing,\n        ...runTime.modifierKeys,\n        ...eventInit,\n    };\n}\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * Ensures that the given {@link AsyncTarget} is checked.\n *\n * If it is not checked, a click is simulated on the input.\n * If the input is still not checked after the click, an error is thrown.\n *\n * @see {@link click}\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  check(\"input[type=checkbox]\"); // Checks the first <input> checkbox element\n */\nexport async function check(target, options) {\n    const finalizeEvents = setupEvents(\"check\", options);\n    const element = queryAny(await target, options);\n    if (!isCheckable(element)) {\n        throw new HootInteractionError(\n            `cannot call \\`check()\\`: target should be a checkbox or radio input`\n        );\n    }\n\n    const checkTarget = getTag(element) === \"label\" ? element.control : element;\n    if (!checkTarget.checked) {\n        await _hover(element, options, { implicit: true, originalTarget: target });\n        await _click(options);\n\n        if (!checkTarget.checked) {\n            throw new HootInteractionError(\n                `error when calling \\`check()\\`: target is not checked after interaction`\n            );\n        }\n    }\n\n    return finalizeEvents();\n}\n\nexport function cleanupEvents() {\n    if (runTime.pointerDownTimeout) {\n        globalThis.clearTimeout(runTime.pointerDownTimeout);\n    }\n\n    removeChangeTargetListeners();\n\n    // Runtime global variables\n    $assign(runTime, getDefaultRunTimeValue());\n}\n\n/**\n * Clears the **value** of the current **active element**.\n *\n * This is done using the following sequence:\n * - pressing \"Control\" + \"A\" to select the whole value;\n * - pressing \"Backspace\" to delete the value;\n * - (optional) triggering a \"change\" event by pressing \"Enter\".\n *\n * @param {FillOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  clear(); // Clears the value of the current active element\n */\nexport async function clear(options) {\n    const finalizeEvents = setupEvents(\"clear\", options);\n    const element = getActiveElement();\n\n    if (!hasTagName(element, \"select\") && !isEditable(element)) {\n        throw new HootInteractionError(\n            `cannot call \\`clear()\\`: target should be editable or a <select> element`\n        );\n    }\n\n    if (isEditable(element)) {\n        await _clear(element, options);\n    } else {\n        // Selects\n        await _select(element, \"\");\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a click sequence on the given {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n *  - `pointerdown`\n *  - [desktop] `mousedown`\n *  - [touch] `touchstart`\n *  - [target is not active element] `blur`\n *  - [target is focusable] `focus`\n *  - `pointerup`\n *  - [desktop] `mouseup`\n *  - [touch] `touchend`\n *  - `click`\n *  - `dblclick` if click is not prevented & current click count is even\n *\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  click(\"button\"); // Clicks on the first <button> element\n */\nexport async function click(target, options) {\n    const finalizeEvents = setupEvents(\"click\", options);\n    const element = queryAny(await target, options);\n\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _click(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Performs two click sequences on the given {@link AsyncTarget}.\n *\n * @see {@link click}\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  dblclick(\"button\"); // Double-clicks on the first <button> element\n */\nexport async function dblclick(target, options) {\n    const finalizeEvents = setupEvents(\"dblclick\", options);\n    const element = queryAny(await target, options);\n\n    options = { ...options, button: btn.LEFT };\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _click(options);\n    await _click(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Disclaimer: avoid using this method; it is meant to support niche event sequences,\n * or as a temporary fix for unsupported use cases. Prefer using other 'hoot-dom'\n * helpers such as {@link click}, {@link press} or {@link edit}.\n *\n * Creates a new DOM {@link Event} of the given type and dispatches it on the given\n * {@link Target}.\n *\n * Note that this function is free of side-effects and does not trigger any other\n * event or special action. It also only supports standard DOM events, and will\n * crash when trying to dispatch a non-standard or deprecated event.\n *\n * @template {EventType} T\n * @template {HTMLBodyElementEventMap[T]} I\n * @param {EventTarget} target\n * @param {T} type\n * @param {Partial<I> | { eventInit: Record<T, Partial<I>> }} [eventInit]\n * @example\n *  await manuallyDispatchProgrammaticEvent(\"input\", \"paste\"); // Dispatches a \"paste\" event on the given <input>\n * @returns {Promise<EventList>}\n */\nexport async function dispatch(target, type, eventInit) {\n    const finalizeEvents = setupEvents(\"dispatch\");\n\n    if (!isEventTarget(target)) {\n        throw new HootInteractionError(\n            `cannot dispatch \"${type}\" event: expected target to be an 'EventTarget', got: ${target}`\n        );\n    }\n    if (type in DEPRECATED_EVENTS) {\n        throw new HootInteractionError(\n            `cannot dispatch \"${type}\" event: this event type is deprecated, use \"${DEPRECATED_EVENTS[type]}\" instead`\n        );\n    }\n    if (type !== type.toLowerCase()) {\n        throw new HootInteractionError(\n            `cannot dispatch \"${type}\" event: this event type is either non-standard or deprecated`\n        );\n    }\n\n    await _dispatch(target, type, eventInit);\n\n    return finalizeEvents();\n}\n\n/**\n * Starts a drag sequence on the given {@link AsyncTarget}.\n *\n * Returns a set of helper functions to direct the sequence:\n * - `moveTo`: moves the pointer to the given target;\n * - `drop`: drops the dragged element on the given target (if any);\n * - `cancel`: cancels the drag sequence.\n *\n * @param {AsyncTarget} target\n * @param {DragOptions} [options]\n * @returns {Promise<DragHelpers>}\n * @example\n *  drag(\".card:first\").drop(\".card:last\"); // Drags the first card onto the last one\n * @example\n *  drag(\".card:first\").moveTo(\".card:last\").drop(); // Same as above\n * @example\n *  const { cancel, moveTo } = await drag(\".card:first\"); // Starts the drag sequence\n *  moveTo(\".card:eq(3)\"); // Moves the dragged card to the 4th card\n *  cancel(); // Cancels the drag sequence\n */\nexport async function drag(target, options) {\n    /**\n     * @template T\n     * @param {T} fn\n     * @param {boolean} endDrag\n     * @returns {T}\n     */\n    function expectIsDragging(fn, endDrag) {\n        return {\n            async [fn.name](...args) {\n                if (dragEndReason) {\n                    throw new HootInteractionError(\n                        `cannot execute drag helper \\`${fn.name}\\`: drag sequence has been ended by \\`${dragEndReason}\\``\n                    );\n                }\n                const result = await fn(...args);\n                if (endDrag) {\n                    dragEndReason = fn.name;\n                }\n                return result;\n            },\n        }[fn.name];\n    }\n\n    const cancel = expectIsDragging(\n        /** @type {DragHelpers[\"cancel\"]} */\n        async function cancel(options) {\n            const finalizeEvents = setupEvents(\"drag & drop: cancel\", options);\n            const bodyElement = getDocument(runTime.pointerTarget).body;\n\n            // Reset buttons\n            runTime.buttons = 0;\n\n            await _press(bodyElement, { key: \"Escape\" });\n\n            dragEvents.push(...finalizeEvents());\n\n            return dragEvents;\n        },\n        true\n    );\n\n    const drop = expectIsDragging(\n        /** @type {DragHelpers[\"drop\"]} */\n        async function drop(to, options) {\n            if (to) {\n                await moveTo(to, options);\n\n                if (isDictionary(to)) {\n                    options = to;\n                }\n            }\n\n            const finalizeEvents = setupEvents(\"drag & drop: drop\", options);\n\n            await _pointerUp(options);\n\n            dragEvents.push(...finalizeEvents());\n\n            return dragEvents;\n        },\n        true\n    );\n\n    const moveTo = expectIsDragging(\n        /** @type {DragHelpers[\"moveTo\"]} */\n        async function moveTo(to, options) {\n            if (isDictionary(to)) {\n                [to, options] = [null, to];\n            }\n            const finalizeEvents = setupEvents(\"drag & drop: move\", options);\n\n            const nextElement = to ? queryAny(await to, options) : runTime.pointerTarget;\n            await _hover(nextElement, options, { originalTarget: to });\n\n            dragEvents.push(...finalizeEvents());\n\n            return dragHelpers;\n        },\n        false\n    );\n\n    const finalizeEvents = setupEvents(\"drag & drop: start\", options);\n    const dragHelpers = { cancel, drop, moveTo };\n    const dragStartTarget = queryAny(await target, options);\n    let dragEndReason = null;\n\n    // Pointer down on main target\n    await _hover(dragStartTarget, options, { implicit: true, originalTarget: target });\n    await _pointerDown(options);\n\n    const dragEvents = finalizeEvents();\n\n    return dragHelpers;\n}\n\n/**\n * Combination of {@link clear} and {@link fill}:\n * - first, clears the input value (if any)\n * - then fills the input with the given value\n *\n * @see {@link clear}\n * @see {@link fill}\n * @param {InputValue} value\n * @param {FillOptions} options\n * @returns {Promise<EventList>}\n * @example\n *  fill(\"foo\"); // Types \"foo\" in the active element\n *  edit(\"Hello World\"); // Replaces \"foo\" by \"Hello World\"\n */\nexport async function edit(value, options) {\n    const finalizeEvents = setupEvents(\"edit\", options);\n    const element = getActiveElement();\n    if (!isEditable(element)) {\n        throw new HootInteractionError(`cannot call \\`edit()\\`: target should be editable`);\n    }\n\n    if (getNodeValue(element)) {\n        await _clear(element);\n    }\n    await _fill(element, value, options);\n\n    return finalizeEvents();\n}\n\n/**\n * @param {boolean} toggle\n */\nexport function enableEventLogs(toggle) {\n    allowLogs = toggle ?? true;\n}\n\n/**\n * Fills the current **active element** with the given `value`. This helper is intended\n * for `<input>` and `<textarea>` elements, with the exception of `\"checkbox\"` and\n * `\"radio\"` types, which should be selected using the {@link check} helper.\n *\n * If the target is an editable input, its string `value` will be input one character\n * at a time, each generating its corresponding keyboard event sequence. This behavior\n * can be overriden by passing the `instantly` option, which will instead simulate\n * a `control` + `v` keyboard sequence, resulting in the whole text being pasted.\n *\n * Note that the given value is **appended** to the current value of the element.\n *\n * If the active element is a `<input type=\"file\"/>`, the `value` should be a\n * `File`/list of `File` object(s).\n *\n * @param {InputValue} value\n * @param {FillOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  fill(\"Hello World\"); // Types \"Hello World\" in the active element\n * @example\n *  fill(\"Hello World\", { instantly: true }); // Pastes \"Hello World\" in the active element\n * @example\n *  fill(new File([\"Hello World\"], \"hello.txt\")); // Uploads a file named \"hello.txt\" with \"Hello World\" as content\n */\nexport async function fill(value, options) {\n    const finalizeEvents = setupEvents(\"fill\", options);\n    const element = getActiveElement();\n\n    if (!isEditable(element)) {\n        throw new HootInteractionError(`cannot call \\`fill()\\`: target should be editable`);\n    }\n\n    await _fill(element, value, options);\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a hover sequence on the given {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n *  - `pointerover`\n *  - [desktop] `mouseover`\n *  - `pointerenter`\n *  - [desktop] `mouseenter`\n *  - `pointermove`\n *  - [desktop] `mousemove`\n *  - [touch] `touchmove`\n *\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  hover(\"button\"); // Hovers the first <button> element\n */\nexport async function hover(target, options) {\n    const finalizeEvents = setupEvents(\"hover\", options);\n    const element = queryAny(await target, options);\n\n    await _hover(element, options, { originalTarget: target });\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a key down sequence on the current **active element**.\n *\n * The event sequence is as follows:\n *  - `keydown`\n *\n * Additional actions will be performed depending on the key pressed:\n * - `Tab`: focus next (or previous with `shift`) focusable element;\n * - `c`: copy current selection to clipboard;\n * - `v`: paste current clipboard content to current element;\n * - `Enter`: submit the form if the target is a `<button type=\"button\">` or\n *  a `<form>` element, or trigger a `change` event on the target if it is\n *  an `<input>` element;\n * - `Space`: trigger a `click` event on the target if it is an `<input type=\"checkbox\">`\n *  element.\n *\n * @param {KeyStrokes} keyStrokes\n * @param {KeyboardOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  keyDown(\" \"); // Space key\n */\nexport async function keyDown(keyStrokes, options) {\n    const finalizeEvents = setupEvents(\"keyDown\", options);\n    const eventInits = parseKeyStrokes(keyStrokes, options);\n    for (const eventInit of eventInits) {\n        await _keyDown(getActiveElement(), eventInit);\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a key up sequence on the current **active element**.\n *\n * The event sequence is as follows:\n *  - `keyup`\n *\n * @param {KeyStrokes} keyStrokes\n * @param {KeyboardOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  keyUp(\"Enter\");\n */\nexport async function keyUp(keyStrokes, options) {\n    const finalizeEvents = setupEvents(\"keyUp\", options);\n    const eventInits = parseKeyStrokes(keyStrokes, options);\n    for (const eventInit of eventInits) {\n        await _keyUp(getActiveElement(), eventInit);\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a leave sequence on the current **window**.\n *\n * The event sequence is as follows:\n *  - `pointermove`\n *  - [desktop] `mousemove`\n *  - [touch] `touchmove`\n *  - `pointerout`\n *  - [desktop] `mouseout`\n *  - `pointerleave`\n *  - [desktop] `mouseleave`\n *\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  leave(\"button\"); // Moves out of <button>\n */\nexport async function leave(options) {\n    const finalizeEvents = setupEvents(\"leave\", options);\n\n    await _hover(null, options, { originalTarget: window });\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a middle-click sequence on the given {@link AsyncTarget}.\n *\n * @see {@link click}\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  middleClick(\"button\"); // Middle-clicks on the first <button> element\n */\nexport async function middleClick(target, options) {\n    const finalizeEvents = setupEvents(\"middleClick\", options);\n    const element = queryAny(await target, options);\n\n    options = { ...options, button: btn.MIDDLE };\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _click(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Shorthand helper to attach an event listener to the given {@link Target}, and\n * returning a function to remove the listener.\n *\n * @template {EventType} T\n * @param {Target<EventTarget>} target\n * @param {T} type\n * @param {(event: GlobalEventHandlersEventMap[T]) => any} listener\n * @param {boolean | AddEventListenerOptions} [options]\n * @returns {() => void}\n * @example\n *  const off = on(\"button\", \"click\", onClick);\n *  after(off);\n */\nexport function on(target, type, listener, options) {\n    const targets = isEventTarget(target) ? [target] : queryAll(target);\n    if (!targets.length) {\n        throw new HootInteractionError(`expected at least 1 event target, got none`);\n    }\n    for (const eventTarget of targets) {\n        eventTarget.addEventListener(type, listener, options);\n    }\n\n    return function off() {\n        for (const eventTarget of targets) {\n            eventTarget.removeEventListener(type, listener, options);\n        }\n    };\n}\n\n/**\n * Performs a pointer down on the given {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n *  - `pointerdown`\n *  - [desktop] `mousedown`\n *  - [touch] `touchstart`\n *  - [target is not active element] `blur`\n *  - [target is focusable] `focus`\n *\n * @param {AsyncTarget} target\n * @param {PointerOptions | DragOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  pointerDown(\"button\"); // Focuses to the first <button> element\n */\nexport async function pointerDown(target, options) {\n    const finalizeEvents = setupEvents(\"pointerDown\", options);\n    const element = queryAny(await target, options);\n\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _pointerDown(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a pointer up on the given {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n * - `pointerup`\n * - [desktop] `mouseup`\n * - [touch] `touchend`\n *\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  pointerUp(\"body\"); // Triggers a pointer up on the <body> element\n */\nexport async function pointerUp(target, options) {\n    const finalizeEvents = setupEvents(\"pointerUp\", options);\n    const element = queryAny(await target, options);\n\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _pointerUp(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a keyboard event sequence on the current **active element**.\n *\n * The event sequence is as follows:\n *  - `keydown`\n *  - `keyup`\n *\n * @param {KeyStrokes} keyStrokes\n * @param {KeyboardOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  pointerDown(\"button[type=submit]\"); // Moves focus to <button>\n *  keyDown(\"Enter\"); // Submits the form\n * @example\n *  keyDown(\"Shift+Tab\"); // Focuses previous focusable element\n * @example\n *  keyDown([\"ctrl\", \"v\"]); // Pastes current clipboard content\n */\nexport async function press(keyStrokes, options) {\n    const finalizeEvents = setupEvents(\"press\", options);\n    const eventInits = parseKeyStrokes(keyStrokes, options);\n    const activeElement = getActiveElement();\n\n    for (const eventInit of eventInits) {\n        await _keyDown(activeElement, eventInit);\n    }\n    for (const eventInit of eventInits.reverse()) {\n        await _keyUp(activeElement, eventInit);\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a resize event sequence on the current **window**.\n *\n * The event sequence is as follows:\n *  - `resize`\n *\n * The target will be resized to the given dimensions, enforced by `!important` style\n * attributes.\n *\n * @param {Dimensions} dimensions\n * @param {EventOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  resize(\"body\", { width: 1000, height: 500 }); // Resizes <body> to 1000x500\n */\nexport async function resize(dimensions, options) {\n    const finalizeEvents = setupEvents(\"resize\", options);\n    const [width, height] = parseDimensions(dimensions);\n\n    setDimensions(width, height);\n\n    await _dispatch(getWindow(), \"resize\");\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a right-click sequence on the given {@link AsyncTarget}.\n *\n * @see {@link click}\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  rightClick(\"button\"); // Middle-clicks on the first <button> element\n */\nexport async function rightClick(target, options) {\n    const finalizeEvents = setupEvents(\"rightClick\", options);\n    const element = queryAny(await target, options);\n\n    options = { ...options, button: btn.RIGHT };\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _click(options);\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a scroll event sequence on the given {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n *  - [desktop] `wheel`\n *  - `scroll`\n *\n * @param {AsyncTarget} target\n * @param {Position} position\n * @param {ScrollOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  scroll(\"body\", { y: 0 }); // Scrolls to the top of <body>\n */\nexport async function scroll(target, position, options) {\n    const finalizeEvents = setupEvents(\"scroll\", options);\n\n    // Parse position and assign default options\n    let [x, y] = parsePosition(position);\n    options = {\n        initiator: \"wheel\",\n        scrollable: x && y ? \"both\" : x ? \"x\" : y ? \"y\" : true,\n        ...options,\n    };\n\n    const { force, initiator, relative } = options;\n    /** @type {ScrollToOptions} */\n    const scrollTopOptions = {};\n    const element = queryAny(await target, options);\n    if (relative) {\n        x += element.scrollLeft;\n        y += element.scrollTop;\n    }\n    if (!$isNaN(x)) {\n        const targetX = force ? x : constrainScrollX(element, x);\n        if (targetX !== element.scrollLeft) {\n            scrollTopOptions.left = targetX;\n        }\n    }\n    if (!$isNaN(y)) {\n        const targetY = force ? y : constrainScrollY(element, y);\n        if (targetY !== element.scrollTop) {\n            scrollTopOptions.top = targetY;\n        }\n    }\n    const keys = [];\n    if (initiator === \"keyboard\") {\n        if (x < element.scrollLeft) {\n            keys.push(\"ArrowRight\");\n        } else if (x > element.scrollLeft) {\n            keys.push(\"ArrowLeft\");\n        }\n        if (y < element.scrollTop) {\n            keys.push(\"ArrowDown\");\n        } else if (y > element.scrollTop) {\n            keys.push(\"ArrowUp\");\n        }\n        await Promise.all(keys.map((key) => _keyDown(key)));\n    } else if (!hasTouch() && initiator === \"wheel\") {\n        /** @type {WheelEventInit} */\n        const wheelEventInit = {};\n        if (!$isNaN(x)) {\n            wheelEventInit.deltaX = x - element.scrollLeft;\n        }\n        if (!$isNaN(y)) {\n            wheelEventInit.deltaY = y - element.scrollTop;\n        }\n        await _dispatch(element, \"wheel\", wheelEventInit);\n    }\n    if (force || $values(scrollTopOptions).length) {\n        await dispatchAndIgnore({\n            target: element,\n            events: [\"scroll\", \"scrollend\"],\n            callback: (el) => el.scrollTo(scrollTopOptions),\n        });\n    }\n    if (initiator === \"keyboard\") {\n        await Promise.all(keys.map((key) => _keyUp(key)));\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Performs a selection event sequence on the current **active element**. This helper\n * is intended for `<select>` elements only.\n *\n * The event sequence is as follows:\n *  - `change`\n *\n * @param {string | number | (string | number)[]} value\n * @param {SelectOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  click(\"select[name=country]\"); // Focuses <select> element\n *  select(\"belgium\"); // Selects the <option value=\"belgium\"> element\n */\nexport async function select(value, options) {\n    const finalizeEvents = setupEvents(\"select\", options);\n    const target = options?.target || getActiveElement();\n    const element = queryAny(await target);\n\n    if (!hasTagName(element, \"select\")) {\n        throw new HootInteractionError(\n            `cannot call \\`select()\\`: target should be a <select> element`\n        );\n    }\n\n    if (options?.target) {\n        await _hover(element, null, { implicit: true, originalTarget: target });\n        await _pointerDown();\n    }\n    await _select(element, value);\n    if (options?.target) {\n        await _pointerUp();\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Gives the given {@link File} list to the current file input. This helper only\n * works if a file input has been previously interacted with (by clicking on it).\n *\n * @param {MaybeIterable<File>} files\n * @param {EventOptions} [options]\n * @returns {Promise<EventList>}\n */\nexport async function setInputFiles(files, options) {\n    if (!runTime.fileInput) {\n        throw new HootInteractionError(\n            `cannot call \\`setInputFiles()\\`: no file input has been interacted with`\n        );\n    }\n\n    const finalizeEvents = setupEvents(\"setInputFiles\", options);\n\n    await _fill(runTime.fileInput, files, options);\n\n    runTime.fileInput = null;\n\n    return finalizeEvents();\n}\n\n/**\n * Sets the given value to the given \"input[type=range]\" {@link AsyncTarget}.\n *\n * The event sequence is as follows:\n *  - `pointerdown`\n *  - `input`\n *  - `change`\n *  - `pointerup`\n *\n * @param {AsyncTarget} target\n * @param {number} value\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n */\nexport async function setInputRange(target, value, options) {\n    const finalizeEvents = setupEvents(\"setInputRange\", options);\n    const element = queryAny(await target, options);\n\n    await _hover(element, options, { implicit: true, originalTarget: target });\n    await _pointerDown(options);\n    await _fill(element, value, options);\n    await _pointerUp(options);\n\n    return finalizeEvents();\n}\n\n/**\n * @param {HTMLElement} target\n * @param {{\n *  allowSubmit?: boolean;\n *  allowTrustedEvents?: boolean;\n *  noFileInputRegistration?: boolean;\n * }} [options]\n */\nexport function setupEventActions(target, options) {\n    const eventHandlers = [];\n    if (!options?.allowTrustedEvents) {\n        eventHandlers.push(...GLOBAL_TRUSTED_EVENTS_CANCELERS);\n    }\n    if (!options?.noFileInputRegistration) {\n        eventHandlers.push(...GLOBAL_FILE_INPUT_REGISTERERS);\n    }\n    if (!options?.allowSubmit) {\n        eventHandlers.push(...GLOBAL_SUBMIT_FORWARDERS);\n    }\n\n    const view = getWindow(target);\n    for (const [eventType, handler, options] of eventHandlers) {\n        view.addEventListener(eventType, handler, options);\n    }\n\n    return function cleanupEventActions() {\n        for (const [eventType, handler, options] of eventHandlers) {\n            view.removeEventListener(eventType, handler, options);\n        }\n    };\n}\n\n/**\n * Ensures that the given {@link AsyncTarget} is unchecked.\n *\n * If it is checked, a click is triggered on the input.\n * If the input is still checked after the click, an error is thrown.\n *\n * @see {@link click}\n * @param {AsyncTarget} target\n * @param {PointerOptions} [options]\n * @returns {Promise<EventList>}\n * @example\n *  uncheck(\"input[type=checkbox]\"); // Unchecks the first <input> checkbox element\n */\nexport async function uncheck(target, options) {\n    const finalizeEvents = setupEvents(\"uncheck\", options);\n    const element = queryAny(await target, options);\n    if (!isCheckable(element)) {\n        throw new HootInteractionError(\n            `cannot call \\`uncheck()\\`: target should be a checkbox or radio input`\n        );\n    }\n\n    const checkTarget = getTag(element) === \"label\" ? element.control : element;\n    if (checkTarget.checked) {\n        await _hover(element, options, { implicit: true, originalTarget: target });\n        await _click(options);\n\n        if (checkTarget.checked) {\n            throw new HootInteractionError(\n                `error when calling \\`uncheck()\\`: target is still checked after interaction`\n            );\n        }\n    }\n\n    return finalizeEvents();\n}\n\n/**\n * Triggers a \"beforeunload\" event on the current **window**.\n *\n * @param {EventOptions} [options]\n * @returns {Promise<EventList>}\n */\nexport async function unload(options) {\n    const finalizeEvents = setupEvents(\"unload\", options);\n\n    await _dispatch(getWindow(), \"beforeunload\");\n\n    return finalizeEvents();\n}\n\n/** @extends {Array<Event>} */\nexport class EventList extends Array {\n    constructor(...args) {\n        super(...args.flat());\n    }\n\n    /**\n     * @param {EventListPredicate} predicate\n     */\n    get(predicate) {\n        return this.getAll(predicate)[0] || null;\n    }\n\n    /**\n     * @param {EventListPredicate} predicate\n     */\n    getAll(predicate) {\n        if (typeof predicate !== \"function\") {\n            const type = predicate;\n            predicate = function isSameType(ev) {\n                return ev.type === type;\n            };\n        }\n        return this.filter(predicate);\n    }\n}\n", "/** @odoo-module */\n\nimport { isInstanceOf } from \"../hoot_dom_utils\";\n\n/**\n * @typedef {{\n *  animationFrame?: boolean;\n *  blockTimers?: boolean;\n * }} AdvanceTimeOptions\n *\n * @typedef {{\n *  message?: string | () => string;\n *  timeout?: number;\n * }} WaitOptions\n */\n\n//-----------------------------------------------------------------------------\n// Global\n//-----------------------------------------------------------------------------\n\nconst {\n    cancelAnimationFrame,\n    clearInterval,\n    clearTimeout,\n    Error,\n    Math: { ceil: $ceil, floor: $floor, max: $max, min: $min },\n    Number,\n    performance,\n    Promise,\n    requestAnimationFrame,\n    setInterval,\n    setTimeout,\n} = globalThis;\n/** @type {Performance[\"now\"]} */\nconst $performanceNow = performance.now.bind(performance);\n\n//-----------------------------------------------------------------------------\n// Internal\n//-----------------------------------------------------------------------------\n\n/**\n * @param {number} id\n */\nfunction animationToId(id) {\n    return ID_PREFIX.animation + String(id);\n}\n\nfunction getNextTimerValues() {\n    /** @type {[number, () => any, string] | null} */\n    let timerValues = null;\n    for (const [internalId, [callback, init, delay]] of timers.entries()) {\n        const timeout = init + delay;\n        if (!timerValues || timeout < timerValues[0]) {\n            timerValues = [timeout, callback, internalId];\n        }\n    }\n    return timerValues;\n}\n\n/**\n * @param {string} id\n */\nfunction idToAnimation(id) {\n    return Number(id.slice(ID_PREFIX.animation.length));\n}\n\n/**\n * @param {string} id\n */\nfunction idToInterval(id) {\n    return Number(id.slice(ID_PREFIX.interval.length));\n}\n\n/**\n * @param {string} id\n */\nfunction idToTimeout(id) {\n    return Number(id.slice(ID_PREFIX.timeout.length));\n}\n\n/**\n * @param {number} id\n */\nfunction intervalToId(id) {\n    return ID_PREFIX.interval + String(id);\n}\n\n/**\n * Converts a given value to a **natural number** (or 0 if failing to do so).\n *\n * @param {unknown} value\n */\nfunction parseNat(value) {\n    return $max($floor(Number(value)), 0) || 0;\n}\n\nfunction now() {\n    return (frozen ? 0 : $performanceNow()) + timeOffset;\n}\n\n/**\n * @param {number} id\n */\nfunction timeoutToId(id) {\n    return ID_PREFIX.timeout + String(id);\n}\n\nclass HootTimingError extends Error {\n    name = \"HootTimingError\";\n}\n\nconst ID_PREFIX = {\n    animation: \"a_\",\n    interval: \"i_\",\n    timeout: \"t_\",\n};\n\n/** @type {Map<string, [() => any, number, number]>} */\nconst timers = new Map();\n\nlet allowTimers = false;\nlet frozen = false;\nlet frameDelay = 1000 / 60;\nlet nextDummyId = 1;\nlet timeOffset = 0;\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * @param {number} [frameCount]\n * @param {AdvanceTimeOptions} [options]\n */\nexport function advanceFrame(frameCount, options) {\n    return advanceTime(frameDelay * parseNat(frameCount), options);\n}\n\n/**\n * Advances the current time by the given amount of milliseconds. This will\n * affect all timeouts, intervals, animations and date objects.\n *\n * It returns a promise resolved after all related callbacks have been executed.\n *\n * @param {number} ms\n * @param {AdvanceTimeOptions} [options]\n * @returns {Promise<number>} time consumed by timers (in ms).\n */\nexport async function advanceTime(ms, options) {\n    ms = parseNat(ms);\n\n    if (options?.blockTimers) {\n        allowTimers = false;\n    }\n\n    const targetTime = now() + ms;\n    let remaining = ms;\n    /** @type {ReturnType<typeof getNextTimerValues>} */\n    let timerValues;\n    while ((timerValues = getNextTimerValues()) && timerValues[0] <= targetTime) {\n        const [timeout, handler, id] = timerValues;\n        const diff = timeout - now();\n        if (diff > 0) {\n            timeOffset += $min(remaining, diff);\n            remaining = $max(remaining - diff, 0);\n        }\n        if (timers.has(id)) {\n            handler(timeout);\n        }\n    }\n\n    if (remaining > 0) {\n        timeOffset += remaining;\n    }\n\n    if (options?.animationFrame ?? true) {\n        await animationFrame();\n    }\n\n    allowTimers = true;\n\n    return ms;\n}\n\n/**\n * Returns a promise resolved after the next animation frame, typically allowing\n * Owl components to render.\n *\n * @returns {Promise<void>}\n */\nexport function animationFrame() {\n    return new Promise((resolve) => requestAnimationFrame(() => setTimeout(resolve)));\n}\n\n/**\n * Cancels all current timeouts, intervals and animations.\n */\nexport function cancelAllTimers() {\n    for (const id of timers.keys()) {\n        if (id.startsWith(ID_PREFIX.animation)) {\n            globalThis.cancelAnimationFrame(idToAnimation(id));\n        } else if (id.startsWith(ID_PREFIX.interval)) {\n            globalThis.clearInterval(idToInterval(id));\n        } else if (id.startsWith(ID_PREFIX.timeout)) {\n            globalThis.clearTimeout(idToTimeout(id));\n        }\n    }\n}\n\nexport function cleanupTime() {\n    allowTimers = false;\n    frozen = false;\n\n    cancelAllTimers();\n\n    // Wait for remaining async code to run\n    return delay();\n}\n\n/**\n * Returns a promise resolved after a given amount of milliseconds (default to 0).\n *\n * @param {number} [duration]\n * @returns {Promise<void>}\n * @example\n *  await delay(1000); // waits for 1 second\n */\nexport function delay(duration) {\n    return new Promise((resolve) => setTimeout(resolve, duration));\n}\n\nexport function freezeTime() {\n    frozen = true;\n}\n\nexport function unfreezeTime() {\n    frozen = false;\n}\n\nexport function getTimeOffset() {\n    return timeOffset;\n}\n\nexport function isTimeFrozen() {\n    return frozen;\n}\n\n/**\n * Returns a promise resolved after the next microtask tick.\n *\n * @returns {Promise<void>}\n */\nexport function microTick() {\n    return new Promise(queueMicrotask);\n}\n\n/** @type {typeof cancelAnimationFrame} */\nexport function mockedCancelAnimationFrame(handle) {\n    if (!frozen) {\n        cancelAnimationFrame(handle);\n    }\n    timers.delete(animationToId(handle));\n}\n\n/** @type {typeof clearInterval} */\nexport function mockedClearInterval(intervalId) {\n    if (!frozen) {\n        clearInterval(intervalId);\n    }\n    timers.delete(intervalToId(intervalId));\n}\n\n/** @type {typeof clearTimeout} */\nexport function mockedClearTimeout(timeoutId) {\n    if (!frozen) {\n        clearTimeout(timeoutId);\n    }\n    timers.delete(timeoutToId(timeoutId));\n}\n\n/** @type {typeof requestAnimationFrame} */\nexport function mockedRequestAnimationFrame(callback) {\n    if (!allowTimers) {\n        return 0;\n    }\n\n    function handler() {\n        mockedCancelAnimationFrame(handle);\n        return callback(now());\n    }\n\n    const animationValues = [handler, now(), frameDelay];\n    const handle = frozen ? nextDummyId++ : requestAnimationFrame(handler);\n    const internalId = animationToId(handle);\n    timers.set(internalId, animationValues);\n\n    return handle;\n}\n\n/** @type {typeof setInterval} */\nexport function mockedSetInterval(callback, ms, ...args) {\n    if (!allowTimers) {\n        return 0;\n    }\n\n    ms = parseNat(ms);\n\n    function handler() {\n        if (allowTimers) {\n            intervalValues[1] = $max(now(), intervalValues[1] + ms);\n        } else {\n            mockedClearInterval(intervalId);\n        }\n        return callback(...args);\n    }\n\n    const intervalValues = [handler, now(), ms];\n    const intervalId = frozen ? nextDummyId++ : setInterval(handler, ms);\n    const internalId = intervalToId(intervalId);\n    timers.set(internalId, intervalValues);\n\n    return intervalId;\n}\n\n/** @type {typeof setTimeout} */\nexport function mockedSetTimeout(callback, ms, ...args) {\n    if (!allowTimers) {\n        return 0;\n    }\n\n    ms = parseNat(ms);\n\n    function handler() {\n        mockedClearTimeout(timeoutId);\n        return callback(...args);\n    }\n\n    const timeoutValues = [handler, now(), ms];\n    const timeoutId = frozen ? nextDummyId++ : setTimeout(handler, ms);\n    const internalId = timeoutToId(timeoutId);\n    timers.set(internalId, timeoutValues);\n\n    return timeoutId;\n}\n\nexport function resetTimeOffset() {\n    timeOffset = 0;\n}\n\n/**\n * Calculates the amount of time needed to run all current timeouts, intervals and\n * animations, and then advances the current time by that amount.\n *\n * @see {@link advanceTime}\n * @param {AdvanceTimeOptions} [options]\n * @returns {Promise<number>} time consumed by timers (in ms).\n */\nexport function runAllTimers(options) {\n    if (!timers.size) {\n        return 0;\n    }\n\n    const endts = $max(...[...timers.values()].map(([, init, delay]) => init + delay));\n    return advanceTime($ceil(endts - now()), options);\n}\n\n/**\n * Sets the current frame rate (in fps) used by animation frames (default to 60fps).\n *\n * @param {number} frameRate\n */\nexport function setFrameRate(frameRate) {\n    frameRate = parseNat(frameRate);\n    if (frameRate < 1 || frameRate > 1000) {\n        throw new HootTimingError(\"frame rate must be an number between 1 and 1000\");\n    }\n    frameDelay = 1000 / frameRate;\n}\n\nexport function setupTime() {\n    allowTimers = true;\n}\n\n/**\n * Returns a promise resolved after the next task tick.\n *\n * @returns {Promise<void>}\n */\nexport function tick() {\n    return delay();\n}\n\n/**\n * Returns a promise fulfilled when the given `predicate` returns a truthy value,\n * with the value of the promise being the return value of the `predicate`.\n *\n * The `predicate` is run once initially, and then on each animation frame until\n * it succeeds or fail.\n *\n * The promise automatically rejects after a given `timeout` (defaults to 5 seconds).\n *\n * @template T\n * @param {(last: boolean) => T} predicate\n * @param {WaitOptions} [options]\n * @returns {Promise<T>}\n * @example\n *  await waitUntil(() => []); // -> []\n * @example\n *  const button = await waitUntil(() => queryOne(\"button:visible\"));\n *  button.click();\n */\nexport async function waitUntil(predicate, options) {\n    await Promise.resolve();\n\n    // Early check before running the loop\n    const result = predicate(false);\n    if (result) {\n        return result;\n    }\n\n    const timeout = $floor(options?.timeout ?? 200);\n    const maxFrameCount = $ceil(timeout / frameDelay);\n    let frameCount = 0;\n    let handle;\n    return new Promise((resolve, reject) => {\n        function runCheck() {\n            const isLast = ++frameCount >= maxFrameCount;\n            const result = predicate(isLast);\n            if (result) {\n                resolve(result);\n            } else if (!isLast) {\n                handle = requestAnimationFrame(runCheck);\n            } else {\n                let message =\n                    options?.message || `'waitUntil' timed out after %timeout% milliseconds`;\n                if (typeof message === \"function\") {\n                    message = message();\n                }\n                if (isInstanceOf(message, Error)) {\n                    reject(message);\n                } else {\n                    reject(new HootTimingError(message.replace(\"%timeout%\", String(timeout))));\n                }\n            }\n        }\n\n        handle = requestAnimationFrame(runCheck);\n    }).finally(() => {\n        cancelAnimationFrame(handle);\n    });\n}\n\n/**\n * Manually resolvable and rejectable promise. It introduces 2 new methods:\n *  - {@link reject} rejects the deferred with the given reason;\n *  - {@link resolve} resolves the deferred with the given value.\n *\n * @template [T=unknown]\n */\nexport class Deferred extends Promise {\n    /** @type {typeof Promise.resolve<T>} */\n    _resolve;\n    /** @type {typeof Promise.reject<T>} */\n    _reject;\n\n    /**\n     * @param {(resolve: (value?: T) => any, reject: (reason?: any) => any) => any} [executor]\n     */\n    constructor(executor) {\n        let _resolve, _reject;\n\n        super(function deferredResolver(resolve, reject) {\n            _resolve = resolve;\n            _reject = reject;\n            executor?.(_resolve, _reject);\n        });\n\n        this._resolve = _resolve;\n        this._reject = _reject;\n    }\n\n    /**\n     * @param {any} [reason]\n     */\n    async reject(reason) {\n        return this._reject(reason);\n    }\n\n    /**\n     * @param {T} [value]\n     */\n    async resolve(value) {\n        return this._resolve(value);\n    }\n}\n", "/** @odoo-module alias=@odoo/hoot-dom default=false */\n\nimport * as dom from \"./helpers/dom\";\nimport * as events from \"./helpers/events\";\nimport * as time from \"./helpers/time\";\nimport { interactor } from \"./hoot_dom_utils\";\n\n/**\n * @typedef {import(\"./helpers/dom\").Dimensions} Dimensions\n * @typedef {import(\"./helpers/dom\").FormatXmlOptions} FormatXmlOptions\n * @typedef {import(\"./helpers/dom\").Position} Position\n * @typedef {import(\"./helpers/dom\").QueryOptions} QueryOptions\n * @typedef {import(\"./helpers/dom\").QueryRectOptions} QueryRectOptions\n * @typedef {import(\"./helpers/dom\").QueryTextOptions} QueryTextOptions\n * @typedef {import(\"./helpers/dom\").Target} Target\n *\n * @typedef {import(\"./helpers/events\").DragHelpers} DragHelpers\n * @typedef {import(\"./helpers/events\").DragOptions} DragOptions\n * @typedef {import(\"./helpers/events\").EventType} EventType\n * @typedef {import(\"./helpers/events\").FillOptions} FillOptions\n * @typedef {import(\"./helpers/events\").InputValue} InputValue\n * @typedef {import(\"./helpers/events\").KeyStrokes} KeyStrokes\n * @typedef {import(\"./helpers/events\").PointerOptions} PointerOptions\n */\n\nexport {\n    formatXml,\n    getActiveElement,\n    getFocusableElements,\n    getNextFocusableElement,\n    getParentFrame,\n    getPreviousFocusableElement,\n    isDisplayed,\n    isEditable,\n    isFocusable,\n    isInDOM,\n    isInViewPort,\n    isScrollable,\n    isVisible,\n    matches,\n    queryAll,\n    queryAllAttributes,\n    queryAllProperties,\n    queryAllRects,\n    queryAllTexts,\n    queryAllValues,\n    queryAny,\n    queryAttribute,\n    queryFirst,\n    queryOne,\n    queryRect,\n    queryText,\n    queryValue,\n} from \"./helpers/dom\";\nexport { on } from \"./helpers/events\";\nexport {\n    animationFrame,\n    cancelAllTimers,\n    Deferred,\n    delay,\n    freezeTime,\n    unfreezeTime,\n    microTick,\n    setFrameRate,\n    tick,\n    waitUntil,\n} from \"./helpers/time\";\n\n//-----------------------------------------------------------------------------\n// Interactors\n//-----------------------------------------------------------------------------\n\n// DOM\nexport const observe = interactor(\"query\", dom.observe);\nexport const waitFor = interactor(\"query\", dom.waitFor);\nexport const waitForNone = interactor(\"query\", dom.waitForNone);\n\n// Events\nexport const check = interactor(\"interaction\", events.check);\nexport const clear = interactor(\"interaction\", events.clear);\nexport const click = interactor(\"interaction\", events.click);\nexport const dblclick = interactor(\"interaction\", events.dblclick);\nexport const drag = interactor(\"interaction\", events.drag);\nexport const edit = interactor(\"interaction\", events.edit);\nexport const fill = interactor(\"interaction\", events.fill);\nexport const hover = interactor(\"interaction\", events.hover);\nexport const keyDown = interactor(\"interaction\", events.keyDown);\nexport const keyUp = interactor(\"interaction\", events.keyUp);\nexport const leave = interactor(\"interaction\", events.leave);\nexport const manuallyDispatchProgrammaticEvent = interactor(\"interaction\", events.dispatch);\nexport const middleClick = interactor(\"interaction\", events.middleClick);\nexport const pointerDown = interactor(\"interaction\", events.pointerDown);\nexport const pointerUp = interactor(\"interaction\", events.pointerUp);\nexport const press = interactor(\"interaction\", events.press);\nexport const resize = interactor(\"interaction\", events.resize);\nexport const rightClick = interactor(\"interaction\", events.rightClick);\nexport const scroll = interactor(\"interaction\", events.scroll);\nexport const select = interactor(\"interaction\", events.select);\nexport const setInputFiles = interactor(\"interaction\", events.setInputFiles);\nexport const setInputRange = interactor(\"interaction\", events.setInputRange);\nexport const uncheck = interactor(\"interaction\", events.uncheck);\nexport const unload = interactor(\"interaction\", events.unload);\n\n// Time\nexport const advanceFrame = interactor(\"time\", time.advanceFrame);\nexport const advanceTime = interactor(\"time\", time.advanceTime);\nexport const runAllTimers = interactor(\"time\", time.runAllTimers);\n\n// Debug\nexport { exposeHelpers } from \"./hoot_dom_utils\";\n", "/** @odoo-module */\n\n/**\n * @typedef {ArgumentPrimitive | `${ArgumentPrimitive}[]` | null} ArgumentType\n *\n * @typedef {\"any\"\n *  | \"bigint\"\n *  | \"boolean\"\n *  | \"error\"\n *  | \"function\"\n *  | \"integer\"\n *  | \"node\"\n *  | \"number\"\n *  | \"object\"\n *  | \"regex\"\n *  | \"string\"\n *  | \"symbol\"\n *  | \"undefined\"} ArgumentPrimitive\n *\n * @typedef {[string, string | undefined, any[], any]} InteractionDetails\n *\n * @typedef {\"interaction\" | \"query\" | \"server\" | \"time\"} InteractionType\n */\n\n/**\n * @template T\n * @typedef {T | Iterable<T>} MaybeIterable\n */\n\n/**\n * @template T\n * @typedef {T | PromiseLike<T>} MaybePromise\n */\n\n//-----------------------------------------------------------------------------\n// Global\n//-----------------------------------------------------------------------------\n\nconst {\n    Array: { isArray: $isArray },\n    matchMedia,\n    navigator: { userAgent: $userAgent },\n    Object: { assign: $assign, getPrototypeOf: $getPrototypeOf },\n    RegExp,\n    SyntaxError,\n} = globalThis;\nconst $toString = Object.prototype.toString;\n\n//-----------------------------------------------------------------------------\n// Internal\n//-----------------------------------------------------------------------------\n\n/**\n * @template {(...args: any[]) => any} T\n * @param {InteractionType} type\n * @param {T} fn\n * @param {string} name\n * @param {string} [alias]\n * @returns {T}\n */\nfunction makeInteractorFn(type, fn, name, alias) {\n    return {\n        [alias || name](...args) {\n            const result = fn(...args);\n            if (isInstanceOf(result, Promise)) {\n                for (let i = 0; i < args.length; i++) {\n                    if (isInstanceOf(args[i], Promise)) {\n                        // Get promise result for async arguments if possible\n                        args[i].then((result) => (args[i] = result));\n                    }\n                }\n                return result.then((promiseResult) =>\n                    dispatchInteraction(type, name, alias, args, promiseResult)\n                );\n            } else {\n                return dispatchInteraction(type, name, alias, args, result);\n            }\n        },\n    }[alias || name];\n}\n\nfunction polyfillIsError(value) {\n    return $toString.call(value) === \"[object Error]\";\n}\n\nconst GRAYS = {\n    100: \"#f1f5f9\",\n    200: \"#e2e8f0\",\n    300: \"#cbd5e1\",\n    400: \"#94a3b8\",\n    500: \"#64748b\",\n    600: \"#475569\",\n    700: \"#334155\",\n    800: \"#1e293b\",\n    900: \"#0f172a\",\n};\n\nconst COLORS = {\n    default: {\n        // Generic colors\n        black: \"#000000\",\n        white: \"#ffffff\",\n\n        // Grays\n        \"gray-100\": GRAYS[100],\n        \"gray-200\": GRAYS[200],\n        \"gray-300\": GRAYS[300],\n        \"gray-400\": GRAYS[400],\n        \"gray-500\": GRAYS[500],\n        \"gray-600\": GRAYS[600],\n        \"gray-700\": GRAYS[700],\n        \"gray-800\": GRAYS[800],\n        \"gray-900\": GRAYS[900],\n    },\n    light: {\n        // Generic colors\n        primary: \"#714b67\",\n        secondary: \"#74b4b9\",\n        amber: \"#f59e0b\",\n        \"amber-900\": \"#fef3c7\",\n        blue: \"#3b82f6\",\n        \"blue-900\": \"#dbeafe\",\n        cyan: \"#0891b2\",\n        \"cyan-900\": \"#e0f2fe\",\n        emerald: \"#047857\",\n        \"emerald-900\": \"#ecfdf5\",\n        gray: GRAYS[400],\n        lime: \"#84cc16\",\n        \"lime-900\": \"#f7fee7\",\n        orange: \"#ea580c\",\n        \"orange-900\": \"#ffedd5\",\n        purple: \"#581c87\",\n        \"purple-900\": \"#f3e8ff\",\n        rose: \"#9f1239\",\n        \"rose-900\": \"#fecdd3\",\n\n        // App colors\n        bg: GRAYS[100],\n        text: GRAYS[900],\n        \"status-bg\": GRAYS[300],\n        \"link-text-hover\": \"var(--primary)\",\n        \"btn-bg\": \"#714b67\",\n        \"btn-bg-hover\": \"#624159\",\n        \"btn-text\": \"#ffffff\",\n        \"bg-result\": \"rgba(255, 255, 255, 0.6)\",\n        \"border-result\": GRAYS[300],\n        \"border-search\": \"#d8dadd\",\n        \"shadow-opacity\": 0.1,\n\n        // HootReporting colors\n        \"bg-report\": \"#ffffff\",\n        \"text-report\": \"#202124\",\n        \"border-report\": \"#f0f0f0\",\n        \"bg-report-error\": \"#fff0f0\",\n        \"text-report-error\": \"#ff0000\",\n        \"border-report-error\": \"#ffd6d6\",\n        \"text-report-number\": \"#1a1aa6\",\n        \"text-report-string\": \"#c80000\",\n        \"text-report-key\": \"#881280\",\n        \"text-report-html-tag\": \"#881280\",\n        \"text-report-html-id\": \"#1a1aa8\",\n        \"text-report-html-class\": \"#994500\",\n    },\n    dark: {\n        // Generic colors\n        primary: \"#14b8a6\",\n        amber: \"#fbbf24\",\n        \"amber-900\": \"#422006\",\n        blue: \"#60a5fa\",\n        \"blue-900\": \"#172554\",\n        cyan: \"#22d3ee\",\n        \"cyan-900\": \"#083344\",\n        emerald: \"#34d399\",\n        \"emerald-900\": \"#064e3b\",\n        gray: GRAYS[500],\n        lime: \"#bef264\",\n        \"lime-900\": \"#365314\",\n        orange: \"#fb923c\",\n        \"orange-900\": \"#431407\",\n        purple: \"#a855f7\",\n        \"purple-900\": \"#3b0764\",\n        rose: \"#fb7185\",\n        \"rose-900\": \"#4c0519\",\n\n        // App colors\n        bg: GRAYS[900],\n        text: GRAYS[100],\n        \"status-bg\": GRAYS[700],\n        \"btn-bg\": \"#00dac5\",\n        \"btn-bg-hover\": \"#00c1ae\",\n        \"btn-text\": \"#000000\",\n        \"bg-result\": \"rgba(0, 0, 0, 0.5)\",\n        \"border-result\": GRAYS[600],\n        \"border-search\": \"#3c3f4c\",\n        \"shadow-opacity\": 0.4,\n\n        // HootReporting colors\n        \"bg-report\": \"#202124\",\n        \"text-report\": \"#e8eaed\",\n        \"border-report\": \"#3a3a3a\",\n        \"bg-report-error\": \"#290000\",\n        \"text-report-error\": \"#ff8080\",\n        \"border-report-error\": \"#5c0000\",\n        \"text-report-number\": \"#9980ff\",\n        \"text-report-string\": \"#f28b54\",\n        \"text-report-key\": \"#5db0d7\",\n        \"text-report-html-tag\": \"#5db0d7\",\n        \"text-report-html-id\": \"#f29364\",\n        \"text-report-html-class\": \"#9bbbdc\",\n    },\n};\nconst DEBUG_NAMESPACE = \"hoot\";\n\nconst isError = typeof Error.isError === \"function\" ? Error.isError : polyfillIsError;\nconst interactionBus = new EventTarget();\nconst preferredColorScheme = matchMedia(\"(prefers-color-scheme: dark)\").matches ? \"dark\" : \"light\";\n\n//-----------------------------------------------------------------------------\n// Exports\n//-----------------------------------------------------------------------------\n\n/**\n * @param {Iterable<InteractionType>} types\n * @param {(event: CustomEvent<InteractionDetails>) => any} callback\n */\nexport function addInteractionListener(types, callback) {\n    for (const type of types) {\n        interactionBus.addEventListener(type, callback);\n    }\n\n    return function removeInteractionListener() {\n        for (const type of types) {\n            interactionBus.removeEventListener(type, callback);\n        }\n    };\n}\n\n/**\n * @param {InteractionType} type\n * @param {string} name\n * @param {string | undefined} alias\n * @param {any[]} args\n * @param {any} returnValue\n */\nexport function dispatchInteraction(type, name, alias, args, returnValue) {\n    interactionBus.dispatchEvent(\n        new CustomEvent(type, {\n            detail: [name, alias, args, returnValue],\n        })\n    );\n    return returnValue;\n}\n\n/**\n * @param {...any} helpers\n */\nexport function exposeHelpers(...helpers) {\n    let nameSpaceIndex = 1;\n    let nameSpace = DEBUG_NAMESPACE;\n    while (nameSpace in globalThis) {\n        nameSpace = `${DEBUG_NAMESPACE}${nameSpaceIndex++}`;\n    }\n    globalThis[nameSpace] = new HootDebugHelpers(...helpers);\n    return nameSpace;\n}\n\n/**\n * @param {keyof typeof COLORS} [scheme]\n */\nexport function getAllColors(scheme) {\n    return scheme ? COLORS[scheme] : COLORS;\n}\n\n/**\n * @param {keyof typeof COLORS[\"light\"]} varName\n */\nexport function getColorHex(varName) {\n    return COLORS[preferredColorScheme][varName];\n}\n\nexport function getPreferredColorScheme() {\n    return preferredColorScheme;\n}\n\n/**\n * @param {Node} node\n */\nexport function getTag(node) {\n    return node?.nodeName?.toLowerCase() || \"\";\n}\n\n/**\n * @template {(...args: any[]) => any} T\n * @param {InteractionType} type\n * @param {T} fn\n * @returns {T & {\n *  as: (name: string) => T;\n *  readonly silent: T;\n * }}\n */\nexport function interactor(type, fn) {\n    return $assign(makeInteractorFn(type, fn, fn.name), {\n        as(alias) {\n            return makeInteractorFn(type, fn, fn.name, alias);\n        },\n        get silent() {\n            return fn;\n        },\n    });\n}\n\n/**\n * @returns {boolean}\n */\nexport function isFirefox() {\n    return /firefox/i.test($userAgent);\n}\n\n/**\n * Cross-realm equivalent to 'instanceof'.\n * Can be called with multiple constructors, and will return true if the given object\n * is an instance of any of them.\n *\n * @param {unknown} instance\n * @param {...{ name: string }} classes\n */\nexport function isInstanceOf(instance, ...classes) {\n    if (!classes.length) {\n        return instance instanceof classes[0];\n    }\n    if (!instance || Object(instance) !== instance) {\n        // Object is falsy or a primitive (null, undefined and primitives cannot be the instance of anything)\n        return false;\n    }\n    for (const cls of classes) {\n        if (instance instanceof cls) {\n            return true;\n        }\n        const targetName = cls.name;\n        if (!targetName) {\n            return false;\n        }\n        if (targetName === \"Array\") {\n            return $isArray(instance);\n        }\n        if (targetName === \"Error\") {\n            return isError(instance);\n        }\n        if ($toString.call(instance) === `[object ${targetName}]`) {\n            return true;\n        }\n        let { constructor } = instance;\n        while (constructor) {\n            if (constructor.name === targetName) {\n                return true;\n            }\n            constructor = $getPrototypeOf(constructor);\n        }\n    }\n    return false;\n}\n\n/**\n * Returns whether the given object is iterable (*excluding strings*).\n *\n * @template T\n * @template {T | Iterable<T>} V\n * @param {V} object\n * @returns {V extends Iterable<T> ? true : false}\n */\nexport function isIterable(object) {\n    return !!(object && typeof object === \"object\" && object[Symbol.iterator]);\n}\n\n/**\n * @param {string} value\n * @param {{ safe?: boolean }} [options]\n * @returns {string | RegExp}\n */\nexport function parseRegExp(value, options) {\n    const regexParams = value.match(R_REGEX);\n    if (regexParams) {\n        const unified = regexParams[1].replace(R_WHITE_SPACE, \"\\\\s+\");\n        const flag = regexParams[2];\n        try {\n            return new RegExp(unified, flag);\n        } catch (error) {\n            if (isInstanceOf(error, SyntaxError) && options?.safe) {\n                return value;\n            } else {\n                throw error;\n            }\n        }\n    }\n    return value;\n}\n\n/**\n * @param {Node} node\n * @param {{ raw?: boolean }} [options]\n */\nexport function toSelector(node, options) {\n    const tagName = getTag(node);\n    const id = node.id ? `#${node.id}` : \"\";\n    const classNames = node.classList\n        ? [...node.classList].map((className) => `.${className}`)\n        : [];\n    if (options?.raw) {\n        return { tagName, id, classNames };\n    } else {\n        return [tagName, id, ...classNames].join(\"\");\n    }\n}\n\nexport class HootDebugHelpers {\n    /**\n     * @param {...any} helpers\n     */\n    constructor(...helpers) {\n        $assign(this, ...helpers);\n    }\n}\n\nexport const REGEX_MARKER = \"/\";\n\n// Common regular expressions\nexport const R_REGEX = new RegExp(`^${REGEX_MARKER}(.*)${REGEX_MARKER}([dgimsuvy]+)?$`);\nexport const R_WHITE_SPACE = /\\s+/g;\n", "import { session } from \"@web/session\";\nimport { utils } from \"@web/core/ui/ui_service\";\nimport * as hoot from \"@odoo/hoot-dom\";\nimport { pick } from \"@web/core/utils/objects\";\n\n/**\n * @typedef TourStep\n * @property {\"enterprise\"|\"community\"|\"mobile\"|\"desktop\"|HootSelector[][]} isActive Active the step following {@link isActiveStep} filter\n * @property {string} [id]\n * @property {HootSelector} trigger The node on which the action will be executed.\n * @property {string} [content] Description of the step.\n * @property {\"top\" | \"bottom\" | \"left\" | \"right\"} [position] The position where the UI helper is shown.\n * @property {RunCommand} [run] The action to perform when trigger conditions are verified.\n * @property {number} [timeout] By default, when the trigger node isn't found after 10000 milliseconds, it throws an error.\n * You can change this value to lengthen or shorten the time before the error occurs [ms].\n */\nexport class TourStep {\n    constructor(data, tour) {\n        Object.assign(this, data);\n        this.tour = tour;\n    }\n\n    /**\n     * Check if a step is active dependant on step.isActive property\n     * Note that when step.isActive is not defined, the step is active by default.\n     * When a step is not active, it's just skipped and the tour continues to the next step.\n     */\n    get active() {\n        this.checkHasTour();\n        const mode = this.tour.mode;\n        const isSmall = utils.isSmall();\n        const standardKeyWords = [\"enterprise\", \"community\", \"mobile\", \"desktop\", \"auto\", \"manual\"];\n        const isActiveArray = Array.isArray(this.isActive) ? this.isActive : [];\n        if (isActiveArray.length === 0) {\n            return true;\n        }\n        const selectors = isActiveArray.filter((key) => !standardKeyWords.includes(key));\n        if (selectors.length) {\n            // if one of selectors is not found, step is skipped\n            for (const selector of selectors) {\n                const el = hoot.queryFirst(selector);\n                if (!el) {\n                    return false;\n                }\n            }\n        }\n        const checkMode =\n            isActiveArray.includes(mode) ||\n            (!isActiveArray.includes(\"manual\") && !isActiveArray.includes(\"auto\"));\n        const edition =\n            (session.server_version_info || \"\").at(-1) === \"e\" ? \"enterprise\" : \"community\";\n        const checkEdition =\n            isActiveArray.includes(edition) ||\n            (!isActiveArray.includes(\"enterprise\") && !isActiveArray.includes(\"community\"));\n        const onlyForMobile = isActiveArray.includes(\"mobile\") && isSmall;\n        const onlyForDesktop = isActiveArray.includes(\"desktop\") && !isSmall;\n        const checkDevice =\n            onlyForMobile ||\n            onlyForDesktop ||\n            (!isActiveArray.includes(\"mobile\") && !isActiveArray.includes(\"desktop\"));\n        return checkEdition && checkDevice && checkMode;\n    }\n\n    checkHasTour() {\n        if (!this.tour) {\n            throw new Error(`TourStep instance must have a tour`);\n        }\n    }\n\n    get describeMe() {\n        this.checkHasTour();\n        return (\n            `[${this.index + 1}/${this.tour.steps.length}] Tour ${this.tour.name} \u2192 Step ` +\n            (this.content ? `${this.content} (trigger: ${this.trigger})` : this.trigger)\n        );\n    }\n\n    get stringify() {\n        return (\n            JSON.stringify(\n                pick(\n                    this,\n                    \"isActive\",\n                    \"content\",\n                    \"trigger\",\n                    \"run\",\n                    \"tooltipPosition\",\n                    \"timeout\",\n                    \"expectUnloadPage\"\n                ),\n                (_key, value) => {\n                    if (typeof value === \"function\") {\n                        return \"[function]\";\n                    } else {\n                        return value;\n                    }\n                },\n                2\n            ) + \",\"\n        );\n    }\n}\n", "import * as hootDom from \"@odoo/hoot-dom\";\nimport { enableEventLogs, setupEventActions } from \"@web/../lib/hoot-dom/helpers/events\";\nimport { browser } from \"@web/core/browser/browser\";\nimport { Macro } from \"@web/core/macro\";\nimport { config as transitionConfig } from \"@web/core/transition\";\nimport { TourStepAutomatic } from \"@web_tour/js/tour_automatic/tour_step_automatic\";\nimport { tourState } from \"@web_tour/js/tour_state\";\n\nexport class TourAutomatic {\n    mode = \"auto\";\n    allowUnload = true;\n    constructor(data) {\n        Object.assign(this, data);\n        this.steps = this.steps.map((step, index) => new TourStepAutomatic(step, this, index));\n        this.config = tourState.getCurrentConfig() || {};\n    }\n\n    get currentIndex() {\n        return tourState.getCurrentIndex();\n    }\n\n    get currentStep() {\n        return this.steps[this.currentIndex];\n    }\n\n    get debugMode() {\n        return this.config.debug !== false;\n    }\n\n    start() {\n        setupEventActions(document.createElement(\"div\"), { allowSubmit: true });\n        enableEventLogs(this.debugMode);\n        const { delayToCheckUndeterminisms, stepDelay } = this.config;\n        const macroSteps = this.steps\n            .filter((step) => step.index >= this.currentIndex)\n            .flatMap((step) => [\n                {\n                    action: async () => {\n                        if (this.debugMode) {\n                            console.groupCollapsed(step.describeMe);\n                            console.log(step.stringify);\n                            if (stepDelay > 0) {\n                                await hootDom.delay(stepDelay);\n                            }\n                            if (step.break) {\n                                // eslint-disable-next-line no-debugger\n                                debugger;\n                            }\n                        } else {\n                            console.log(step.describeMe);\n                        }\n                    },\n                },\n                {\n                    trigger: step.trigger ? () => step.findTrigger() : null,\n                    timeout:\n                        step.pause && this.debugMode\n                            ? 9999999\n                            : step.timeout || this.timeout || 10000,\n                    action: async (trigger) => {\n                        if (delayToCheckUndeterminisms > 0) {\n                            await step.checkForUndeterminisms(trigger, delayToCheckUndeterminisms);\n                        }\n                        this.allowUnload = false;\n                        if (!step.skipped && step.expectUnloadPage) {\n                            this.allowUnload = true;\n                            setTimeout(() => {\n                                const message = `\n                                    The key { expectUnloadPage } is defined but page has not been unloaded within 20000 ms.\n                                    You probably don't need it.\n                                `.replace(/^\\s+/gm, \"\");\n                                this.throwError(message);\n                            }, 20000);\n                        }\n                        await step.doAction();\n                        if (this.debugMode) {\n                            console.log(trigger);\n                            if (step.skipped) {\n                                console.log(\"This step has been skipped\");\n                            } else {\n                                console.log(\"This step has run successfully\");\n                            }\n                            console.groupEnd();\n                            if (step.pause) {\n                                await this.pause();\n                            }\n                        }\n                        tourState.setCurrentIndex(step.index + 1);\n                        if (this.allowUnload) {\n                            return \"StopTheMacro!\";\n                        }\n                    },\n                },\n            ]);\n\n        const end = () => {\n            delete window[hootNameSpace];\n            transitionConfig.disabled = false;\n            tourState.clear();\n            //No need to catch error yet.\n            window.addEventListener(\n                \"error\",\n                (ev) => {\n                    ev.preventDefault();\n                    ev.stopImmediatePropagation();\n                },\n                true\n            );\n            window.addEventListener(\n                \"unhandledrejection\",\n                (ev) => {\n                    ev.preventDefault();\n                    ev.stopImmediatePropagation();\n                },\n                true\n            );\n        };\n\n        this.macro = new Macro({\n            name: this.name,\n            steps: macroSteps,\n            onError: ({ error }) => {\n                if (error.type === \"Timeout\") {\n                    this.throwError(...this.currentStep.describeWhyIFailed, error.message);\n                } else {\n                    this.throwError(error.message);\n                }\n                end();\n            },\n            onComplete: () => {\n                browser.console.log(\"tour succeeded\");\n                // Used to see easily in the python console and to know which tour has been succeeded in suite tours case.\n                const succeeded = `\u2551 TOUR ${this.name} SUCCEEDED \u2551`;\n                const msg = [succeeded];\n                msg.unshift(\"\u2554\" + \"\u2550\".repeat(succeeded.length - 2) + \"\u2557\");\n                msg.push(\"\u255a\" + \"\u2550\".repeat(succeeded.length - 2) + \"\u255d\");\n                browser.console.log(`\\n\\n${msg.join(\"\\n\")}\\n`);\n                end();\n            },\n        });\n\n        const beforeUnloadHandler = () => {\n            if (!this.allowUnload) {\n                const message = `\n                    Be sure to use { expectUnloadPage: true } for any step\n                    that involves firing a beforeUnload event.\n                    This avoid a non-deterministic behavior by explicitly stopping\n                    the tour that might continue before the page is unloaded.\n                `.replace(/^\\s+/gm, \"\");\n                this.throwError(message);\n            }\n        };\n        window.addEventListener(\"beforeunload\", beforeUnloadHandler);\n\n        if (this.debugMode && this.currentIndex === 0) {\n            // Starts the tour with a debugger to allow you to choose devtools configuration.\n            // eslint-disable-next-line no-debugger\n            debugger;\n        }\n        transitionConfig.disabled = true;\n        const hootNameSpace = hootDom.exposeHelpers(hootDom);\n        console.debug(`Hoot DOM helpers available from \\`window.${hootNameSpace}\\``);\n        this.macro.start();\n    }\n\n    get describeWhereIFailed() {\n        const offset = 3;\n        const start = Math.max(this.currentIndex - offset, 0);\n        const end = Math.min(this.currentIndex + offset, this.steps.length - 1);\n        const result = [];\n        for (let i = start; i <= end; i++) {\n            const step = this.steps[i];\n            const stepString = step.stringify;\n            const text = [stepString];\n            if (i === this.currentIndex) {\n                const line = \"-\".repeat(10);\n                const failing_step = `${line} FAILED: ${step.describeMe} ${line}`;\n                text.unshift(failing_step);\n                text.push(\"-\".repeat(failing_step.length));\n            }\n            result.push(...text);\n        }\n        return result.join(\"\\n\");\n    }\n\n    /**\n     * @param {string} [error]\n     */\n    throwError(...args) {\n        console.groupEnd();\n        tourState.setCurrentTourOnError();\n        // console.error notifies the test runner that the tour failed.\n        browser.console.error([`FAILED: ${this.currentStep.describeMe}.`, ...args].join(\"\\n\"));\n        // The logged text shows the relative position of the failed step.\n        // Useful for finding the failed step.\n        browser.console.dir(this.describeWhereIFailed);\n        if (this.debugMode) {\n            // eslint-disable-next-line no-debugger\n            debugger;\n        }\n    }\n\n    async pause() {\n        const styles = [\n            \"background: black; color: white; font-size: 14px\",\n            \"background: black; color: orange; font-size: 14px\",\n        ];\n        console.log(\n            `%cTour is paused. Use %cplay()%c to continue.`,\n            styles[0],\n            styles[1],\n            styles[0]\n        );\n        await new Promise((resolve) => {\n            window.play = () => {\n                resolve();\n                delete window.play;\n            };\n        });\n    }\n}\n", "import * as hoot from \"@odoo/hoot-dom\";\nimport { patch } from \"@web/core/utils/patch\";\nimport { TourHelpers } from \"./tour_helpers\";\n\npatch(TourHelpers.prototype, {\n    /**\n     * Ensures that the given {@link Selector} is checked.\n     * @description\n     * If it is not checked, a click is triggered on the input.\n     * If the input is still not checked after the click, an error is thrown.\n     *\n     * @param {string|Node} selector\n     * @example\n     *  run: \"check\", //Checks the action element\n     * @example\n     *  run: \"check input[type=checkbox]\", // Checks the selector\n     */\n    async check(selector) {\n        const element = this._get_action_element(selector);\n        await hoot.check(element);\n    },\n\n    /**\n     * Clears the **value** of the **{@link Selector}**.\n     * @description\n     * This is done using the following sequence:\n     * - pressing \"Control\" + \"A\" to select the whole value;\n     * - pressing \"Backspace\" to delete the value;\n     * - (optional) triggering a \"change\" event by pressing \"Enter\".\n     *\n     * @param {Selector} selector\n     * @example\n     *  run: \"clear\", // Clears the value of the action element\n     * @example\n     *  run: \"clear input#my_input\", // Clears the value of the selector\n     */\n    async clear(selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        await hoot.clear();\n    },\n\n    /**\n     * Performs a click sequence on the given **{@link Selector}**\n     * @description Let's see more informations about click sequence here: {@link hoot.click}\n     * @param {Selector} selector\n     * @param {import(\"@odoo/hoot-dom\").PointerOptions} options\n     * @example\n     *  run: \"click\", // Click on the action element\n     * @example\n     *  run: \"click .o_rows:first\", // Click on the selector\n     */\n    async click(selector, options = { interactive: false }) {\n        const element = this._get_action_element(selector);\n        // FIXME: should always target interactive element, but some tour steps are\n        // targetting elements affected by 'pointer-events: none' for some reason.\n        // This option should ultimately disappear, with all affected cased fixed\n        // individually (no common cause found during a quick investigation).\n        await hoot.click(element, options);\n    },\n\n    /**\n     * Performs two click sequences on the given **{@link Selector}**.\n     * @description Let's see more informations about click sequence here: {@link hoot.dblclick}\n     * @param {Selector} selector\n     * @example\n     *  run: \"dblclick\", // Double click on the action element\n     * @example\n     *  run: \"dblclick .o_rows:first\", // Double click on the selector\n     */\n    async dblclick(selector) {\n        const element = this._get_action_element(selector);\n        await hoot.dblclick(element);\n    },\n\n    /**\n     * Starts a drag sequence on the active element (anchor) and drop it on the given **{@link Selector}**.\n     * @param {Selector} selector\n     * @param {hoot.PointerOptions} options\n     * @example\n     *  run: \"drag_and_drop .o_rows:first\", // Drag the active element and drop it in the selector\n     * @example\n     *  async run(helpers) {\n     *      await helpers.drag_and_drop(\".o_rows:first\", {\n     *          position: {\n     *              top: 40,\n     *              left: 5,\n     *          },\n     *          relative: true,\n     *      });\n     *  }\n     */\n    async drag_and_drop(selector, options) {\n        if (typeof options !== \"object\") {\n            options = { position: \"top\", relative: true };\n        }\n        const dragEffectDelay = async () => {\n            await hoot.animationFrame();\n            await hoot.delay(this.delay);\n        };\n\n        const element = this.anchor;\n        const { drop, moveTo } = await hoot.drag(element);\n        await dragEffectDelay();\n        await hoot.hover(element, {\n            position: {\n                top: 20,\n                left: 20,\n            },\n            relative: true,\n        });\n        await dragEffectDelay();\n        const target = await hoot.waitFor(selector, {\n            visible: true,\n            timeout: 1000,\n        });\n        await moveTo(target, options);\n        await dragEffectDelay();\n        await drop(target, options);\n        await dragEffectDelay();\n    },\n\n    /**\n     * Edit input or textarea given by **{@link selector}**\n     * @param {string} text\n     * @param {Selector} selector\n     * @example\n     *  run: \"edit Hello Mr. Doku\",\n     */\n    async edit(text, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        await hoot.edit(text);\n    },\n\n    /**\n     * Edit only editable wysiwyg element given by **{@link Selector}**\n     * @param {string} text\n     * @param {Selector} selector\n     */\n    async editor(text, selector) {\n        const element = this._get_action_element(selector);\n        const InEditor = Boolean(element.closest(\".odoo-editor-editable\"));\n        if (!InEditor) {\n            throw new Error(\"run 'editor' always on an element in an editor\");\n        }\n        await hoot.click(element);\n        this._set_range(element, \"start\");\n        await hoot.keyDown(\"_\");\n        element.textContent = text;\n        await hoot.manuallyDispatchProgrammaticEvent(element, \"input\");\n        this._set_range(element, \"stop\");\n        await hoot.keyUp(\"_\");\n        await hoot.manuallyDispatchProgrammaticEvent(element, \"change\");\n    },\n\n    /**\n     * Fills the **{@link Selector}** with the given `value`.\n     * @description This helper is intended for `<input>` and `<textarea>` elements,\n     * with the exception of `\"checkbox\"` and `\"radio\"` types, which should be\n     * selected using the {@link check} helper.\n     * In tour, it's mainly usefull for autocomplete components.\n     * @param {string} value\n     * @param {Selector} selector\n     */\n    async fill(value, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        await hoot.fill(value);\n    },\n\n    /**\n     * Performs a hover sequence on the given **{@link Selector}**.\n     * @param {Selector} selector\n     * @param {import(\"@odoo/hoot-dom\").PointerOptions} options\n     * @example\n     *  run: \"hover\",\n     */\n    async hover(selector, options) {\n        const element = this._get_action_element(selector);\n        await hoot.hover(element, options);\n    },\n\n    /**\n     * Only for input[type=\"range\"]\n     * @param {string|number} value\n     * @param {Selector} selector\n     */\n    async range(value, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        await hoot.setInputRange(element, value);\n    },\n\n    /**\n     * Performs a keyboard event sequence.\n     * @example\n     *  run : \"press Enter\",\n     */\n    async press(...args) {\n        await hoot.press(args.flatMap((arg) => typeof arg === \"string\" && arg.split(\"+\")));\n    },\n\n    /**\n     * Performs a selection event sequence on **{@link Selector}**. This helper is intended\n     * for `<select>` elements only.\n     * @description Select the option by its value\n     * @param {string} value\n     * @param {Selector} selector\n     * @example\n     * run(helpers) => {\n     *  helpers.select(\"Kevin17\", \"select#mySelect\");\n     * },\n     * @example\n     * run: \"select Foden47\",\n     */\n    async select(value, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        await hoot.select(value, { target: element });\n    },\n\n    /**\n     * Performs a selection event sequence on **{@link Selector}**\n     * @description Select the option by its index\n     * @param {number} index starts at 0\n     * @param {Selector} selector\n     * @example\n     *  run: \"selectByIndex 2\", //Select the third option\n     */\n    async selectByIndex(index, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        const value = hoot.queryValue(`option:eq(${index})`, { root: element });\n        if (value) {\n            await hoot.select(value, { target: element });\n            await hoot.manuallyDispatchProgrammaticEvent(element, \"input\");\n        }\n    },\n\n    /**\n     * Performs a selection event sequence on **{@link Selector}**\n     * @description Select option(s) by there labels\n     * @param {string|RegExp} contains\n     * @param {Selector} selector\n     * @example\n     *  run: \"selectByLabel Jeremy Doku\", //Select all options where label contains Jeremy Doku\n     */\n    async selectByLabel(contains, selector) {\n        const element = this._get_action_element(selector);\n        await hoot.click(element);\n        const values = hoot.queryAllValues(`option:contains(${contains})`, { root: element });\n        await hoot.select(values, { target: element });\n    },\n\n    /**\n     * Ensures that the given {@link Selector} is unchecked.\n     * @description\n     * If it is checked, a click is triggered on the input.\n     * If the input is still checked after the click, an error is thrown.\n     *\n     * @param {string|Node} selector\n     * @example\n     *  run: \"uncheck\", // Unchecks the action element\n     * @example\n     *  run: \"uncheck input[type=checkbox]\", // Unchecks the selector\n     */\n    async uncheck(selector) {\n        const element = this._get_action_element(selector);\n        await hoot.uncheck(element);\n    },\n\n    /**\n     * Navigate to {@link url}.\n     *\n     * @param {string} url\n     * @example\n     *  run: \"goToUrl /shop\", // Go to /shop\n     */\n    async goToUrl(url) {\n        const linkEl = document.createElement(\"a\");\n        linkEl.href = url;\n        await hoot.click(linkEl);\n    },\n\n    /**\n     * Ensures that the given canvas selector **{@link Selector}** contains pixels.\n     * @param {string|Node} selector\n     */\n    async canvasNotEmpty(selector) {\n        const canvas = this._get_action_element(selector);\n        if (canvas.tagName.toLowerCase() !== \"canvas\") {\n            throw new Error(`canvasNotEmpty is only suitable for canvas elements.`);\n        }\n        await hoot.waitUntil(() => {\n            const context = canvas.getContext(\"2d\");\n            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n            const pixels = new Uint32Array(imageData.data.buffer);\n            return pixels.some((pixel) => pixel !== 0); // pixel is on\n        });\n    },\n\n    /**\n     * Get Node for **{@link Selector}**\n     * @param {Selector} selector\n     * @returns {Node}\n     * @default this.anchor\n     */\n    _get_action_element(selector) {\n        if (typeof selector === \"string\" && selector.length) {\n            const nodes = hoot.queryAll(selector);\n            return nodes.find(hoot.isVisible) || nodes.at(0);\n        } else if (typeof selector === \"object\" && Boolean(selector?.nodeType)) {\n            return selector;\n        }\n        return this.anchor;\n    },\n\n    // Useful for wysiwyg editor.\n    _set_range(element, start_or_stop) {\n        function _node_length(node) {\n            if (node.nodeType === Node.TEXT_NODE) {\n                return node.nodeValue.length;\n            } else {\n                return node.childNodes.length;\n            }\n        }\n        const selection = element.ownerDocument.getSelection();\n        selection.removeAllRanges();\n        const range = new Range();\n        let node = element;\n        let length = 0;\n        if (start_or_stop === \"start\") {\n            while (node.firstChild) {\n                node = node.firstChild;\n            }\n        } else {\n            while (node.lastChild) {\n                node = node.lastChild;\n            }\n            length = _node_length(node);\n        }\n        range.setStart(node, length);\n        range.setEnd(node, length);\n        selection.addRange(range);\n    },\n\n    queryAll(target, options) {\n        return hoot.queryAll(target, options);\n    },\n\n    queryFirst(target, options) {\n        return hoot.queryFirst(target, options);\n    },\n\n    queryOne(target, options) {\n        return hoot.queryOne(target, options);\n    },\n\n    waitFor(target, options) {\n        return hoot.waitFor(target, options);\n    },\n\n    waitUntil(predicate, options) {\n        return hoot.waitUntil(predicate, options);\n    },\n\n    animationFrame(...args) {\n        return hoot.animationFrame(...args);\n    },\n});\n", "import { tourState } from \"@web_tour/js/tour_state\";\nimport * as hoot from \"@odoo/hoot-dom\";\nimport { serializeChanges, serializeMutation } from \"@web_tour/js/utils/tour_utils\";\nimport { TourHelpers } from \"@web_tour/js/tour_automatic/tour_helpers\";\nimport { TourStep } from \"@web_tour/js/tour_step\";\nimport { getTag } from \"@web/core/utils/xml\";\nimport { MacroMutationObserver } from \"@web/core/macro\";\n\nasync function waitForMutations(target = document, timeout = 1000 / 16) {\n    return new Promise((resolve) => {\n        let observer;\n        let timer;\n        const mutationList = [];\n        function onMutation(mutations) {\n            mutationList.push(...(mutations || []));\n            clearTimeout(timer);\n            timer = setTimeout(() => {\n                observer.disconnect();\n                resolve(mutationList);\n            }, timeout);\n        }\n        observer = new MacroMutationObserver(onMutation);\n        observer.observe(target);\n        onMutation([]);\n    });\n}\nexport class TourStepAutomatic extends TourStep {\n    skipped = false;\n    error = \"\";\n    constructor(data, tour, index) {\n        super(data, tour);\n        this.index = index;\n        this.tourConfig = tourState.getCurrentConfig();\n    }\n\n    async checkForUndeterminisms(initialElement, delay) {\n        if (delay <= 0 || !initialElement) {\n            return;\n        }\n        const tagName = initialElement.tagName?.toLowerCase();\n        if ([\"body\", \"html\"].includes(tagName) || !tagName) {\n            return;\n        }\n        const snapshot = initialElement.cloneNode(true);\n        const mutations = await waitForMutations(initialElement, delay);\n        let reason;\n        if (!hoot.isVisible(initialElement)) {\n            reason = `Initial element is no longer visible`;\n        } else if (!initialElement.isEqualNode(snapshot)) {\n            reason =\n                `Initial element has changed:\\n` +\n                JSON.stringify(serializeChanges(snapshot, initialElement), null, 2);\n        } else if (mutations.length) {\n            const changes = [...new Set(mutations.map(serializeMutation))];\n            reason =\n                `Initial element has mutated ${mutations.length} times:\\n` +\n                JSON.stringify(changes, null, 2);\n        }\n        if (reason) {\n            throw new Error(\n                `Potential non deterministic behavior found in ${delay}ms for trigger ${this.trigger}.\\n${reason}`\n            );\n        }\n    }\n\n    get describeWhyIFailed() {\n        const errors = [];\n        if (this.element) {\n            errors.push(`Element has been found.`);\n            if (this.isUIBlocked) {\n                errors.push(\"BUT: DOM is blocked by UI.\");\n            }\n            if (!this.elementIsInModal) {\n                errors.push(\n                    `BUT: It is not allowed to do action on an element that's below a modal.`\n                );\n            }\n            if (!this.elementIsEnabled) {\n                errors.push(\n                    `BUT: Element is not enabled. TIP: You can use :enable to wait the element is enabled before doing action on it.`\n                );\n            }\n            if (!this.parentFrameIsReady) {\n                errors.push(`BUT: parent frame is not ready ([is-ready='false']).`);\n            }\n        } else {\n            const checkElement = hoot.queryFirst(this.trigger);\n            if (checkElement) {\n                errors.push(`Element has been found.`);\n                errors.push(\n                    `BUT: Element is not visible. TIP: You can use :not(:visible) to force the search for an invisible element.`\n                );\n            } else {\n                errors.push(`Element (${this.trigger}) has not been found.`);\n            }\n        }\n        return errors;\n    }\n\n    /**\n     * When return null or false, macro continues.\n     */\n    async doAction() {\n        if (this.skipped) {\n            return false;\n        }\n        const actionHelper = new TourHelpers(this.element);\n        if (typeof this.run === \"function\") {\n            return await this.run.call({ anchor: this.element }, actionHelper);\n        } else if (typeof this.run === \"string\") {\n            let lastResult = null;\n            for (const todo of this.run.split(\"&&\")) {\n                const m = String(todo)\n                    .trim()\n                    .match(/^(?<action>\\w*) *\\(? *(?<arguments>.*?)\\)?$/);\n                lastResult = await actionHelper[m.groups?.action](m.groups?.arguments);\n            }\n            return lastResult;\n        }\n    }\n\n    /**\n     * Each time it returns false, tour engine wait for a mutation\n     * to retry to find the trigger.\n     * @returns {(HTMLElement|Boolean)}\n     */\n    findTrigger() {\n        if (!this.active) {\n            this.skipped = true;\n            return true;\n        }\n        const visible = !/:(hidden|visible)\\b/.test(this.trigger);\n        this.element = hoot.queryFirst(this.trigger, { visible });\n        if (this.element) {\n            return !this.isUIBlocked &&\n                this.elementIsEnabled &&\n                this.elementIsInModal &&\n                this.parentFrameIsReady\n                ? this.element\n                : false;\n        }\n        return false;\n    }\n\n    get isUIBlocked() {\n        return (\n            document.body.classList.contains(\"o_ui_blocked\") ||\n            document.querySelector(\".o_blockUI\") ||\n            document.querySelector(\".o_is_blocked\")\n        );\n    }\n\n    get parentFrameIsReady() {\n        if (this.trigger.match(/\\[is-ready=(true|false)\\]/)) {\n            return true;\n        }\n        const parentFrame = hoot.getParentFrame(this.element);\n        return parentFrame && parentFrame.contentDocument.body.hasAttribute(\"is-ready\")\n            ? parentFrame.contentDocument.body.getAttribute(\"is-ready\") === \"true\"\n            : true;\n    }\n\n    get elementIsInModal() {\n        if (this.hasAction) {\n            const overlays = hoot.queryFirst(\n                \".popover, .o-we-command, .o-we-toolbar, .o_notification\"\n            );\n            const modal = hoot.queryFirst(\".modal:visible:not(.o_inactive_modal):last\");\n            if (modal && !overlays && !this.trigger.startsWith(\"body\")) {\n                return (\n                    modal.contains(hoot.getParentFrame(this.element)) ||\n                    modal.contains(this.element)\n                );\n            }\n        }\n        return true;\n    }\n\n    get elementIsEnabled() {\n        const isTag = (array) => array.includes(getTag(this.element, true));\n        if (this.hasAction) {\n            if (isTag([\"input\", \"textarea\"])) {\n                return hoot.isEditable(this.element);\n            } else if (isTag([\"button\", \"select\"])) {\n                return !this.element.disabled;\n            }\n        }\n        return true;\n    }\n\n    get hasAction() {\n        return [\"string\", \"function\"].includes(typeof this.run) && !this.skipped;\n    }\n}\n", "import { patch } from \"@web/core/utils/patch\";\n\n// To expose the editor instance globally for tour.\nexport const editorsWeakMap = new WeakMap();\n\nconst editorModule = odoo.loader.modules.get(\"@html_editor/editor\");\nif (editorModule) {\n    const { Editor } = editorModule;\n    patch(Editor.prototype, {\n        attachTo(editable) {\n            editorsWeakMap.set(editable.ownerDocument, this);\n            return super.attachTo(...arguments);\n        },\n    });\n}\n\nexport function setSelection({\n    anchorNode,\n    anchorOffset,\n    focusNode = anchorNode,\n    focusOffset = anchorOffset,\n}) {\n    const selection = anchorNode.ownerDocument.getSelection();\n    selection.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n}\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"mail_activity_date_format\", {\n    steps: () => [\n        {\n            trigger: \"button:contains('Activity')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_selection_badge span:contains('To-Do')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"div[name='summary'] input\",\n            run: \"edit Go Party\",\n        },\n        {\n            trigger: \"button:contains('Save')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Activity:contains('Go Party')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Activity-info i\",\n            run: \"click\",\n        },\n        // Format expected from the server for 9 AM at the first day of 2024 is date_format = \"%d/%b/%y\", time_format = \"%I:%M:%S %p\".\n        {\n            trigger:\n                \".o-mail-Activity-details tr:contains('Created') td:contains('01/Jan/24 09:00:00 AM')\",\n        },\n        {\n            // Default due date is 5 days after creation date.\n            trigger: \".o-mail-Activity-details tr:contains('Due on') td:contains('06/Jan/24')\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"can_create_channel_from_form_view\", {\n    steps: () => [\n        {\n            trigger: \".o-mail-DiscussSidebarChannel-itemName:contains(OdooBot)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-DiscussContent-threadName[title='OdooBot']\",\n        },\n        { trigger: \"button[title='View or join channels']:not(:visible)\", run: \"click\" },\n        {\n            trigger: \".o_control_panel_main_buttons button:contains('New')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"div[name='name'] input\",\n            run: \"edit Test channel\",\n        },\n        {\n            trigger: \".breadcrumb-item:contains('OdooBot')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel-itemName:contains('Test channel')\",\n        },\n    ],\n});\n", "import { ChannelMember } from \"@mail/discuss/core/common/channel_member_model\";\n\nimport { registry } from \"@web/core/registry\";\nimport { patchWithCleanup } from \"@web/../tests/helpers/utils\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_call_invitation.js\", {\n    steps: () => {\n        // Call invitation is cancelled after 30s. Increase this delay for the test.\n        patchWithCleanup(ChannelMember, { CANCEL_CALL_INVITE_DELAY: 1e6 });\n        return [\n            { trigger: \".o-discuss-CallInvitation\" },\n            {\n                trigger:\n                    \".o-mail-CallInvitation-avatar[title='View the bob (base.group_user) and john (base.group_user) channel']\",\n            },\n            {\n                trigger:\n                    \".o-discuss-CallInvitation-channelName:contains('bob (base.group_user) and john (base.group_user)')\",\n            },\n            {\n                trigger:\n                    \".o-discuss-CallInvitation-description:contains('Incoming call from bob (base.group_user)')\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview:not(:visible)\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation button[title='Join Call']\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation button[title='Reject']\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation button[title='Show camera preview']\",\n                run: \"click\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview button[title='Turn camera on']\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview button[title='Unmute']\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview button[title='Video Settings']\",\n                run: \"click\",\n            },\n            {\n                trigger: \"label:contains('Blur background')\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation button[title='Hide camera preview']\",\n                run: \"click\",\n            },\n            {\n                trigger: \".o-discuss-CallInvitation-cameraPreview:not(:visible)\",\n            },\n        ];\n    },\n});\n", "import { registry } from \"@web/core/registry\";\nimport { contains } from \"@web/../tests/utils\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_as_guest_tour.js\", {\n    steps: () => [\n        {\n            content: \"Channel secret token has been hidden on welcome page\",\n            trigger: \".o-mail-WelcomePage\",\n            run() {\n                if (!window.location.pathname.startsWith(\"/discuss/channel\")) {\n                    console.error(\"Channel secret token is still present in URL.\");\n                }\n            },\n        },\n        {\n            content: \"Click join\",\n            trigger: \"button[title='Join Channel']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check that we are on not in a call\",\n            trigger: \"button[name='call']\",\n        },\n        {\n            content: \"Check that we are on channel page\",\n            trigger: \".o-mail-Thread\",\n            run: \"press ctrl+k\",\n        },\n        {\n            trigger: \".o_command_palette_search input\",\n            run: \"fill @\",\n        },\n        {\n            trigger: \".o-mail-DiscussCommand\",\n            async run() {\n                await contains(\".fa-hashtag\", {\n                    parent: [\".o-mail-DiscussCommand\", { text: \"Test channel\" }],\n                });\n                await contains(\".fa-user\", { count: 0 });\n            },\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_call_action.js\", {\n    steps: () => [\n        {\n            content: \"Check that the call has started\",\n            trigger: \".o-discuss-Call\",\n        },\n        {\n            content: \"Check that current user is in call ('disconnect' button visible)\",\n            trigger: \"button[title='Disconnect']\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_call_public_tour.js\", {\n    steps: () => [\n        {\n            content: \"The call does not start on the welcome page\",\n            trigger: \".o-mail-WelcomePage\",\n            async run() {\n                await new Promise((r) => setTimeout(r, 250));\n                const rtcService = odoo.__WOWL_DEBUG__.root.env.services[\"discuss.rtc\"];\n                if (rtcService?.selfSession || rtcService?.state.hasPendingRequest) {\n                    console.error(\"The call should not have started.\");\n                }\n            },\n        },\n        {\n            content: \"Click join\",\n            trigger: \"button[title='Join Channel']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check that the call has started\",\n            trigger: \".o-discuss-Call\",\n        },\n        {\n            content: \"Check that current user is in call ('disconnect' button visible)\",\n            trigger: \"button[title='Disconnect']\",\n        },\n    ],\n});\n", "import { browser } from \"@web/core/browser/browser\";\nimport { registry } from \"@web/core/registry\";\nimport { dragenterFiles } from \"@web/../tests/utils\";\n\nconst CLICK_ON_CHAT_STEP = \"click-on-chat-action\";\n\nfunction getMeetingViewTourSteps({ inWelcomePage = false } = {}) {\n    const steps = [\n        { trigger: \".o-mail-Meeting\" },\n        {\n            trigger: \".o-mail-Meeting [title='Invite People']\",\n            run: \"click\",\n        },\n        { trigger: \".o-mail-Meeting .o-mail-ActionPanel:contains('Invite people')\" },\n        {\n            trigger: \".o-mail-Meeting [title='Invite People']\", // close it\n            run: \"click\",\n        },\n        { trigger: \".o-mail-Meeting:not(:has(.o-mail-ActionPanel))\" },\n        {\n            trigger: \".o-mail-Meeting [title='Invite People']\",\n            run: \"click\",\n        },\n        { trigger: \".o-mail-Meeting .o-mail-ActionPanel:contains('Invite people')\" },\n        {\n            trigger: \".o-mail-Meeting [title='Chat']\",\n            run: \"click\",\n            content: CLICK_ON_CHAT_STEP,\n        },\n        {\n            trigger:\n                \".o-mail-Meeting .o-mail-ActionPanel .o-mail-Thread:contains('john (base.group_user) and bob (base.group_user)')\",\n        },\n        {\n            trigger: \".o-mail-Message[data-persistent]:contains('Hello everyone!')\",\n            run: \"hover && click .o-mail-Message-actions button[title='Expand']\",\n        },\n        {\n            trigger: \".o-dropdown-item:contains('Mark as Unread')\",\n            run: \"click\",\n        },\n        { trigger: \".o-mail-Meeting [title='Chat']:has(.badge:contains(1))\" },\n        {\n            trigger: \".o-mail-Thread-banner span:contains('Mark as Read')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Meeting [title='Chat']:not(:has(.badge))\",\n            async run({ waitFor }) {\n                const files = [new File([\"hi there\"], \"file2.txt\", { type: \"text/plain\" })];\n                await dragenterFiles(\".o-mail-Meeting .o-mail-ActionPanel\", files);\n                // Ensure other dropzones such as discuss or chat window dropzones are not active in meeting view.\n                await waitFor(\".o-Dropzone\", { only: true });\n            },\n        },\n        {\n            trigger: \".o-mail-Meeting [title='Close panel']\",\n            run: \"click\",\n        },\n        { trigger: \".o-mail-Meeting:not(:has(.o-mail-ActionPanel))\" },\n        {\n            trigger: \".o-mail-Meeting [title='Exit Fullscreen']\",\n            run: \"click\",\n        },\n        { trigger: \"body:not(:has(.o-mail-Meeting))\" },\n    ];\n    if (inWelcomePage) {\n        steps.unshift({ trigger: \"[title='Join Channel']\", run: \"click\" });\n    }\n    return steps;\n}\n\nregistry\n    .category(\"web_tour.tours\")\n    .add(\"discuss.meeting_view_tour\", {\n        steps: () => {\n            // Avoid starting with mic/camera to prevent an unhandleable browser permission popup.\n            browser.localStorage.setItem(\"discuss_call_preview_join_mute\", \"true\");\n            browser.localStorage.setItem(\"discuss_call_preview_join_video\", \"false\");\n            const steps = getMeetingViewTourSteps();\n            const clickOnChatIndex = steps.find((step) => step.content === CLICK_ON_CHAT_STEP);\n            steps.splice(\n                clickOnChatIndex,\n                0,\n                {\n                    trigger: \".o-mail-Composer.o-focused .o-mail-Composer-input\",\n                    run: \"edit Hello everyone!\",\n                },\n                { trigger: \".o-mail-Composer button[title='Send']:enabled\", run: \"click\" }\n            );\n            return steps;\n        },\n    })\n    .add(\"discuss.meeting_view_public_tour\", {\n        steps: () => getMeetingViewTourSteps({ inWelcomePage: true }),\n    });\n", "import { reactive } from \"@odoo/owl\";\nimport { registry } from \"@web/core/registry\";\nimport { getOrigin } from \"@web/core/utils/urls\";\nimport { click, inputFiles } from \"@web/../tests/utils\";\n\n// The tour is ran twice, ensure the correct message is always targetted.\nconst messageSelector = \".o-mail-Message:has(.o-mail-Message-body:contains('cheese'))\";\nconst editedMessageSelector = \".o-mail-Message:has(.o-mail-Message-body:contains('vegetables'))\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_channel_public_tour.js\", {\n    steps: () => [\n        {\n            trigger: \".o-mail-Discuss\",\n        },\n        {\n            trigger: \".o-mail-Thread\",\n            run() {\n                if (!window.location.pathname.startsWith(\"/discuss/channel\")) {\n                    console.error(\"Channel secret token is still present in URL.\");\n                }\n                const errors = odoo.loader.findErrors();\n                if (Object.keys(errors).length) {\n                    console.error(\"Couldn't load all JS modules.\", errors);\n                }\n                document.body.classList.add(\"o_discuss_channel_public_modules_loaded\");\n                if (\n                    !document.title.includes(\n                        document.querySelector(\".o-mail-DiscussContent-threadName\")?.value\n                    )\n                ) {\n                    console.error(\n                        `Tab title should match conversation name. Got \"${\n                            document.title\n                        }\" instead of \"${\n                            document.querySelector(\".o-mail-DiscussContent-threadName\")?.value\n                        }\".`\n                    );\n                }\n            },\n        },\n        {\n            trigger: \".o_discuss_channel_public_modules_loaded\",\n        },\n        {\n            trigger: \".o-mail-Composer-input\",\n            run: \"edit cheese\",\n        },\n        { trigger: \".o-mail-Composer button[title='More Actions']\", run: \"click\" },\n        {\n            trigger: \".dropdown-item:contains('Attach Files')\",\n            async run() {\n                const text = new File([\"hello, world\"], \"text.txt\", { type: \"text/plain\" });\n                await inputFiles(\".o-mail-Composer .o_input_file\", [text]);\n            },\n        },\n        {\n            trigger: \".o-mail-AttachmentContainer:not(.o-isUploading):contains(text.txt)\",\n        },\n        {\n            trigger: \".dropdown-item:contains('Attach Files')\",\n            async run() {\n                await inputFiles(\".o-mail-Composer .o_input_file\", [\n                    new File(\n                        [\n                            await (\n                                await fetch(\n                                    \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQIW2P4v5ThPwAG7wKklwQ/bwAAAABJRU5ErkJggg==\"\n                                )\n                            ).blob(),\n                        ],\n                        \"image.png\",\n                        { type: \"image/png\" }\n                    ),\n                ]);\n            },\n        },\n        {\n            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading)[title=\"image.png\"]',\n            async run({ waitFor }) {\n                /** @type {import(\"models\").Store} */\n                const store = odoo.__WOWL_DEBUG__.root.env.services[\"mail.store\"];\n                if (store.self_guest) {\n                    const src = this.anchor.querySelector(\"img\").src;\n                    const attachment = store[\"ir.attachment\"].get(\n                        (src.match(\"/web/image/([0-9]+)\") || []).at(-1)\n                    );\n                    if (!attachment) {\n                        throw new Error(`Attachment was not found from src: ${src}`);\n                    }\n                    if (!attachment.raw_access_token) {\n                        await new Promise((resolve) => {\n                            const proxy = reactive(attachment, () => {\n                                if (attachment.raw_access_token) {\n                                    resolve();\n                                } else {\n                                    void proxy.raw_access_token; // keep observing until a value is received\n                                }\n                            });\n                            void proxy.raw_access_token; // start observing\n                        });\n                    }\n                    await waitFor(\n                        `.o-mail-AttachmentContainer[title=\"image.png\"] img[src=\"${getOrigin()}/web/image/${\n                            attachment.id\n                        }?access_token=${attachment.raw_access_token}&filename=image.png&unique=${\n                            attachment.checksum\n                        }\"]`\n                    );\n                }\n            },\n        },\n        { trigger: \".o-mail-Composer button[title='Send']:enabled\", run: \"click\" },\n        {\n            trigger: `${messageSelector}[data-persistent]`,\n        },\n        {\n            trigger: `${messageSelector} .o-mail-AttachmentContainer:contains(\"text.txt\")`,\n        },\n        {\n            trigger: messageSelector,\n            run: `hover && click ${messageSelector} [title='Add a Reaction']`,\n        },\n        {\n            trigger: \".o-mail-QuickReactionMenu\",\n            run: () => click(\"[title='Toggle Emoji Picker']\"),\n        },\n        {\n            trigger: \".o-EmojiPicker .o-Emoji:contains('\ud83d\ude42')\",\n            run: \"click\",\n        },\n        {\n            trigger: `${messageSelector} .o-mail-MessageReaction:contains('\ud83d\ude42')`,\n            run: \"click\",\n        },\n        {\n            trigger: `${messageSelector}:not(:has(.o-mail-MessageReaction:contains('\ud83d\ude42')))`,\n        },\n        {\n            trigger: `${messageSelector}`,\n            run: `hover && click ${messageSelector} [title='Expand']`,\n        },\n        {\n            trigger: `.o-mail-Message-moreMenu [title='Edit'], ${messageSelector} [title='Edit']`,\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Message .o-mail-Composer-input\",\n            run: \"edit vegetables\",\n        },\n        {\n            trigger: \".o-mail-Message .o-mail-Composer button[title='More Actions']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".dropdown-item:contains('Attach Files')\",\n            async run() {\n                const extratxt = new File([\"hello 2\"], \"extra.txt\", { type: \"text/plain\" });\n                await inputFiles(\".o-mail-Message .o_input_file\", [extratxt]);\n            },\n        },\n        {\n            trigger:\n                \".o-mail-Message .o-mail-Composer .o-mail-AttachmentContainer:not(.o-isUploading):contains(extra.txt)\",\n        },\n        {\n            trigger: \".o-mail-Message button:contains(save)\",\n            run: \"click\",\n        },\n        {\n            trigger: editedMessageSelector,\n        },\n        {\n            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains(\"text.txt\")`,\n        },\n        {\n            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains(\"extra.txt\")`,\n        },\n        {\n            trigger: `${editedMessageSelector} .o-mail-AttachmentContainer:contains(\"extra.txt\") .o-mail-Attachment-unlink`,\n            run: \"click\",\n        },\n        {\n            trigger: \".modal:contains(Confirmation) .btn:contains(Ok)\",\n            run: \"click\",\n        },\n        {\n            trigger: `${editedMessageSelector}:not(:has(.o-mail-AttachmentContainer:contains(\"extra.txt\")))`,\n        },\n        {\n            trigger: \"button[title='Search Messages']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_searchview_input\",\n            run: \"edit text.txt\",\n        },\n        {\n            trigger: \"button[aria-label='Search button']\",\n            run: \"click\",\n        },\n        {\n            trigger: `.o-mail-SearchMessagesPanel ${editedMessageSelector} .o-mail-AttachmentContainer:contains(\"text.txt\")`,\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_configuration_tour\", {\n    url: \"/odoo\",\n    steps: () => [\n        stepUtils.showAppsMenuItem(),\n        {\n            trigger: '.o_app[data-menu-xmlid=\"mail.menu_root_discuss\"]',\n            run: \"click\",\n        },\n        {\n            trigger: \".o_main_navbar button:contains('Configuration')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".dropdown-menu a:contains('Notification')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"button:contains('All Messages')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"button:contains('Mentions Only')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"button:contains('Nothing')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".modal-header button[aria-label='Close']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_main_navbar button:contains('Configuration')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".dropdown-menu a:contains('Voice & Video')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"select[name='inputDevice']\",\n        },\n        {\n            trigger: \"button:contains('Voice Detection')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"span:contains('Voice detection sensitivity')\",\n        },\n        {\n            trigger: \"button:contains('Push to Talk')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"label:contains('Push-to-talk key')\",\n        },\n        {\n            trigger: \"label:contains('Delay after releasing push-to-talk')\",\n        },\n        {\n            trigger: \"input[aria-label='Show video participants only']\",\n        },\n        {\n            trigger: \"input[aria-label='Blur video background']\",\n            run: \"click\",\n        },\n        {\n            trigger: \"label:contains('Background blur intensity')\",\n        },\n        {\n            trigger: \"label:contains('Edge blur intensity')\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_go_back_to_thread_from_breadcrumbs.js\", {\n    steps: () => [\n        { trigger: \".o-mail-DiscussContent-threadName[title='Inbox']\" },\n        { trigger: \".o-mail-DiscussSidebar-item:contains('Starred messages')\", run: \"click\" },\n        { trigger: \"button[title='View or join channels']:not(:visible)\", run: \"click\" },\n        { trigger: \".breadcrumb-item:contains('Starred messages')\", run: \"click\" },\n        { trigger: \".o-mail-DiscussContent-threadName[title='Starred messages']\" },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss.invite_by_email\", {\n    steps: () => [\n        {\n            trigger: \"button[title='Invite People']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-discuss-ChannelInvitation-search[placeholder='Invite people or email']\",\n            run: \"edit john@test.com\",\n        },\n        {\n            trigger: \".o-discuss-ChannelInvitation-selectable:contains('john (base.group_user)')\",\n            async run({ waitFor, click }) {\n                await waitFor(\".o-discuss-ChannelInvitation-selectable\", {\n                    only: true,\n                    timeout: 5000,\n                });\n                await click();\n            },\n        },\n        {\n            trigger:\n                \".o-discuss-ChannelInvitation-selectedList :contains('john (base.group_user)')\",\n        },\n        {\n            trigger: \".o-discuss-ChannelInvitation-search\",\n            run: \"edit unknown_email@test.com\",\n        },\n        {\n            trigger: \".o-discuss-ChannelInvitation-selectable:contains('unknown_email@test.com')\",\n            run: \"click\",\n        },\n        {\n            trigger:\n                \".o-discuss-ChannelInvitation-selectedList :contains('unknown_email@test.com')\",\n        },\n        {\n            trigger: \"button:contains(Invite to Group Chat)\",\n            run: \"click\",\n        },\n        {\n            trigger: \"body:not(:has(.o-mail-ActionPanel))\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"discuss_mention_suggestions_group_restricted_channel.js\", {\n    steps: () => [\n        { trigger: \".o-mail-DiscussContent-threadName[title='R&D Channel']\" },\n        { trigger: \".o-mail-Composer-input\", run: \"edit @\" },\n        { trigger: \".o-mail-Composer-suggestion:count(3)\" },\n        {\n            content: \"Suggest channel member not in R&D group\",\n            trigger: \".o-mail-Composer-suggestion strong:text(Consultant User)\",\n        },\n        {\n            content: \"Suggest non-channel member in R&D group\",\n            trigger: \".o-mail-Composer-suggestion strong:text(Dev User)\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"sidebar_in_public_page_tour\", {\n    steps: () => [\n        {\n            trigger: \".o-mail-DiscussContent-header [title='Channel 1']\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 2)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-DiscussContent-header [title='Channel 2']\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active\",\n            run() {\n                history.back();\n            },\n        },\n        {\n            trigger: \".o-mail-DiscussContent-header [title='Channel 1']\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 1).o-active\",\n            run() {\n                history.forward();\n            },\n        },\n        {\n            trigger: \".o-mail-DiscussContent-header [title='Channel 2']\",\n        },\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active\",\n        },\n        {\n            content: \"Open channel actions\",\n            trigger: \".o-mail-DiscussSidebarChannel:contains(Channel 2).o-active\",\n            run: \"hover && click [title='Channel Actions']\",\n        },\n        {\n            trigger: \".o-dropdown-item:contains('Invite People')\",\n            run: \"click\",\n        },\n    ],\n});\n", "import { SubChannelList } from \"@mail/discuss/core/public_web/sub_channel_list\";\n\nimport { status } from \"@odoo/owl\";\n\nimport { registry } from \"@web/core/registry\";\nimport { Deferred } from \"@web/core/utils/concurrency\";\nimport { patch } from \"@web/core/utils/patch\";\nimport { effect } from \"@web/core/utils/reactive\";\nimport { contains, dragenterFiles, dropFiles, scroll } from \"@web/../tests/utils\";\n\nlet waitForLoadMoreToDisappearDef;\nregistry.category(\"web_tour.tours\").add(\"test_discuss_sub_channel_search\", {\n    steps: () => [\n        {\n            trigger: \"body\",\n            run() {\n                patch(SubChannelList.prototype, {\n                    setup() {\n                        super.setup(...arguments);\n                        effect(\n                            (state) => {\n                                if (status(this) === \"destroyed\") {\n                                    return;\n                                }\n                                if (!state.isVisible) {\n                                    waitForLoadMoreToDisappearDef?.resolve();\n                                }\n                            },\n                            [this.loadMoreState]\n                        );\n                    },\n                });\n            },\n        },\n        {\n            trigger: \"button[title='Threads']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-SubChannelList\",\n            async run() {\n                // 30 newest sub channels are loaded initially.\n                for (let i = 99; i > 69; i--) {\n                    await contains(\".o-mail-SubChannelPreview\", {\n                        text: `Sub Channel ${i}`,\n                    });\n                    await contains(\".o-mail-SubChannelPreview\", { count: 30 });\n                }\n            },\n        },\n        {\n            trigger: \".o-mail-ActionPanel:has(.o-mail-SubChannelList) .o_searchview_input\",\n            run: \"edit Sub Channel 10\",\n        },\n        {\n            trigger:\n                \".o-mail-ActionPanel:has(.o-mail-SubChannelList) button[aria-label='Search button']\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-SubChannelPreview:contains(Sub Channel 10)\",\n            async run() {\n                await contains(\".o-mail-SubChannelPreview\", { count: 1 });\n                waitForLoadMoreToDisappearDef = new Deferred();\n            },\n        },\n        {\n            trigger: \".o_searchview_input\",\n            run: \"clear\",\n        },\n        {\n            trigger: \".o-mail-SubChannelPreview:contains(Sub Channel 99)\",\n            async run() {\n                await contains(\".o-mail-SubChannelPreview\", { count: 31 });\n                // Already fetched sub channels are shown in addition to the one\n                // that was fetched during the search.\n                for (let i = 99; i > 69; i--) {\n                    await contains(\".o-mail-SubChannelPreview\", {\n                        text: `Sub Channel ${i}`,\n                    });\n                }\n                await contains(\".o-mail-SubChannelPreview\", { text: `Sub Channel 10` });\n                // Ensure lazy loading is still working after a search.\n                await waitForLoadMoreToDisappearDef;\n                waitForLoadMoreToDisappearDef = new Deferred();\n                await scroll(\".o-mail-ActionPanel:has(.o-mail-SubChannelList)\", \"bottom\");\n            },\n        },\n        {\n            trigger: \".o-mail-SubChannelPreview:contains(Sub Channel 40)\",\n            async run() {\n                await contains(\".o-mail-SubChannelPreview\", { count: 61 });\n                for (let i = 99; i > 39; i--) {\n                    await contains(\".o-mail-SubChannelPreview\", {\n                        text: `Sub Channel ${i}`,\n                    });\n                }\n                await waitForLoadMoreToDisappearDef;\n                waitForLoadMoreToDisappearDef = new Deferred();\n                await scroll(\".o-mail-ActionPanel:has(.o-mail-SubChannelList)\", \"bottom\");\n            },\n        },\n        {\n            trigger: \".o-mail-SubChannelPreview:contains(Sub Channel 11)\",\n            async run() {\n                await contains(\".o-mail-SubChannelPreview\", { count: 90 });\n                for (let i = 99; i > 9; i--) {\n                    await contains(\".o-mail-SubChannelPreview\", {\n                        text: `Sub Channel ${i}`,\n                    });\n                }\n                await waitForLoadMoreToDisappearDef;\n                await scroll(\".o-mail-ActionPanel:has(.o-mail-SubChannelList)\", \"bottom\");\n            },\n        },\n        {\n            trigger: \".o-mail-SubChannelPreview:contains(Sub Channel 0)\",\n            async run() {\n                await contains(\".o-mail-SubChannelPreview\", { count: 100 });\n                for (let i = 99; i > 0; i--) {\n                    await contains(\".o-mail-SubChannelPreview\", {\n                        text: `Sub Channel ${i}`,\n                    });\n                }\n            },\n        },\n    ],\n});\n\nregistry.category(\"web_tour.tours\").add(\"create_thread_for_attachment_without_body\", {\n    steps: () => [\n        {\n            content: \"Open general channel\",\n            trigger: '.o-mail-DiscussSidebarChannel-itemName:contains(\"general\")',\n            run: \"click\",\n        },\n        {\n            content: \"Drop a file\",\n            trigger: \".o-mail-DiscussContent-main\",\n            async run() {\n                const files = [new File([\"hi there\"], \"file2.txt\", { type: \"text/plain\" })];\n                await dragenterFiles(\".o-mail-DiscussContent-main\", files);\n                await dropFiles(\".o-Dropzone\", files);\n            },\n        },\n        {\n            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading):contains(\"file2.txt\")',\n        },\n        {\n            content: \"Click on send button\",\n            trigger: \".o-mail-Composer-mainActions [title='Send']:enabled\",\n            run: \"click\",\n        },\n        {\n            content: \"Hover on attachment\",\n            trigger:\n                '.o-mail-Message:not(:has(.o-mail-Message-pendingProgress)) .o-mail-AttachmentContainer:contains(\"file2.txt\")',\n            run: \"hover\",\n        },\n        {\n            content: \"Click on expand button\",\n            trigger: '.o-mail-Message [title=\"Expand\"]',\n            run: \"click\",\n        },\n        {\n            content: \"Create a new thread\",\n            trigger: '.o-dropdown-item:contains(\"Create Thread\")',\n            run: \"click\",\n        },\n        {\n            content: \"Check a new thread is created\",\n            trigger: '.o-mail-Discuss:contains(\"New Thread\")',\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"mail_activity_schedule_from_chatter\", {\n    steps: () => [\n        {\n            trigger: \"button:contains('Activity')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_selection_badge span:contains('Call')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_selection_badge.active span:contains('Call')\",\n        },\n        {\n            trigger: \".o_selection_badge span:contains('To-Do')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"div[name='summary'] input\",\n            run: \"edit Play Mario Party\",\n        },\n        {\n            trigger: \"button:contains('Save')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Activity:contains('Play Mario Party')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"button:contains('Activity')\",\n            run: \"click\",\n        },\n        {\n            trigger: \"div[name='summary'] input\",\n            run: \"edit Play Mario Kart\",\n        },\n        {\n            trigger: \"button.btn.btn-secondary:contains('Mark Done')\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Message:contains('Play Mario Kart')\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add(\"mail/static/tests/tours/mail_composer_autosave_tour.js\", {\n    steps: () => [\n        {\n            content: \"Edit the function field\",\n            trigger: \".o_field_widget[name='function'] > .o_input\",\n            run: \"edit Director\",\n        },\n        {\n            trigger: \".o_form_sheet_bg\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \".o-mail-Chatter-sendMessage\",\n            run: \"click\",\n        },\n        {\n            content: \"Open the full composer\",\n            trigger: \"[name='open-full-composer']\",\n            run: \"click\",\n        },\n        {\n            content: \"Edit the body\",\n            trigger: \".o-wysiwyg div[contenteditable='true']\",\n            run: \"editor Hello-- Mitchell Admin\",\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \".o_mail_send[name='action_send_mail']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check message is shown\",\n            trigger: '.o-mail-Message-body:contains(\"Hello\")',\n        },\n        {\n            trigger: \".o_form_saved\",\n        },\n        ...stepUtils.toggleHomeMenu(),\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { contains, dragenterFiles, dropFiles, inputFiles } from \"@web/../tests/utils\";\n\n/**\n * This tour depends on data created by python test in charge of launching it.\n * It is not intended to work when launched from interface. It is needed to test\n * an action (action manager) which is not possible to test with QUnit.\n * @see mail/tests/test_mail_composer.py\n */\nregistry.category(\"web_tour.tours\").add(\"mail/static/tests/tours/mail_composer_test_tour.js\", {\n    steps: () => [\n        {\n            content: \"Wait for the chatter to be fully loaded\",\n            trigger: \".o-mail-Chatter\",\n            async run() {\n                await contains(\".o-mail-Message\", { count: 1 });\n            },\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Write something in composer\",\n            trigger: \".o-mail-Composer-input\",\n            run: \"edit blahblah @Not && click body\",\n        },\n        {\n            content: \"Mention a partner\",\n            trigger: \".o-mail-Composer-suggestion:contains(Not A Demo User)\",\n            run: \"click\",\n        },\n        {\n            content: \"Add one file in composer\",\n            trigger: \".o-mail-Composer button[title='Attach Files']\",\n            async run() {\n                const files = [new File([\"hello, world\"], \"file1.txt\", { type: \"text/plain\" })];\n                await inputFiles(\".o-mail-Composer .o_input_file\", files);\n            },\n        },\n        {\n            trigger: '.o-mail-AttachmentContainer:not(.o-isUploading):contains(\"file1.txt\")',\n        },\n        {\n            content: \"Open full composer\",\n            trigger: \"button[title='Open Full Composer']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check composer keeps open after pushing Escape\",\n            trigger: \".o_mail_composer_form_view\",\n            run: \"press Escape\",\n        },\n        {\n            content: \"Check the earlier provided attachment is listed\",\n            trigger: \".o_field_mail_composer_attachment_list a:contains(file1.txt)\",\n        },\n        {\n            content: \"Check subject is autofilled\",\n            trigger: '[name=\"subject\"] input',\n            run() {\n                const subjectValue = document.querySelector('[name=\"subject\"] input').value;\n                if (subjectValue !== \"Jane\") {\n                    console.error(\n                        `Full composer should have \"Jane\" in subject input (actual: ${subjectValue})`\n                    );\n                }\n            },\n        },\n        {\n            content: \"Check composer content is kept and contains the user's signature\",\n            trigger: '.o_field_html[name=\"body\"]',\n            run() {\n                const bodyContent = document.querySelector(\n                    '.o_field_html[name=\"body\"]'\n                ).textContent;\n                if (!bodyContent.includes(\"blahblah @Not A Demo User\")) {\n                    console.error(\n                        `Full composer should contain text from small composer (\"blahblah @Not A Demo User\") in body input (actual: ${bodyContent})`\n                    );\n                }\n                const mentionLink = document.querySelector(\n                    '.o_field_html[name=\"body\"] a'\n                ).textContent;\n                if (!mentionLink.includes(\"@Not A Demo User\")) {\n                    console.error(\n                        `Full composer should contain mention link from small composer (\"@Not A Demo User\") in body input)`\n                    );\n                }\n                /** When opening the full composer for the first time, the system\n                 * should add the user's signature to the end of the message so\n                 * that the user can edit it. After adding the signature to\n                 * the editor, the server shouldn't automatically add the\n                 * signature to the message (see: Python tests). */\n                if ((bodyContent.match(/--\\nErnest/g) || []).length !== 1) {\n                    console.error(\"Full composer should contain the user's signature once.\");\n                }\n            },\n        },\n        {\n            content: \"Drop a file on the full composer\",\n            trigger: \".o_mail_composer_form_view\",\n            async run() {\n                const files = [new File([\"hi there\"], \"file2.txt\", { type: \"text/plain\" })];\n                await dragenterFiles(\".o_mail_composer_form_view .o_form_renderer\", files);\n                await dropFiles(\".o-Dropzone\", files);\n            },\n        },\n        {\n            content: \"Check the attachment is listed\",\n            trigger: \".o_field_mail_composer_attachment_list a:contains(file2.txt)\",\n        },\n        {\n            content: \"Click on the mail template selector\",\n            trigger: \".mail-composer-template-dropdown-btn\",\n            run: \"click\",\n        },\n        {\n            content: \"Check a template is listed\",\n            trigger:\n                '.mail-composer-template-dropdown.popover .o-dropdown-item:contains(\"Test template\")',\n        },\n        {\n            content: \"Verify admin template is NOT listed\",\n            trigger: \".mail-composer-template-dropdown.popover\",\n            run() {\n                const hasAdminTemplate = [...document.querySelectorAll('.o-dropdown-item')]\n                    .some(item => item.textContent.includes(\"Test template for admin\"));\n                if (hasAdminTemplate) {\n                    console.error(\"Template assigned to the admin is visible to a non-assigned user! This should not happen.\");\n                }\n            },\n        },\n        {\n            content: \"Send message from full composer\",\n            trigger: \".o_mail_send\",\n            run: \"click\",\n        },\n        {\n            content: \"Check message is shown\",\n            trigger: '.o-mail-Message-body:contains(\"blahblah @Not A Demo User\")',\n            run: \"click\",\n        },\n        {\n            content: \"Click on envelope to see recipients of message\",\n            trigger:\n                '.o-mail-Message:has(.o-mail-Message-body:contains(\"blahblah @Not A Demo User\")) .o-mail-Message-notification',\n            run: \"click\",\n        },\n        {\n            content: \"Check message has correct recipients\",\n            trigger:\n                \".o-mail-MessageNotificationPopover:contains('Not A Demo User (NotADemoUser@mail.com) Jane (jane@example.com) Mitchell Admin (test.admin@test.example.com)')\",\n        },\n        {\n            content: \"Check message contains the first attachment\",\n            trigger: '.o-mail-Message .o-mail-AttachmentContainer:contains(\"file1.txt\")',\n        },\n        {\n            content: \"Check message contains the second attachment\",\n            trigger: '.o-mail-Message .o-mail-AttachmentContainer:contains(\"file2.txt\")',\n        },\n        // Test the full composer input text is kept on closing\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Open full composer\",\n            trigger: \"button[title='Open Full Composer']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check that the composer contains the signature\",\n            trigger: '.o_field_html[name=\"body\"]',\n            run() {\n                const bodyContent = document.querySelector(\n                    '.o_field_html[name=\"body\"]'\n                ).textContent;\n                /** When opening the full composer, the system should add the\n                 * user's signature, as this is a new message and the signature\n                 * has not yet been added to it. */\n                if ((bodyContent.match(/--\\nErnest/g) || []).length !== 1) {\n                    console.log(\"Full composer should contain the user's signature once.\");\n                }\n            },\n        },\n        {\n            content: \"Write something in full composer\",\n            trigger: \".note-editable\",\n            run: \"editor keep the content\",\n        },\n        {\n            content: \"Close full composer\",\n            trigger: \".btn-close\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Check full composer text is kept\",\n            trigger: \".o-mail-Composer-input\",\n            run() {\n                if (this.anchor.value !== \"keep the content\") {\n                    console.error(\n                        \"Composer in chatter should contain full composer text after discarding.\"\n                    );\n                }\n            },\n        },\n        {\n            content: \"Open full composer\",\n            trigger: \"button[title='Open Full Composer']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check that the composer doesn't add the user's signature twice\",\n            trigger: \".note-editable\",\n            run() {\n                const bodyContent = document.querySelector(\n                    '.o_field_html[name=\"body\"]'\n                ).textContent;\n                /** When re-opening the full composer, the system shouldn't re-add\n                 * the user's signature to the message. As the user deleted the\n                 * signature in the previous steps (see: `editor keep the content`),\n                 * the editor shouldn't contain any signature. */\n                if ((bodyContent.match(/--\\nErnest/g) || []).length !== 0) {\n                    console.error(\"The composer should not contain the user's signature.\");\n                }\n            },\n        },\n        {\n            content: \"Close full composer\",\n            trigger: \".btn-close\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Send message from chatter\",\n            trigger: \".o-mail-Composer-send:enabled\",\n            run: \"click\",\n        },\n        {\n            content: \"Check message is shown\",\n            trigger: '.o-mail-Message-body:contains(\"keep the content\")',\n        },\n        // Test that the server automatically adds the user's signature to the\n        // email when the user didn't open the full composer.\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Write a message\",\n            trigger: \".o-mail-Composer-input\",\n            run: \"edit hello world\",\n        },\n        {\n            content: \"Send message from chatter\",\n            trigger: \".o-mail-Composer-send:enabled\",\n            run: \"click\",\n        },\n        {\n            content: \"Check message is shown\",\n            trigger: '.o-mail-Message-body:contains(\"hello world\")',\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { contains } from \"@web/../tests/utils\";\n\n/**\n * This tour depends on data created by python test in charge of launching it.\n * It is not intended to work when launched from interface. It is needed to test\n * an action (action manager) which is not possible to test with QUnit.\n * @see mail/tests/test_mail_composer.py\n */\nregistry.category(\"web_tour.tours\").add(\"mail/static/tests/tours/mail_html_composer_test_tour.js\", {\n    steps: () => [\n        {\n            content: \"Wait for the chatter to be fully loaded\",\n            trigger: \".o-mail-Chatter\",\n            async run() {\n                const composerService = odoo.__WOWL_DEBUG__.root.env.services[\"mail.composer\"];\n                composerService.setHtmlComposer();\n                await contains(\".o-mail-Message\", { count: 1 });\n            },\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"Write something in composer\",\n            trigger: \".o-mail-Composer-html.odoo-editor-editable\",\n            run: \"editor Hello\",\n        },\n        {\n            content: \"Select the text\",\n            trigger: \".o-mail-Composer-html.odoo-editor-editable\",\n            run: \"dblclick\",\n        },\n        {\n            trigger: \".o-we-toolbar\",\n        },\n        {\n            content: \"Bold the text\",\n            trigger: \".o-we-toolbar button[title='Toggle bold']\",\n            run: \"click\",\n        },\n        {\n            content: \"The bolded text is in the composer\",\n            trigger: \".o-mail-Composer-html.odoo-editor-editable strong:contains(Hello)\",\n        },\n        {\n            content: \"Open full composer\",\n            trigger: \"button[title='Open Full Composer']\",\n            run: \"click\",\n        },\n        {\n            content: \"Check composer keeps the formatted content\",\n            trigger: \".o_mail_composer_message strong:contains(Hello)\",\n        },\n        {\n            content: \"Focus the text in full composer\",\n            trigger: \".o_mail_composer_message .odoo-editor-editable\",\n            run: \"click\",\n        },\n        {\n            content: \"Select the text in full composer\",\n            trigger: \".o_mail_composer_message .odoo-editor-editable\",\n            run: \"dblclick\",\n        },\n        {\n            trigger: \".o-we-toolbar\",\n        },\n        {\n            content: \"Remove the Bold\",\n            trigger: \".o-we-toolbar button[title='Toggle bold']\",\n            run: \"click\",\n        },\n        {\n            content: \"Italicize the text\",\n            trigger: \".o-we-toolbar button[title='Toggle italic']\",\n            run: \"click\",\n        },\n        {\n            content: \"The italicized text is in the full composer\",\n            trigger: \".o_mail_composer_message em:contains(Hello)\",\n        },\n        {\n            content: \"Close full composer\",\n            trigger: \".btn-close\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on Send Message\",\n            trigger: \"button:not(.active):contains(Send message)\",\n            run: \"click\",\n        },\n        {\n            content: \"The italicized text is in the composer\",\n            trigger: \".o-mail-Composer-html.odoo-editor-editable em:contains(Hello)\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { contains, scroll } from \"@web/../tests/utils\";\n\nregistry.category(\"web_tour.tours\").add(\"mail_message_load_order_tour\", {\n    steps: () => [\n        {\n            trigger: \".o-mail-DiscussSidebarChannel:contains(MyTestChannel)\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-mail-Thread .o-mail-Message\",\n            async run() {\n                await contains(\".o-mail-Thread .o-mail-Message\", { count: 30 });\n                await contains(\".o-mail-Thread\", { scroll: \"bottom\" });\n            },\n        },\n        {\n            trigger: \"*[title='Pinned Messages']\",\n            run: \"click\",\n        },\n        {\n            content: \"Click on invisible jump (should hover card to be visible)\",\n            trigger: \".o-mail-MessageCard-jump:not(:visible)\",\n            run: \"click\",\n        },\n        {\n            // Messages depends on FETCH_LIMIT (currently set to 60) in\n            // the thread service. Thus, at first load the message range\n            // will be (31 - 60). This trigger ensures the next messages\n            // are fetched after jumping to the message.\n            trigger:\n                \".o-mail-Thread .o-mail-Message:first .o-mail-Message-textContent:not(:contains(31))\",\n            async run() {\n                await contains(\".o-mail-Thread .o-mail-Message\", { count: 31 });\n                await contains(\".o-mail-Thread\", { scroll: 0 });\n                // ensure 1 - 31 are loaded in order: 30 below and the\n                // one we're loading messages around.\n                const messages = Array.from(\n                    document.querySelectorAll(\".o-mail-Thread .o-mail-Message-content\")\n                ).map((el) => el.innerText);\n                for (let i = 0; i < 31; i++) {\n                    if (messages[i] !== (i + 1).toString()) {\n                        throw new Error(\"Wrong message order after loading around\");\n                    }\n                }\n                await scroll(\".o-mail-Thread\", \"bottom\");\n            },\n        },\n        {\n            // After jumping to the pinned message, the message range\n            // was (1 -31): 30 before (but none were found), 30 after\n            // and the pinned message itself. This trigger ensures the\n            // next messages are fetched after scrolling to the bottom.\n            trigger: \".o-mail-Thread .o-mail-Message .o-mail-Message-textContent:contains(17)\",\n            async run() {\n                await contains(\".o-mail-Thread .o-mail-Message\", { count: 60 });\n                // ensure 1 - 60  are loaded in order.\n                const messages = Array.from(\n                    document.querySelectorAll(\".o-mail-Thread .o-mail-Message-content\")\n                ).map((el) => el.innerText);\n                for (let i = 0; i < 60; i++) {\n                    if (messages[i] !== (i + 1).toString()) {\n                        throw new Error(\"Wrong message order after loading after\");\n                    }\n                }\n            },\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\nimport { delay } from \"@web/core/utils/concurrency\";\n\nregistry.category(\"web_tour.tours\").add(\"mail_template_dynamic_placeholder_tour\", {\n    url: \"/odoo\",\n    steps: () => [\n        stepUtils.showAppsMenuItem(),\n        {\n            content: 'Go into the Setting \"app\"',\n            trigger: '.o_app[data-menu-xmlid=\"base.menu_administration\"]',\n            run: \"click\",\n        },\n        {\n            content: \"Open email templates\",\n            trigger: 'button[name=\"open_mail_templates\"]',\n            run: \"click\",\n        },\n        {\n            content: \"Create a new email template\",\n            trigger: \"button.o_list_button_add\",\n            run: \"click\",\n        },\n        {\n            content: 'Insert # inside \"Subject\" input',\n            trigger: 'div[name=\"subject\"] input[type=\"text\"]',\n            run: \"edit(no_model_id #)\",\n        },\n        {\n            content: 'Select \"Contact\" model',\n            trigger: 'div[name=\"model_id\"] input[type=\"text\"]',\n            run: \"edit Contact\",\n        },\n        {\n            content: \"Wait for the autocomplete RPC\",\n            trigger: 'div[name=\"model_id\"] .ui-autocomplete:contains(\"Contact\")',\n            run: async () => {\n                await delay(300);\n            },\n        },\n        {\n            content: \"Click on contact\",\n            trigger: 'div[name=\"model_id\"] .ui-autocomplete',\n            run: async function () {\n                const contact = Array.from(\n                    document.querySelectorAll(\n                        'div[name=\"model_id\"] .ui-autocomplete .dropdown-item'\n                    )\n                ).find((el) => el.textContent === \"Contact\");\n                await contact.click();\n            },\n        },\n        {\n            content: \"Wait for the drop down to disappear\",\n            trigger: 'div[name=\"model_id\"] .o-autocomplete:not(:has(.ui-autocomplete))',\n            run: async () => {\n                // Ensure the system has registered a correct model value before\n                // we try to open the DPH.\n                // It seems that the autocomplete validation can be very slow.\n                await delay(200);\n            },\n        },\n        {\n            content: 'Retry insert # inside \"Subject\" input',\n            trigger: 'div[name=\"subject\"] input[type=\"text\"]',\n            run: \"edit (yes_model_id) && press #\",\n        },\n        {\n            content: \"Check if the dynamic placeholder popover is opened\",\n            trigger: \"div.o_model_field_selector_popover\",\n        },\n        {\n            content: \"filter the dph result\",\n            trigger: \"div.o_model_field_selector_popover_search input[type='text']\",\n            run: \"edit name\",\n        },\n        {\n            content: \"Click on the first entry of the dynamic placeholder\",\n            trigger: 'div.o_model_field_selector_popover button:contains(\"Company Name\")',\n            run: \"click\",\n        },\n        {\n            content: \"Enter a default value\",\n            trigger:\n                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type=\"text\"]',\n            run: \"edit defValue\",\n        },\n        {\n            content: \"Click on the insert button\",\n            trigger: \"div.o_model_field_selector_popover button:first-child\",\n            run: \"click\",\n        },\n        {\n            content: \"Wait for the popover to disappear\",\n            trigger: \"body:not(:has(.o_model_field_selector_popover))\",\n            run: \"click\",\n        },\n        {\n            content: \"Check if subject value was correctly updated\",\n            trigger: 'div[name=\"subject\"] input[type=\"text\"]',\n            run() {\n                const subjectValue = this.anchor.value;\n                const correctValue = \"yes_model_id {{object.company_name|||defValue}}\";\n                if (subjectValue !== correctValue) {\n                    console.error(\n                        `Email template should have \"${correctValue}\" in subject input (actual: ${subjectValue})`\n                    );\n                }\n            },\n        },\n        {\n            content: \"Insert text inside editable\",\n            trigger: \".note-editable.odoo-editor-editable\",\n            async run(actions) {\n                await actions.editor(`/`);\n                document.querySelector(\".note-editable\").dispatchEvent(\n                    new InputEvent(\"input\", {\n                        inputType: \"insertText\",\n                        data: \"/\",\n                    })\n                );\n            },\n        },\n        {\n            content: \"Click on the the dynamic placeholder powerBox options\",\n            trigger: \"div.o-we-powerbox .o-we-command:contains(Dynamic Placeholder)\",\n            run: \"click\",\n        },\n        {\n            content: \"Check if the dynamic placeholder popover is opened\",\n            trigger: \"div.o_model_field_selector_popover\",\n            run: \"click\",\n        },\n        {\n            content: \"filter the dph result\",\n            trigger: \"div.o_model_field_selector_popover_search input[type='text']\",\n            run: \"edit name\",\n        },\n        {\n            content: \"Click on the first entry of the dynamic placeholder\",\n            trigger: 'div.o_model_field_selector_popover button:contains(\"Company Name\")',\n            run: \"click\",\n        },\n        {\n            content: \"Enter a default value\",\n            trigger:\n                'div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type=\"text\"]',\n            run: \"edit defValue\",\n        },\n        {\n            content: \"Click on the insert button\",\n            trigger: \"div.o_model_field_selector_popover button:first-child\",\n            run: \"click\",\n        },\n        {\n            content: \"Ensure the editable contain the dynamic placeholder t tag\",\n            trigger: `.note-editable.odoo-editor-editable t[t-out=\"object.company_name\"]:contains(\"defValue\")`,\n        },\n        {\n            content: 'Type \"Push Notification Device\" model',\n            trigger: 'div[name=\"model_id\"] input[type=\"text\"]',\n            run: \"edit Push Notification Device\",\n        },\n        {\n            content: 'Select \"Push Notification Device\" model',\n            trigger: 'a.dropdown-item:contains(\"Push Notification Device\")',\n            run: \"click\",\n        },\n        {\n            content: \"Insert text inside editable\",\n            trigger: \".note-editable.odoo-editor-editable\",\n            async run(actions) {\n                await actions.editor(`/`);\n                document.querySelector(\".note-editable\").dispatchEvent(\n                    new InputEvent(\"input\", {\n                        inputType: \"insertText\",\n                        data: \"/\",\n                    })\n                );\n            },\n        },\n        {\n            content: \"Click on the the dynamic placeholder powerBox options\",\n            trigger: \"div.o-we-powerbox .o-we-command:contains(Dynamic Placeholder)\",\n            run: \"click\",\n        },\n        {\n            content: \"Check if the dynamic placeholder popover is opened\",\n            trigger: \"div.o_model_field_selector_popover\",\n            run: \"click\",\n        },\n        {\n            content: \"filter the dph result\",\n            trigger: \"div.o_model_field_selector_popover_search input[type='text']\",\n            run: \"edit created on\",\n        },\n        {\n            content: \"Click on the first entry of the dynamic placeholder\",\n            trigger:\n                'div.o_model_field_selector_popover li:first-child button:contains(\"Created on\")',\n            run: \"click\",\n        },\n        {\n            content: \"Enter a default value\",\n            trigger:\n                \"div.o_model_field_selector_popover .o_model_field_selector_default_value_input input[type='text']\",\n            run: \"edit localTime\",\n        },\n        {\n            content: \"Click on the insert button\",\n            trigger: \"div.o_model_field_selector_popover button:first-child:contains('Insert)\",\n            run: \"click\",\n        },\n        {\n            content: \"Ensure the editable contain the dynamic placeholder t tag\",\n            trigger: `.note-editable.odoo-editor-editable t[t-out=\"format_datetime(object.create_date, tz=object.partner_id.tz) or 'localTime'\"]:contains(\"localTime\")`,\n        },\n        {\n            content: \"Discard form changes\",\n            trigger: \"button.o_form_button_cancel\",\n            run: \"click\",\n        },\n        {\n            content: \"Wait for the form view to disappear\",\n            trigger: \"body:not(:has(.o_form_sheet))\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { click, contains } from \"@web/../tests/utils\";\n\n/**\n * Verify that a user can modify their own profile information.\n */\nregistry.category(\"web_tour.tours\").add(\"mail/static/tests/tours/user_modify_own_profile_tour.js\", {\n    steps: () => [\n        {\n            content: \"Open user account menu\",\n            trigger: \".o_user_menu button\",\n            run: \"click\",\n        },\n        {\n            content: \"Open preferences / profile screen\",\n            trigger: \"[data-menu=preferences]\",\n            run: \"click\",\n        },\n        {\n            content: \"Update the notification type\",\n            trigger: '.modal div[name=\"notification_type\"] input[data-value=\"inbox\"]',\n            async run() {\n                await click('.modal div[name=\"notification_type\"] input[data-value=\"inbox\"]');\n                await contains(\".o_form_dirty\", { count: 1 });\n            },\n        },\n        {\n            content: \"Save the form\",\n            trigger: 'button[name=\"preference_save\"]',\n            run: \"click\",\n        },\n        {\n            content: \"Wait until the modal is closed\",\n            trigger: \"body:not(.modal-open)\",\n            async run() {\n                await contains(\".o_form_dirty\", { count: 0 });\n            },\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"portal_load_homepage\", {\n    url: \"/my\",\n    steps: () => [\n        {\n            content: \"Check portal is loaded\",\n            trigger: 'a[href*=\"/my/account\"]:contains(\"Edit\"):first',\n            run: \"click\",\n            expectUnloadPage: true,\n        },\n        {\n            content: \"Load my account details\",\n            trigger: 'input[value=\"Joel Willis\"]',\n            run: \"click\",\n        },\n        {\n            content: \"type a different phone number\",\n            trigger: 'input[name=\"phone\"]',\n            run: \"edit +1 555 666 7788\",\n        },\n        {\n            content: \"Submit the form\",\n            trigger: \"button[id=save_address]\",\n            run: \"click\",\n            expectUnloadPage: true,\n        },\n        {\n            content: \"Check that we are back on the portal\",\n            trigger: 'a[href*=\"/my/account\"]:contains(\"Edit\"):first',\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"skip_to_content\", {\n    url: \"/\",\n    steps: () => [\n        {\n            content: \"Make sure that Skip to Content button is on top of all the links present in header\",\n            trigger: \"a:first-child[class~='o_skip_to_content']\",\n            run: \"click\"\n        },\n        {\n            content: \"Check if we have been redirected to #wrap\",\n            trigger: \"body\",\n            run: () => {\n                if (!window.location.href.endsWith(\"#wrap\")) {\n                    console.error(\"We should be on #wrap.\");\n                }\n            }\n        }\n    ]\n});\n", "export function addSectionFromProductCatalog() {\n    return [\n        {\n            content: \"Click Catalog Button\",\n            trigger: 'button[name=action_add_from_catalog]',\n            run: 'click',\n        },\n        {\n            content: \"Click 'Add Section' button\",\n            trigger: '.o_search_panel_sections button:contains(\"+ Add Section\")',\n            run: 'click',\n        },\n        {\n            content: \"Type new section name\",\n            trigger: 'input.o_section_input',\n            run: 'edit Section A',\n        },\n        {\n            content: \"Click anywhere to add the section\",\n            trigger: '.o_search_panel',\n            run: 'click',\n        },\n        {\n            content: \"Check section A is selected\",\n            trigger: '.o_search_panel_sections .o_selected_section:contains(\"Section A\")',\n        },\n        {\n            content: \"Add a Product\",\n            trigger: '.o_kanban_record:contains(\"Test Product\")',\n            run: function () {\n                setTimeout(() => {\n                    [...document.querySelectorAll('.o_kanban_record')].find(el =>\n                        el.textContent.includes('Test Product')\n                    )?.click();\n                }, 1000);\n            },\n        },\n        {\n            content: \"Wait for product to be added\",\n            trigger: '.o_kanban_record:contains(\"Test Product\"):not(:has(.fa-shopping-cart))',\n        },\n        {\n            content: \"Close the catalog\",\n            trigger: '.o-kanban-button-back',\n            run: 'click',\n        },\n        {\n            content: \"Ensure Section is first row\",\n            trigger: '.o_section_and_note_list_view tr:nth-child(1).o_is_line_section',\n        },\n        {\n            content: \"Ensure Product is second row\",\n            trigger: 'tbody tr:nth-child(2) .o_field_product_label_section_and_note_cell:contains(\"Test Product\")',\n        },\n    ];\n}\n", "import { addSectionFromProductCatalog } from \"@account/js/tours/tour_utils\";\nimport { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"test_use_product_catalog_on_invoice\", {\n    steps: () => [\n        {\n            content: \"Click Catalog Button\",\n            trigger: \"button[name=action_add_from_catalog]\",\n            run: \"click\",\n        },\n        {\n            content: \"Add a Product\",\n            trigger: \".o_kanban_record:contains(Test Product)\",\n            run: \"click\",\n        },\n        {\n            content: \"Wait for it\",\n            trigger: \".o_product_added\",\n        },\n        {\n            content: \"Back to Invoice\",\n            trigger: \".o-kanban-button-back\",\n            run: \"click\",\n        },\n        {\n            content: \"Ensure product is added\",\n            trigger: \".o_field_product_label_section_and_note_cell:contains(Test Product)\",\n        },\n    ],\n});\n\nregistry.category(\"web_tour.tours\").add('test_add_section_from_product_catalog_on_invoice', {\n    steps: () => addSectionFromProductCatalog()\n});\n", "import { registry } from '@web/core/registry';\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add(\"deductible_amount_column\", {\n    url: \"/odoo/vendor-bills/new\",\n    steps: () => [\n    {\n        content: \"Add item\",\n        trigger: \"div[name='invoice_line_ids'] .o_field_x2many_list_row_add a:contains('Add a line')\",\n        run: \"click\",\n    },\n    {\n        content: \"Edit name\",\n        trigger: \".o_field_widget[name='name'] .o_input\",\n        run: \"edit Laptop\"\n    },\n    {\n        content: \"Edit deductible amount\",\n        trigger: \".o_field_widget[name='deductible_amount'] > .o_input\",\n        run: \"edit 80\"\n    },\n    ...stepUtils.saveForm(),\n]})\n", "import { accountTourSteps } from \"@account/js/tours/account\";\nimport { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add('account_tax_group', {\n    url: \"/odoo\",\n    steps: () => [\n    ...accountTourSteps.goToAccountMenu(\"Go to Invoicing\"),\n    {\n        content: \"Go to Vendors\",\n        trigger: 'span:contains(\"Vendors\")',\n        run: \"click\",\n    },\n    {\n        content: \"Go to Bills\",\n        trigger: 'a:contains(\"Bills\")',\n        run: \"click\",\n    },\n    {\n        trigger: \".o_breadcrumb .text-truncate:contains(Bills)\",\n    },\n    {\n        content: \"Create new bill\",\n        trigger: '.o_control_panel_main_buttons .o_list_button_add',\n        run: \"click\",\n    },\n    // Set a vendor\n    {\n        content: \"Add vendor\",\n        trigger: 'div.o_field_widget.o_field_res_partner_many2one[name=\"partner_id\"] div input',\n        run: \"edit Account Tax Group Partner\",\n    },\n    {\n        content: \"Valid vendor\",\n        trigger: '.ui-menu-item a:contains(\"Account Tax Group Partner\")',\n        run: \"click\",\n    },\n    // Show product column\n    {\n        content: \"Open line fields list\",\n        trigger: \".o_optional_columns_dropdown_toggle\",\n        run: \"click\"\n    },\n    {\n        content: \"Show product column\",\n        trigger: '.o-dropdown-item input[name=\"product_id\"]',\n        run: \"click\"\n    },\n    {\n        content: \"Close line fields list\",\n        trigger: \".o_optional_columns_dropdown_toggle\",\n        run: \"click\"\n    },\n    // Add First product\n    {\n        content: \"Add items\",\n        trigger: 'div[name=\"invoice_line_ids\"] .o_field_x2many_list_row_add a:contains(\"Add a line\")',\n        run: \"click\",\n    },\n    {\n        content: \"Select input\",\n        trigger: 'div[name=\"invoice_line_ids\"] .o_selected_row .o_list_many2one[name=\"product_id\"] input',\n        run: \"edit Account Tax Group Product\",\n    },\n    {\n        content: \"Valid item\",\n        trigger: '.ui-menu-item-wrapper:contains(\"Account Tax Group Product\")',\n        run: \"click\",\n    },\n    // Save account.move\n    ...stepUtils.saveForm(),\n    // Edit tax group amount\n    {\n        content: \"Edit tax group amount\",\n        trigger: '.o_tax_group_edit',\n        run: \"click\",\n    },\n    {\n        content: \"Modify the input value\",\n        trigger: '.o_tax_group_edit_input input',\n        run() {\n            this.anchor.value = 200;\n            this.anchor.select();\n            this.anchor.blur();\n        },\n    },\n    // Check new value for total (with modified tax_group_amount).\n    {\n        content: \"Valid total amount\",\n        trigger: 'span[name=\"amount_total\"]:contains(\"800\")',\n        run: \"click\",\n    },\n    // Modify the quantity of the object\n    {\n        content: \"Select item quantity\",\n        trigger: 'div[name=\"invoice_line_ids\"] tbody tr.o_data_row .o_list_number[name=\"quantity\"]',\n        run: \"click\",\n    },\n    {\n        content: \"Change item quantity\",\n        trigger: 'div[name=\"invoice_line_ids\"] tbody tr.o_data_row .o_list_number[name=\"quantity\"] input',\n        run: \"edit 2\",\n    },\n    {\n        content: \"Valid the new value\",\n        trigger: 'div[name=\"invoice_line_ids\"] tbody tr.o_data_row .o_list_number[name=\"quantity\"] input',\n        run: \"press Enter\",\n    },\n    // Check new tax group value\n    {\n        content: \"Check new value of tax group\",\n        trigger: '.o_tax_group_amount_value:contains(\"120\")',\n        run: \"click\",\n    },\n    // Save form\n    ...stepUtils.saveForm(),\n    // Check new tax group value\n    {\n        content: \"Check new value of tax group\",\n        trigger: '.o_tax_group_amount_value:contains(\"120\")',\n        run: \"click\",\n    },\n    {\n        content: \"Edit tax value\",\n        trigger: '.o_tax_group_edit_input input',\n        run: \"edit 2 && click body\",\n    },\n    {\n        content: \"Check new value of total\",\n        trigger: '.oe_subtotal_footer_separator:contains(\"1,202\")',\n        run: \"click\",\n    },\n    {\n        content: \"Discard changes\",\n        trigger: '.o_form_button_cancel',\n        run: \"click\",\n    },\n    {\n        content: \"Check tax value is reset\",\n        trigger: '.o_tax_group_amount_value:contains(\"120\")',\n    },\n]});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add('tests_shared_js_python', {\n    url: \"/account/init_tests_shared_js_python\",\n    steps: () => [\n    {\n        content: \"Click\",\n        trigger: 'button',\n        run: \"click\",\n    },\n    {\n        content: \"Wait\",\n        trigger: 'button.text-success',\n        timeout: 3000,\n    },\n]});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add(\"mail_attachment_removal_tour\", {\n    steps: () => [\n\n    {\n        content: \"click on send by email\",\n        trigger: \".o_statusbar_buttons > button[name='action_quotation_send']\",\n        run: \"click\"\n    },\n    {\n        content: \"save a new layout\",\n        trigger: \".o_technical_modal button[name='document_layout_save']\",\n        run: \"click\"\n    },\n    {\n        content: \"delete attachment\",\n        trigger: \".o_field_widget[name='attachment_ids'] li > button .fa-times\",\n        run: \"click\"\n    },\n    {\n        content: \"send the email\",\n        trigger: \".o_mail_send\",\n        run: \"click\"\n    },\n    {\n        content: \"confirm quotation\",\n        trigger: \"button[name='action_confirm']\",\n        run: \"click\"\n    }\n]\n})\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nconst openProductAttribute = (product_attribute) => [\n    ...stepUtils.goToAppSteps(\"sale.sale_menu_root\", \"Go to the Sales App\"),\n    {\n        content: 'Open configuration menu',\n        trigger: '.o-dropdown[data-menu-xmlid=\"sale.menu_sale_config\"]',\n        run: \"click\",\n    },\n    {\n        content: 'Navigate to product attribute list view',\n        trigger: '.o-dropdown-item[data-menu-xmlid=\"sale.menu_product_attribute_action\"]',\n        run: \"click\",\n    },\n    {\n        content: `Navigate to ${product_attribute}`,\n        trigger: `.o_data_cell[data-tooltip=${product_attribute}]`,\n        run: \"click\",\n    },\n];\nconst deletePAV = (product_attribute_value, message) => [\n    {\n        content: 'Click delete button',\n        trigger: `.o_data_cell[data-tooltip=${product_attribute_value}] ~ .o_list_record_remove`,\n        run: \"click\",\n    },\n    {\n        content: 'Check correct message in modal',\n        trigger: message || '.modal-title:contains(\"Bye-bye, record!\")',\n        run: \"click\",\n    },\n    {\n        content: 'Close modal',\n        trigger: '.btn-close',\n        run: \"click\",\n    }\n]\n\n// This tour relies on data created on the Python test.\nregistry.category(\"web_tour.tours\").add('delete_product_attribute_value_tour', {\n    url: '/odoo',\n    steps: () => [\n        ...openProductAttribute(\"PA\"),\n        // Test error message on a used attribute value\n        ...deletePAV(\"pa_value_1\", \".text-prewrap:contains('pa_value_1')\"),\n        // Test deletability of a used attribute value on archived product\n        ...deletePAV(\"pa_value_2\"),\n        // Test deletability of a removed attribute value on product\n        ...deletePAV(\"pa_value_3\"),\n        {\n            content: 'Check test finished',\n            trigger: 'a:contains(\"Attributes\")',\n        }\n    ]\n});\n", "import { addSectionFromProductCatalog } from \"@account/js/tours/tour_utils\";\nimport { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add('sale_catalog', {\n    steps: () => [\n        {\n            content: \"Create a new SO\",\n            trigger: '.o_list_button_add',\n            run: 'click',\n        },\n        {\n            content: \"Select the customer field\",\n            trigger: \".o_field_res_partner_many2one input.o_input\",\n            run: 'click',\n        },\n        {\n            content: \"Wait for the field to be active\",\n            trigger: \".o_field_res_partner_many2one input[aria-expanded=true]\",\n        },\n        {\n            content: \"Select a customer from the dropdown\",\n            trigger: \".o_field_res_partner_many2one .dropdown-item:not([id$='_loading']):first\",\n            run: 'click',\n        },\n        {\n            content: \"Open product catalog\",\n            trigger: 'button[name=\"action_add_from_catalog\"]',\n            run: 'click',\n        },\n        {\n            content: \"Type 'Restricted' into the search bar\",\n            trigger: 'input.o_searchview_input',\n            run: \"edit Restricted\",\n        },\n        {\n            content: \"Search for the product\",\n            trigger: 'input.o_searchview_input',\n            run: \"press Enter\",\n        },\n        {\n            content: \"Wait for catalog rendering\",\n            trigger: '.o_kanban_record:contains(\"Restricted Product\")',\n        },\n        {\n            content: \"Wait for filtering\",\n            trigger: '.o_kanban_renderer:not(:has(.o_kanban_record:contains(\"AAA Product\")))',\n        },\n        {\n            content: \"Add the product to the SO\",\n            trigger: '.o_kanban_record:contains(\"Restricted Product\") .fa-shopping-cart',\n            run: 'click',\n        },\n        {\n            content: \"Wait for product to be added\",\n            trigger: '.o_kanban_record:contains(\"Restricted Product\"):not(:has(.fa-shopping-cart))',\n        },\n        {\n            content: \"Input a custom quantity\",\n            trigger: '.o_kanban_record:contains(\"Restricted Product\") .o_input',\n            run: \"edit 6\",\n        },\n        {\n            content: \"Increase the quantity\",\n            trigger: '.o_kanban_record:contains(\"Restricted Product\") .fa-plus',\n            run: 'click',\n        },\n        {\n            content: \"Close the catalog\",\n            trigger: '.o-kanban-button-back',\n            run: 'click',\n        },\n    ]\n});\n\nregistry.category(\"web_tour.tours\").add('test_add_section_from_product_catalog_on_sale_order', {\n    steps: () => [\n        {\n            content: \"Create a new SO\",\n            trigger: '.o_list_button_add',\n            run: 'click',\n        },\n        {\n            content: \"Select the customer field\",\n            trigger: '.o_field_res_partner_many2one input.o_input',\n            run: 'click',\n        },\n        {\n            content: \"Wait for the field to be active\",\n            trigger: '.o_field_res_partner_many2one input[aria-expanded=true]',\n        },\n        {\n            content: \"Select a customer from the dropdown\",\n            trigger: '.o_field_res_partner_many2one .dropdown-item:not([id$=\"_loading\"]):first',\n            run: 'click',\n        },\n        ...addSectionFromProductCatalog(),\n    ]\n});\n", "import { registry } from '@web/core/registry';\nimport { stepUtils } from '@web_tour/tour_utils';\nimport comboConfiguratorTourUtils from '@sale/js/tours/combo_configurator_tour_utils';\nimport productConfiguratorTourUtils from '@sale/js/tours/product_configurator_tour_utils';\nimport tourUtils from '@sale/js/tours/tour_utils';\n\nregistry\n    .category('web_tour.tours')\n    .add('sale_combo_configurator', {\n        url: '/odoo',\n        steps: () => [\n            ...stepUtils.goToAppSteps('sale.sale_menu_root', \"Open the sales app\"),\n            ...tourUtils.createNewSalesOrder(),\n            ...tourUtils.selectCustomer(\"Test Partner\"),\n            ...tourUtils.addProduct(\"Combo product\"),\n            // Assert that the combo configurator has the correct data.\n            comboConfiguratorTourUtils.assertComboCount(2),\n            comboConfiguratorTourUtils.assertComboItemCount(\"Combo A\", 2),\n            comboConfiguratorTourUtils.assertComboItemCount(\"Combo B\", 2),\n            // Assert that price changes when the quantity is updated.\n            comboConfiguratorTourUtils.assertQuantity(1),\n            comboConfiguratorTourUtils.assertPrice('25.00'),\n            comboConfiguratorTourUtils.increaseQuantity(),\n            comboConfiguratorTourUtils.assertQuantity(2),\n            comboConfiguratorTourUtils.assertPrice('50.00'),\n            comboConfiguratorTourUtils.decreaseQuantity(),\n            comboConfiguratorTourUtils.assertQuantity(1),\n            comboConfiguratorTourUtils.assertPrice('25.00'),\n            comboConfiguratorTourUtils.setQuantity(3),\n            comboConfiguratorTourUtils.assertQuantity(3),\n            comboConfiguratorTourUtils.assertPrice('75.00'),\n            // Assert that the combo configurator can only be saved after selecting an item for each\n            // combo.\n            comboConfiguratorTourUtils.assertConfirmButtonDisabled(),\n            comboConfiguratorTourUtils.selectComboItem(\"Product A2\"),\n            comboConfiguratorTourUtils.selectComboItem(\"Product B2\"),\n            comboConfiguratorTourUtils.assertConfirmButtonEnabled(),\n            // Assert that the product configurator is opened when a product with configurable\n            // `no_variant` PTALs is selected.\n            comboConfiguratorTourUtils.selectComboItem(\"Product A1\"),\n            productConfiguratorTourUtils.selectAttribute(\"Product A1\", \"No variant attribute\", \"A\"),\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            // Assert that the extra price of a combo item is applied correctly.\n            comboConfiguratorTourUtils.assertPrice('90.00'),\n            // Assert that the extra price of a `no_variant` PTAV is applied correctly.\n            comboConfiguratorTourUtils.selectComboItem(\"Product A1\"),\n            ...productConfiguratorTourUtils.selectAndSetCustomAttribute(\n                \"Product A1\", \"No variant attribute\", \"B\", \"Some custom value\"\n            ),\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            comboConfiguratorTourUtils.assertPrice('93.00'),\n            // Assert that the order's content is correct.\n            ...comboConfiguratorTourUtils.saveConfigurator(),\n            tourUtils.checkSOLDescriptionContains(\"Combo product x 3\"),\n            tourUtils.checkSOLDescriptionContains(\n                \"Product A1\", \"No variant attribute: B: Some custom value\"\n            ),\n            tourUtils.checkSOLDescriptionContains(\"Product B2\"),\n            {\n                content: \"Verify the combo item quantities\",\n                trigger: 'td[name=\"product_uom_qty\"]:contains(3.00)',\n            },\n            {\n                content: \"Verify the first combo item's unit price\",\n                trigger: 'td[name=\"price_unit\"]:contains(18.50)',\n            },\n            {\n                content: \"Verify the second combo item's unit price\",\n                trigger: 'td[name=\"price_unit\"]:contains(12.50)',\n            },\n            {\n                content: \"Verify the order's total price\",\n                trigger: 'div.oe_subtotal_footer:contains(93.00)',\n            },\n            // Assert that the combo configurator is opened with the previous selection when the\n            // combo is edited.\n            tourUtils.editLineMatching(\"Combo product x 3\"),\n            tourUtils.editConfiguration(),\n            comboConfiguratorTourUtils.setQuantity(2),\n            comboConfiguratorTourUtils.assertComboItemSelected(\"Product A1\"),\n            comboConfiguratorTourUtils.assertComboItemSelected(\"Product B2\"),\n            comboConfiguratorTourUtils.selectComboItem(\"Product A2\"),\n            // Assert that the order's content has been updated.\n            ...comboConfiguratorTourUtils.saveConfigurator(),\n            tourUtils.checkSOLDescriptionContains(\"Combo product x 2\"),\n            tourUtils.checkSOLDescriptionContains(\"Product A2\"),\n            tourUtils.checkSOLDescriptionContains(\"Product B2\"),\n            {\n                content: \"Verify the combo item quantities\",\n                trigger: 'td[name=\"product_uom_qty\"]:contains(2.00)',\n            },\n            {\n                content: \"Verify the first combo item's unit price\",\n                trigger: 'td[name=\"price_unit\"]:contains(12.50)',\n            },\n            {\n                content: \"Verify the second combo item's unit price\",\n                trigger: 'td[name=\"price_unit\"]:contains(12.50)',\n            },\n            {\n                content: \"Verify the order's total price\",\n                trigger: 'div.oe_subtotal_footer:contains(50.00)',\n            },\n            // Don't end the tour with a form in edition mode.\n            ...stepUtils.saveForm(),\n        ],\n    });\n\n    registry\n    .category('web_tour.tours')\n    .add('sale_combo_configurator_with_optional_products', {\n        url: '/odoo',\n        steps: () => [\n            ...stepUtils.goToAppSteps('sale.sale_menu_root', \"Open the sales app\"),\n            ...tourUtils.createNewSalesOrder(),\n            ...tourUtils.selectCustomer(\"Test Partner\"),\n            ...tourUtils.addProduct(\"Combo product\"),\n            comboConfiguratorTourUtils.selectComboItem(\"Product B2\"),\n            ...comboConfiguratorTourUtils.saveConfigurator(),\n            productConfiguratorTourUtils.addOptionalProduct(\"Optional product\"),\n            {\n                content: \"verify that we cannot reduce main product quantity\",\n                trigger: ':not(button[name=\"sale_quantity_button_minus\"])',\n            },\n            {\n                content: \"verify that we cannot increase main product quantity\",\n                trigger: ':not(button[name=\"sale_quantity_button_plus\"])',\n            },\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            tourUtils.checkSOLDescriptionContains(\"Combo product\"),\n            tourUtils.checkSOLDescriptionContains(\"Product B2\"),\n            tourUtils.checkSOLDescriptionContains(\"Optional product\"),\n            // Don't end the tour with a form in edition mode.\n            ...stepUtils.saveForm(),\n        ],\n    });\n", "import { registry } from '@web/core/registry';\nimport { stepUtils } from '@web_tour/tour_utils';\nimport comboConfiguratorTourUtils from '@sale/js/tours/combo_configurator_tour_utils';\nimport productConfiguratorTourUtils from '@sale/js/tours/product_configurator_tour_utils';\nimport tourUtils from '@sale/js/tours/tour_utils';\n\nregistry\n    .category('web_tour.tours')\n    .add('sale_combo_configurator_preconfigure_unconfigurable_ptals', {\n        url: '/odoo',\n        steps: () => [\n            ...stepUtils.goToAppSteps('sale.sale_menu_root', \"Open the sales app\"),\n            ...tourUtils.createNewSalesOrder(),\n            ...tourUtils.selectCustomer(\"Test Partner\"),\n            ...tourUtils.addProduct(\"Combo product\"),\n            {\n                content: \"Verify that unconfigurable ptals are preconfigured\",\n                trigger: `${comboConfiguratorTourUtils.comboItemSelector(\"Test product\")}:contains(\"Attribute A: A\")`,\n            },\n            {\n                content: \"Verify that configurable ptals aren't preconfigured\",\n                trigger: `${comboConfiguratorTourUtils.comboItemSelector(\"Test product\")}:not(:contains(\"Attribute B: B\"))`,\n            },\n            comboConfiguratorTourUtils.selectComboItem(\"Test product\"),\n            productConfiguratorTourUtils.selectAttribute(\n                \"Test product\", \"Attribute B\", \"B\", 'multi'\n            ),\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            {\n                content: \"Verify that configurable ptals are now configured\",\n                trigger: `${comboConfiguratorTourUtils.comboItemSelector(\"Test product\")}:contains(\"Attribute B: B\")`,\n            },\n            ...comboConfiguratorTourUtils.saveConfigurator(),\n            // Don't end the tour with a form in edition mode.\n            ...stepUtils.saveForm(),\n        ],\n    });\n", "import { registry } from '@web/core/registry';\nimport { stepUtils } from '@web_tour/tour_utils';\nimport comboConfiguratorTourUtils from '@sale/js/tours/combo_configurator_tour_utils';\nimport productConfiguratorTourUtils from '@sale/js/tours/product_configurator_tour_utils';\nimport tourUtils from '@sale/js/tours/tour_utils';\n\nregistry\n    .category('web_tour.tours')\n    .add('sale_combo_configurator_preselect_single_unconfigurable_items', {\n        url: '/odoo',\n        steps: () => [\n            ...stepUtils.goToAppSteps('sale.sale_menu_root', \"Open the sales app\"),\n            ...tourUtils.createNewSalesOrder(),\n            ...tourUtils.selectCustomer(\"Test Partner\"),\n            ...tourUtils.addProduct(\"Combo product\"),\n            // Assert that only single unconfigurable items are preselected.\n            comboConfiguratorTourUtils.assertPreselectedComboItemCount(2),\n            comboConfiguratorTourUtils.assertComboItemPreselected(\"Product A\"),\n            comboConfiguratorTourUtils.assertComboItemPreselected(\"Product C\"),\n            comboConfiguratorTourUtils.assertConfirmButtonDisabled(),\n            // Configure the remaining combos.\n            comboConfiguratorTourUtils.selectComboItem(\"Product B\"),\n            productConfiguratorTourUtils.selectAttribute(\"Product B\", \"Attribute B\", \"B\", 'multi'),\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            comboConfiguratorTourUtils.selectComboItem(\"Product D\"),\n            productConfiguratorTourUtils.setCustomAttribute(\n                \"Product D\", \"Attribute D\", \"Test D\"\n            ),\n            ...productConfiguratorTourUtils.saveConfigurator(),\n            comboConfiguratorTourUtils.selectComboItem(\"Product E1\"),\n            comboConfiguratorTourUtils.assertConfirmButtonEnabled(),\n            ...comboConfiguratorTourUtils.saveConfigurator(),\n            // Don't end the tour with a form in edition mode.\n            ...stepUtils.saveForm(),\n        ],\n    });\n", "import { registry } from '@web/core/registry';\nimport { stepUtils } from '@web_tour/tour_utils';\nimport productConfiguratorTourUtils from '@sale/js/tours/product_configurator_tour_utils';\nimport tourUtils from '@sale/js/tours/tour_utils';\n\nregistry.category('web_tour.tours').add('sale_order_keep_uom_on_variant_wizard_quantity_change', {\n    steps: () => [\n        tourUtils.editLineMatching(\"Sofa\"),\n        tourUtils.editConfiguration(),\n        productConfiguratorTourUtils.increaseProductQuantity(\"Sofa\"),\n        ...productConfiguratorTourUtils.saveConfigurator(),\n        ...stepUtils.saveForm(),\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\nimport { redirect } from \"@web/core/utils/urls\";\n\n// This tour relies on data created on the Python test.\nregistry.category(\"web_tour.tours\").add('sale_signature', {\n    url: '/my/quotes',\n    steps: () => [\n    {\n        content: \"open the test SO\",\n        trigger: 'a:text(test SO)',\n        run: \"click\",\n        expectUnloadPage: true,\n    },\n    {\n        content: \"click sign\",\n        trigger: 'a:contains(\"Sign\")',\n        run: \"click\",\n    },\n    {\n        content: \"check submit is enabled\",\n        trigger: '.o_portal_sign_submit:enabled',\n    },\n    {\n        trigger: \".modal .o_web_sign_name_and_signature input:value(Joel Willis)\"\n    },\n    {\n        trigger: \".modal canvas.o_web_sign_signature\",\n        run: \"canvasNotEmpty\",\n    },\n    {\n        content: \"click select style\",\n        trigger: '.modal .o_web_sign_auto_select_style button',\n        run: \"click\",\n    },\n    {\n        content: \"click style 4\",\n        trigger: \".o-dropdown-item:eq(3)\",\n        run: \"click\",\n    },\n    {\n        content: \"click submit\",\n        trigger: '.modal .o_portal_sign_submit:enabled',\n        run: \"click\",\n        expectUnloadPage: true,\n    },\n    {\n        content: \"check it's confirmed\",\n        trigger: '#quote_content:contains(\"Thank You\")',\n        run: \"click\",\n    }, {\n        trigger: '#quote_content',\n        run: function () {\n            redirect(\"/odoo\");\n        },  // Avoid race condition at the end of the tour by returning to the home page.\n        expectUnloadPage: true,\n    },\n    {\n        trigger: 'nav',\n    }\n]});\n\nregistry.category(\"web_tour.tours\").add(\"sale_signature_without_name\", {\n    steps: () => [\n        {\n            content: \"Sign & Pay\",\n            trigger:\n                \".o_portal_sale_sidebar .btn-primary, :iframe .o_portal_sale_sidebar .btn-primary\",\n            run: \"click\",\n        },\n        {\n            content: \"click submit\",\n            trigger: \".o_portal_sign_submit:enabled, :iframe .o_portal_sign_submit:enabled\",\n            run: \"click\",\n        },\n        {\n            content: \"check error because no name\",\n            trigger:\n                '.o_portal_sign_error_msg:contains(\"Signature is missing.\"), :iframe .o_portal_sign_error_msg:contains(\"Signature is missing.\")',\n        },\n    ],\n});\n", "function comboSelector(comboName) {\n    return `\n        .sale-combo-configurator-dialog\n        [name=\"sale_combo_configurator_title\"]:contains(\"${comboName}\")\n    `;\n}\n\nfunction comboItemSelector(comboItemName, extraClasses=[]) {\n    const extraClassesSelector = extraClasses.map(extraClass => `.${extraClass}`).join('');\n    return `\n        .sale-combo-configurator-dialog\n        .product-card${extraClassesSelector}:has(h6:contains(\"${comboItemName}\"))\n    `;\n}\n\nfunction assertComboCount(count) {\n    return {\n        content: `Assert that there are ${count} combos`,\n        trigger: '.sale-combo-configurator-dialog',\n        run() {\n            const selector = `.sale-combo-configurator-dialog [name=\"sale_combo_configurator_title\"]`;\n            if (document.querySelectorAll(selector).length !== count) {\n                console.error(`Assertion failed`);\n            }\n        },\n    };\n}\n\nfunction assertComboItemCount(comboName, count) {\n    return {\n        content: `Assert that there are ${count} combo items in combo ${comboName}`,\n        trigger: comboSelector(comboName),\n        run({ queryAll }) {\n            const selector = `${comboSelector(comboName)} + .row .product-card`;\n            if (queryAll(selector).length !== count) {\n                console.error(`Assertion failed`);\n            }\n        },\n    };\n}\n\nfunction assertSelectedComboItemCount(count) {\n    return {\n        content: `Assert that there are ${count} selected combo items`,\n        trigger: '.sale-combo-configurator-dialog',\n        run() {\n            const selector = `.sale-combo-configurator-dialog .row .product-card.selected`;\n            if (document.querySelectorAll(selector).length !== count) {\n                console.error(`Assertion failed`);\n            }\n        },\n    };\n}\n\nfunction assertPreselectedComboItemCount(count) {\n    return {\n        content: `Assert that there are ${count} preselected combo items`,\n        trigger: '.sale-combo-configurator-dialog',\n        run() {\n            const selector = '.sale-combo-configurator-dialog div[name=\"preselected_product_name\"]';\n            if (document.querySelectorAll(selector).length !== count) {\n                console.error(`Assertion failed`);\n            }\n        },\n    };\n}\n\nfunction selectComboItem(comboItemName) {\n    return {\n        content: `Select combo item ${comboItemName}`,\n        trigger: comboItemSelector(comboItemName),\n        run: 'click',\n    };\n}\n\nfunction assertComboItemSelected(comboItemName) {\n    return {\n        content: `Assert that combo item ${comboItemName} is selected`,\n        trigger: comboItemSelector(comboItemName, ['selected']),\n    };\n}\n\nfunction assertComboItemPreselected(comboItemName) {\n    return {\n        content: `Assert that combo item ${comboItemName} is preselected`,\n        trigger: `[name=\"preselected_product_name\"]:contains(${comboItemName})`,\n    };\n}\n\nfunction increaseQuantity() {\n    return {\n        content: \"Increase the combo quantity\",\n        trigger: '.sale-combo-configurator-dialog button[name=\"sale_quantity_button_plus\"]',\n        run: 'click',\n    };\n}\n\nfunction decreaseQuantity() {\n    return {\n        content: \"Decrease the combo quantity\",\n        trigger: '.sale-combo-configurator-dialog button[name=\"sale_quantity_button_minus\"]',\n        run: 'click',\n    };\n}\n\nfunction setQuantity(quantity) {\n    return {\n        content: `Set the combo quantity to ${quantity}`,\n        trigger: '.sale-combo-configurator-dialog input[name=\"sale_quantity\"]',\n        run: `edit ${quantity} && click .modal-body`,\n    };\n}\n\nfunction assertQuantity(quantity) {\n    return {\n        content: `Assert that the combo quantity is ${quantity}`,\n        trigger: `.sale-combo-configurator-dialog input[name=\"sale_quantity\"]:value(${quantity})`,\n    };\n}\n\nfunction assertPrice(price) {\n    return {\n        content: `Assert that the price is ${price}`,\n        trigger: `\n            .sale-combo-configurator-dialog\n            [name=\"sale_combo_configurator_total\"]:contains(\"${price}\")\n        `,\n    };\n}\n\nfunction assertPriceInfo(priceInfo) {\n    return {\n        content: `Assert that the price info is ${priceInfo}`,\n        trigger: `.sale-combo-configurator-dialog footer.modal-footer:contains(\"${priceInfo}\")`,\n    };\n}\n\nfunction assertFooterButtonsDisabled() {\n    return {\n        content: \"Assert that the footer buttons are disabled\",\n        trigger: '.sale-combo-configurator-dialog footer.modal-footer button:disabled',\n    };\n}\n\nfunction assertFooterButtonsEnabled() {\n    return {\n        content: \"Assert that the footer buttons are enabled\",\n        trigger: '.sale-combo-configurator-dialog footer.modal-footer button:enabled',\n    };\n}\n\nfunction assertConfirmButtonDisabled() {\n    return {\n        content: \"Assert that the confirm button is disabled\",\n        trigger: `\n            .sale-combo-configurator-dialog\n            button[name=\"sale_combo_configurator_confirm_button\"]:disabled\n        `,\n    };\n}\n\nfunction assertConfirmButtonEnabled() {\n    return {\n        content: \"Assert that the confirm button is enabled\",\n        trigger: `\n            .sale-combo-configurator-dialog\n            button[name=\"sale_combo_configurator_confirm_button\"]:enabled\n        `,\n    };\n}\n\nfunction saveConfigurator() {\n    return [\n        {\n            content: \"Confirm the combo configurator\",\n            trigger: `\n                .sale-combo-configurator-dialog\n                button[name=\"sale_combo_configurator_confirm_button\"]\n            `,\n            run: 'click',\n        }, {\n            content: \"Wait until the modal is closed\",\n            trigger: 'body:not(:has(.sale-combo-configurator-dialog))',\n        },\n    ];\n}\n\nexport default {\n    comboSelector,\n    comboItemSelector,\n    assertComboCount,\n    assertComboItemCount,\n    assertSelectedComboItemCount,\n    assertPreselectedComboItemCount,\n    selectComboItem,\n    assertComboItemSelected,\n    assertComboItemPreselected,\n    increaseQuantity,\n    decreaseQuantity,\n    setQuantity,\n    assertQuantity,\n    assertPrice,\n    assertPriceInfo,\n    assertFooterButtonsDisabled,\n    assertFooterButtonsEnabled,\n    assertConfirmButtonDisabled,\n    assertConfirmButtonEnabled,\n    saveConfigurator,\n};\n", "function productSelector(productName) {\n    return `\n        table.o_sale_product_configurator_table\n        tr:has(td>div[name=\"o_sale_product_configurator_name\"]\n        span:contains(\"${productName}\"))\n    `;\n}\n\nfunction optionalProductSelector(productName) {\n    return `\n        table.o_sale_product_configurator_table_optional\n        tr:has(td>div[name=\"o_sale_product_configurator_name\"]\n        span:contains(\"${productName}\"))\n    `;\n}\n\nfunction optionalProductImageSrc(queryOne, productName) {\n    return queryOne(\n        `${optionalProductSelector(productName)} td.o_sale_product_configurator_img>img`\n    ).getAttribute(\"src\");\n}\n\nfunction addOptionalProduct(productName) {\n    return {\n        content: `Add ${productName}`,\n        trigger: `\n            ${optionalProductSelector(productName)}\n            td.o_sale_product_configurator_price\n            button:contains(\"Add\")\n        `,\n        run: 'click',\n    };\n}\n\nfunction removeOptionalProduct(productName) {\n    return {\n        content: `Remove ${productName}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            a:contains(\"Remove\")\n        `,\n        run: 'click',\n    };\n}\n\nfunction decreaseProductQuantity(productName) {\n    return {\n        content: `Decrease the quantity of ${productName}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            button:has(i.oi-minus)\n        `,\n        run: 'click',\n    };\n}\n\nfunction increaseProductQuantity(productName) {\n    return {\n        content: `Increase the quantity of ${productName}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            button:has(i.oi-plus)\n        `,\n        run: 'click',\n    };\n}\n\nfunction setProductQuantity(productName, quantity) {\n    return {\n        content: `Set the quantity of ${productName} to ${quantity}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            input[name=\"sale_quantity\"]\n        `,\n        run: `edit ${quantity} && click .modal-body`,\n    };\n}\n\nfunction setProductUoM(productName, uomName) {\n    // UoM must be enabled\n    return {\n        content: `Set the uom of ${productName} to ${uomName}`,\n        trigger: `\n            ${productSelector(productName)}\n            label:contains(\"${uomName}\")\n        `,\n        run: `click && click .modal-body`,\n    };\n}\n\nfunction assertProductQuantity(productName, quantity) {\n    return {\n        content: `Assert that the quantity of ${productName} is ${quantity}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            input[name=\"sale_quantity\"]:value(${quantity})\n        `,\n    };\n}\n\nfunction selectAttribute(productName, attributeName, attributeValue, attributeType='radio') {\n    const ptalSelector = `\n        ${productSelector(productName)}\n        td>div[name=\"ptal\"]:has(label:contains(\"${attributeName}\"))\n    `;\n    const content = `Select ${attributeValue} for ${productName} ${attributeName}`;\n    switch (attributeType) {\n        case 'color':\n            return {\n                content: content,\n                trigger: `${ptalSelector} label[title=\"${attributeValue}\"]`,\n                run: 'click',\n            };\n        case 'multi':\n            return {\n                content: content,\n                trigger: `${ptalSelector}:has(label:text(${attributeValue})) input[type=\"checkbox\"]`,\n                run: \"click\",\n            };\n        case 'pills':\n        case 'radio':\n            return {\n                content: content,\n                trigger: `${ptalSelector} span:contains(\"${attributeValue}\")`,\n                run: 'click',\n            };\n        case 'select':\n            return {\n                content: content,\n                trigger: `${ptalSelector} select`,\n                run: `selectByLabel ${attributeValue}`,\n            };\n        default:\n            console.error(\"Unsupported attribute type\");\n    }\n}\n\nfunction setCustomAttribute(productName, attributeName, customValue) {\n    return {\n        content: `Set ${customValue} as a custom attribute for ${productName} ${attributeName}`,\n        trigger: `\n            ${productSelector(productName)}\n            td>div[name=\"ptal\"]:has(label:contains(\"${attributeName}\"))\n            input[type=\"text\"]\n        `,\n        run: `edit ${customValue} && click .modal-body`,\n    };\n}\n\nfunction selectAndSetCustomAttribute(\n    productName, attributeName, attributeValue, customValue, attributeType='radio'\n) {\n    return [\n        selectAttribute(productName, attributeName, attributeValue, attributeType),\n        setCustomAttribute(productName, attributeName, customValue),\n    ];\n}\n\nfunction assertPriceTotal(total) {\n    return {\n        content: `Assert that the total is ${total}`,\n        trigger: `\n            .o_sale_product_configurator_dialog .o_configurator_price_total:contains(\"${total}\"),\n        `,\n    };\n}\n\nfunction assertProductPrice(productName, price) {\n    return {\n        content: `Assert that ${productName} costs ${price}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            span:contains(\"${price}\")\n        `,\n    };\n}\n\nfunction assertOptionalProductPrice(productName, price) {\n    return {\n        content: `Assert that ${productName} costs ${price}`,\n        trigger: `\n            ${optionalProductSelector(productName)}\n            td.o_sale_product_configurator_price\n            span:contains(\"${price}\")\n        `,\n    };\n}\n\nfunction assertProductPriceInfo(productName, priceInfo) {\n    return {\n        content: `Assert that the price info of ${productName} is ${priceInfo}`,\n        trigger: `\n            ${productSelector(productName)}\n            td.o_sale_product_configurator_qty\n            div:contains(\"${priceInfo}\")\n        `,\n    };\n}\n\nfunction assertOptionalProductPriceInfo(productName, priceInfo) {\n    return {\n        content: `Assert that the price info of ${productName} is ${priceInfo}`,\n        trigger: `\n            ${optionalProductSelector(productName)}\n            td.o_sale_product_configurator_price\n            div:contains(\"${priceInfo}\")\n        `,\n    };\n}\n\nfunction assertProductNameContains(productName) {\n    return {\n        content: `Assert that the product name contains ${productName}`,\n        trigger: productSelector(productName),\n    };\n}\n\nfunction assertFooterButtonsDisabled() {\n    return {\n        content: \"Assert that the footer buttons are disabled\",\n        trigger: '.o_sale_product_configurator_dialog footer.modal-footer button:disabled',\n    };\n}\n\nfunction saveConfigurator() {\n    return [\n        {\n            trigger: '.o_sale_product_configurator_dialog button:contains(Confirm)',\n            run: 'click',\n        }, {\n            content: \"Wait until the modal is closed\",\n            trigger: 'body:not(:has(.o_sale_product_configurator_dialog))',\n        }\n    ];\n}\n\nexport default {\n    productSelector,\n    optionalProductSelector,\n    optionalProductImageSrc,\n    addOptionalProduct,\n    removeOptionalProduct,\n    increaseProductQuantity,\n    decreaseProductQuantity,\n    setProductQuantity,\n    setProductUoM,\n    assertProductQuantity,\n    selectAttribute,\n    setCustomAttribute,\n    selectAndSetCustomAttribute,\n    assertPriceTotal,\n    assertProductPrice,\n    assertOptionalProductPrice,\n    assertProductPriceInfo,\n    assertOptionalProductPriceInfo,\n    assertProductNameContains,\n    assertFooterButtonsDisabled,\n    saveConfigurator,\n};\n", "function createNewSalesOrder() {\n    return [\n        {\n            trigger: '.o_sale_order',\n        }, {\n            content: \"Create new order\",\n            trigger: '.o_list_button_add',\n            run: 'click',\n        },\n    ]\n}\n\nfunction selectCustomer(customerName) {\n    return [\n        {\n            content: `Select customer ${customerName}`,\n            trigger: '.o_field_widget[name=partner_id] input',\n            run: `edit ${customerName}`,\n        },\n        {\n            trigger: `ul.ui-autocomplete > li > a:contains(\"${customerName}\")`,\n            run: 'click',\n        },\n    ];\n}\n\nfunction addProduct(productName, rowNumber=1) {\n    return [\n        {\n            content: `Add product ${productName}`,\n            trigger: 'a:contains(\"Add a product\")',\n            run: 'click',\n        },\n        {\n            content: 'wait for new row to be created',\n            trigger: `.o_data_row:nth-child(${rowNumber})`,\n        },\n        {\n            trigger: 'div[name=\"product_template_id\"] input',  // TODO VFE o_selected_row\n            run: `edit ${productName}`,\n        },\n        {\n            trigger: `ul.ui-autocomplete a:contains(\"${productName}\")`,\n            run: 'click',\n        },\n    ];\n}\n\nfunction clickSomewhereElse() {\n    return [\n        // TODO find a way for onchange to finish first ?\n        {\n            content: 'click somewhere else to exit cell focus',\n            trigger: 'a[name=order_lines]',  // click on notebook tab to stop the sol edit mode.\n            run: 'click',\n        },\n        {\n            content: 'check that the soline is not focused anymore',\n            trigger: 'table.o_section_and_note_list_view:not(:has(.o_selected_row))',\n        }\n    ]\n}\n\nfunction checkSOLDescriptionContains(productName, text) {\n    // TODO in the future: look directly into the textarea value\n    let trigger = '.o_field_product_label_section_and_note_cell';\n    if (productName) {\n        trigger = `${trigger}:has(:contains(\"${productName}\"), input:value(\"${productName}\"))`;\n    }\n    if (text) {\n        trigger = `${trigger} .o_input`;\n    }\n    return { trigger };\n}\n\nfunction editLineMatching(productName, text) {\n    let base_step = checkSOLDescriptionContains(productName, text);\n    base_step['run'] = 'click';\n    return base_step;\n}\n\nfunction editConfiguration() {\n    return {\n        trigger: '[name=product_template_id] button.fa-pencil',\n        run: 'click',\n    }\n}\n\nexport default {\n    createNewSalesOrder,\n    selectCustomer,\n    addProduct,\n    checkSOLDescriptionContains,\n    editLineMatching,\n    editConfiguration,\n    clickSomewhereElse,\n};\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nconst todayDate = function () {\n    const now = new Date();\n    const year = now.getFullYear();\n    const month = String(now.getMonth() + 1).padStart(2, \"0\");\n    const day = String(now.getDate()).padStart(2, \"0\");\n\n    return `${month}/${day}/${year} 10:00:00`;\n};\n\nregistry.category(\"web_tour.tours\").add(\"calendar_appointments_hour_tour\", {\n    url: \"/odoo\",\n    steps: () => [\n        stepUtils.showAppsMenuItem(),\n        {\n            trigger: '.o_app[data-menu-xmlid=\"calendar.mail_menu_calendar\"]',\n            content: \"Open Calendar\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o-calendar-button-new\",\n            content: \"Create a new event\",\n            run: \"click\",\n        },\n        {\n            trigger: \"#name_0\",\n            content: \"Give a name to the new event\",\n            run: \"edit TEST EVENT\",\n        },\n        {\n            trigger: \"div[name='start'] button\",\n            content: \"Open the date picker\",\n            run: \"click\",\n        },\n        {\n            trigger: \"#start_0\",\n            content: \"Give a date to the new event\",\n            run: `edit ${todayDate()}`,\n        },\n        {\n            trigger: \"#duration_0\",\n            content: \"Give a duration to the new event\",\n            run: \"edit 02:00\",\n        },\n        {\n            trigger: \".fa-cloud-upload\",\n            content: \"Save the new event\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_back_button\",\n            content: \"Go back to Calendar view\",\n            run: \"click\",\n        },\n        {\n            trigger: \".scale_button_selection\",\n            content: \"Click to change calendar view\",\n            run: \"click\",\n        },\n        {\n            trigger: '.dropdown-item:contains(\"Month\")',\n            content: \"Change the calendar view to Month\",\n            run: \"click\",\n        },\n        {\n            trigger: \".fc-col-header-cell.fc-day.fc-day-mon\",\n            content: \"Check the day is properly displayed\",\n            run: \"click\",\n        },\n        {\n            trigger: '.fc-time:contains(\"10:00\")',\n            content: \"Check the time is properly displayed\",\n            run: \"click\",\n        },\n        {\n            trigger: '.o_event_title:contains(\"TEST EVENT\")',\n            content: \"Check the event title\",\n        },\n    ],\n});\n\nconst clickOnTheEvent = {\n    content: \"Click on the event (focus + waiting)\",\n    trigger: 'a .fc-event-main:contains(\"Test Event\")',\n    async run(actions) {\n        await actions.click();\n        await new Promise((r) => setTimeout(r, 1000));\n        const custom = document.querySelector(\".o_cw_custom_highlight\");\n        if (custom) {\n            custom.click();\n        }\n    },\n};\n\nregistry.category(\"web_tour.tours\").add(\"test_calendar_delete_tour\", {\n    steps: () => [\n        clickOnTheEvent,\n        {\n            trigger: \".o_cw_popover\",\n        },\n        {\n            content: \"Delete the event\",\n            trigger: \".o_cw_popover_delete\",\n            run: \"click\",\n        },\n        {\n            content: \"Validate the deletion\",\n            trigger: 'button:contains(\"Delete\")',\n            run: \"click\",\n        },\n    ],\n});\n\nregistry.category(\"web_tour.tours\").add(\"test_calendar_decline_tour\", {\n    steps: () => [\n        clickOnTheEvent,\n        {\n            trigger: \".o_cw_popover\",\n        },\n        {\n            content: \"Delete the event\",\n            trigger: \".o_cw_popover_delete\",\n            run: \"click\",\n        },\n        {\n            content: \"Wait declined status\",\n            trigger: \".o_attendee_status_declined\",\n        },\n    ],\n});\n", "    import { registry } from \"@web/core/registry\";\n    import { stepUtils } from \"@web_tour/tour_utils\";\n\n    registry.category(\"web_tour.tours\").add('debug_menu_set_defaults', {\n        url: '/odoo?debug=1',\n        steps: () => [\n            ...stepUtils.goToAppSteps('contacts.menu_contacts', \"Open the contacts menu\"),\n            {\n                content: \"Create a new contact\",\n                trigger: '.o_list_button_add',\n                run: \"click\",\n            },\n            {\n                content: \"Check that Company is checked by default, and not Individual\",\n                trigger: '.o_field_widget[name=\"company_type\"] input[data-value=\"company\"]:checked',\n            },\n            {\n                content: \"Select the individual radio button\",\n                trigger: '.o_field_widget[name=\"company_type\"] input[data-value=\"person\"]',\n                run: \"click\",\n            },\n            {\n                content: \"Open the debug menu\",\n                trigger: '.o_debug_manager button',\n                run: \"click\",\n            },\n            {\n                content: \"Click the Set Defaults menu\",\n                trigger: '.dropdown-item:contains(Set Default Values)',\n                run: \"click\",\n            },\n            {\n                content: \"Choose Company Type = Individual\",\n                trigger: '#formview_default_fields',\n                run: function () {\n                    const element_field = document.querySelector('select#formview_default_fields');\n                    element_field.value = 'company_type';\n                    element_field.dispatchEvent(new Event(\"change\"));\n                },\n            },\n            {\n                content: \"Check that there are conditions\",\n                trigger: '#formview_default_conditions',\n                run: \"click\",\n            },\n            {\n                content: \"Save the new default\",\n                trigger: 'footer button:contains(Save default)',\n                run: \"click\",\n            },\n            {\n                content: \"Discard the contact creation\",\n                trigger: 'button.o_form_button_cancel',\n                run: \"click\",\n            },\n            {\n                trigger: '.o_action_manager > .o_list_view .o_list_button_add',\n                run: \"click\",\n            },\n            {\n                content: \"Check that Individual is checked instead of Company\",\n                trigger: '.o_field_widget[name=\"company_type\"] input[data-value=\"person\"]:checked',\n            },\n            {\n                content: \"Discard the contact creation\",\n                trigger: 'button.o_form_button_cancel',\n                run: \"click\",\n            },\n            {\n                content: \"Wait for discard\",\n                trigger: '.o_control_panel .o_list_button_add',\n            },\n        ]\n    });\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add('create_crm_team_tour', {\n    url: \"/odoo\",\n    steps: () => [\n    ...stepUtils.goToAppSteps('crm.crm_menu_root'),\n{\n    trigger: 'button[data-menu-xmlid=\"crm.crm_menu_config\"]',\n    run: \"click\",\n}, {\n    trigger: 'a[data-menu-xmlid=\"crm.crm_team_config\"]',\n    run: \"click\",\n}, {\n    trigger: 'button.o_list_button_add',\n    run: \"click\",\n}, {\n    trigger: 'input[id=\"name_0\"]',\n    run: \"edit My CRM Team\",\n}, {\n    trigger: '.btn.o-kanban-button-new',\n    run: \"click\",\n}, {\n    trigger: 'div.modal-dialog tr:contains(\"Test Salesman\") input.form-check-input',\n    run: 'click',\n}, {\n    trigger: 'div.modal-dialog tr:contains(\"Test Sales Manager\") input.form-check-input',\n    run: 'click',\n}, {\n    trigger: 'div.modal-dialog tr:contains(\"Test Sales Manager\") input.form-check-input:checked',\n}, {\n    trigger: '.o_selection_box:contains(2)',\n}, {\n    trigger: 'button.o_select_button',\n    run: \"click\",\n},\n    ...stepUtils.saveForm()\n]});\n", "    import { registry } from \"@web/core/registry\";\n    import { stepUtils } from \"@web_tour/tour_utils\";\n\n    registry.category(\"web_tour.tours\").add('crm_email_and_phone_propagation_edit_save', {\n        url: '/odoo',\n        steps: () => [\n        stepUtils.showAppsMenuItem(),\n        {\n            trigger: '.o_app[data-menu-xmlid=\"crm.crm_menu_root\"]',\n            content: 'open crm app',\n            run: \"click\",\n        }, {\n            trigger: '.o_kanban_record:contains(Test Lead Propagation)',\n            content: 'Open the first lead',\n            run: 'click',\n        },\n        {\n            trigger: \".o_form_editable .o_field_widget[name=email_from] input\",\n        },\n        {\n            trigger: \".o_form_button_save:not(:visible)\",\n            content: 'Save the lead',\n            run: 'click',\n        },\n    ]});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\nconst today = luxon.DateTime.now();\n\nregistry.category(\"web_tour.tours\").add('crm_forecast', {\n    url: \"/odoo\",\n    steps: () => [\n    stepUtils.showAppsMenuItem(),\n    {\n        trigger: \".o_app[data-menu-xmlid='crm.crm_menu_root']\",\n        content: \"open crm app\",\n        run: \"click\",\n    }, {\n        trigger: '.dropdown-toggle[data-menu-xmlid=\"crm.crm_menu_report\"]',\n        content: 'Open Reporting menu',\n        run: 'click',\n    }, {\n        trigger: '.dropdown-item[data-menu-xmlid=\"crm.crm_menu_forecast\"]',\n        content: 'Open Forecast menu',\n        run: 'click',\n    }, {\n        trigger: '.o_column_quick_create',\n        content: 'Wait page loading',\n    }, {\n        trigger: \".o-kanban-button-new\",\n        content: \"click create\",\n        run: 'click',\n    }, {\n        trigger: \".o_field_widget[name=name] input\",\n        content: \"complete name\",\n        run: \"edit Test Opportunity 1\",\n    }, {\n        trigger: \".o_field_widget[name=expected_revenue] input\",\n        content: \"complete expected revenue\",\n        run: \"edit 999999\",\n    }, {\n        trigger: \"button.o_kanban_edit\",\n        content: \"edit lead\",\n        run: \"click\",\n    }, {\n        trigger: \"div[name=date_deadline] button\",\n        content: \"open date picker\",\n        run: \"click\",\n    }, {\n        trigger: \"div[name=date_deadline] input\",\n        content: \"complete expected closing\",\n        run: `edit ${today.toFormat(\"MM/dd/yyyy\")}`,\n    }, {\n        trigger: \"div[name=date_deadline] input\",\n        content: \"click to make the datepicker disappear\",\n        run: \"click\"\n    }, {\n        trigger: '.o_back_button',\n        content: 'navigate back to the kanban view',\n        tooltipPosition: \"bottom\",\n        run: \"click\"\n    }, {\n        trigger: \".o_kanban_record:contains('Test Opportunity 1')\",\n        content: \"move to the next month\",\n        async run({ queryAll, drag_and_drop }) {\n            const undefined_groups = queryAll('.o_column_title:contains(\"None\")').length;\n            await drag_and_drop(`.o_opportunity_kanban .o_kanban_group:eq(${1 + undefined_groups})`);\n        },\n    }, {\n        trigger: \".o_kanban_record:contains('Test Opportunity 1')\",\n        content: \"edit lead\",\n        run: \"click\"\n    }, {\n        trigger: \"div[name=date_deadline] button\",\n        content: \"open date picker\",\n        run: \"click\",\n    }, {\n        trigger: \".o_field_widget[name=date_deadline] input\",\n        content: \"complete expected closing\",\n        run: `edit ${today.plus({ months: 5 }).startOf(\"month\").minus({ days: 1 }).toFormat(\"MM/dd/yyyy\")} && press Escape`,\n    }, {\n        trigger: \"button[name=action_set_won_rainbowman]\",\n        content: \"win the lead\",\n        run:\"click\"\n    }, {\n        trigger: '.o_back_button',\n        content: 'navigate back to the kanban view',\n        tooltipPosition: \"bottom\",\n        run: \"click\"\n    }, {\n        trigger: '.o_column_quick_create.o_quick_create_folded div',\n        content: \"add next month\",\n        run: \"click\"\n    }, {\n        trigger: \".o_kanban_record:contains('Test Opportunity 1'):contains('Won')\",\n        content: \"assert that the opportunity has the Won banner\",\n    }\n]});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add(\"crm_rainbowman\", {\n    url: \"/odoo\",\n    steps: () => [\n        stepUtils.showAppsMenuItem(),\n        {\n            trigger: \".o_app[data-menu-xmlid='crm.crm_menu_root']\",\n            content: \"open crm app\",\n            run: \"click\",\n        },\n        {\n            trigger: \"body:has(.o_kanban_renderer) .o-kanban-button-new\",\n            content: \"click create\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_field_widget[name=name] input\",\n            content: \"complete name\",\n            run: \"edit Test Lead 1\",\n        },\n        {\n            trigger: \".o_field_widget[name=expected_revenue] input\",\n            content: \"complete expected revenue\",\n            run: \"edit 999999997\",\n        },\n        {\n            trigger: \"button.o_kanban_add\",\n            content: \"create lead\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_record:contains('Test Lead 1')\",\n            content: \"move to won stage\",\n            run: \"drag_and_drop (.o_opportunity_kanban .o_kanban_group:has(.o_column_title:contains('Won')))\",\n        },\n        {\n            trigger: \".o_reward_rainbow\",\n        },\n        {\n            // This step and the following simulates the fact that after drag and drop,\n            // from the previous steps, a click event is triggered on the window element,\n            // which closes the currently shown .o_kanban_quick_create.\n            trigger: \".o_kanban_renderer\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_renderer:not(:has(.o_kanban_quick_create))\",\n        },\n        {\n            trigger: \".o-kanban-button-new\",\n            content: \"create second lead\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_field_widget[name=name] input\",\n            content: \"complete name\",\n            run: \"edit Test Lead 2\",\n        },\n        {\n            trigger: \".o_field_widget[name=expected_revenue] input\",\n            content: \"complete expected revenue\",\n            run: \"edit 999999998\",\n        },\n        {\n            trigger: \"button.o_kanban_add\",\n            content: \"create lead\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_kanban_record:contains('Test Lead 2')\",\n        },\n        {\n            // move first test back to new stage to be able to test rainbowman a second time\n            trigger: \".o_kanban_record:contains('Test Lead 1')\",\n            content: \"move back to new stage\",\n            run: \"drag_and_drop .o_opportunity_kanban .o_kanban_group:eq(0) \",\n        },\n        {\n            trigger: \".o_kanban_record:contains('Test Lead 2')\",\n            content: \"click on second lead\",\n            run: \"click\",\n        },\n        {\n            trigger: \".o_statusbar_status button[data-value='4']\",\n            content: \"move lead to won stage\",\n            run: \"click\",\n        },\n        {\n            content: \"wait for save completion\",\n            trigger: \".o_form_readonly, .o_form_saved\",\n        },\n        {\n            trigger: \".o_reward_rainbow\",\n        },\n        {\n            trigger: \".o_statusbar_status button[data-value='1']\",\n            content: \"move lead to previous stage & rainbowman appears\",\n            run: \"click\",\n        },\n        {\n            trigger: \"button[name=action_set_won_rainbowman]\",\n            content: \"click button mark won\",\n            run: \"click\",\n        },\n        {\n            content: \"wait for save completion\",\n            trigger: \".o_form_readonly, .o_form_saved\",\n        },\n        {\n            trigger: \".o_reward_rainbow\",\n        },\n        {\n            trigger: \".o_menu_brand\",\n            content: \"last rainbowman appears\",\n        },\n    ],\n});\n", "import { registry } from \"@web/core/registry\";\n\nregistry.category(\"web_tour.tours\").add('passkeys_tour_delete', {\n    url: '/odoo',\n    steps: () => [\n        {\n            content: 'Open user account menu',\n            trigger: '.o_user_menu .dropdown-toggle',\n            run: 'click',\n        }, {\n            content: \"Open preferences / profile screen\",\n            trigger: '[data-menu=preferences]',\n            run: 'click',\n        }, {\n            content: \"Switch to security tab\",\n            trigger: 'a[role=tab]:contains(\"Security\")',\n            run: 'click',\n        }, {\n            content: \"Ensure there is only one passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                let amount = document.querySelectorAll(\"div[name='auth_passkey_key_ids'] article\").length;\n                if(amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        }, {\n            content: \"Open Passkey dropdown\",\n            trigger: '[name=\"auth_passkey_key_ids\"] .o_dropdown_kanban .o-dropdown:not(:visible)',\n            run: 'click',\n        }, {\n            content: \"Delete Passkey\",\n            trigger: 'a[name=\"action_delete_passkey\"]',\n            run: 'click',\n        }, {\n            content: \"Identitycheck: use password\",\n            trigger: 'button[name=\"action_use_password\"]',\n            run: 'click',\n        }, {\n            content: \"Check that we have to enter enhanced security mode\",\n            trigger: \".modal div:contains(Enter your current password)\",\n        }, {\n            content: \"Input password\",\n            trigger: '.modal [name=password] input',\n            run: \"edit admin\",\n        }, {\n            content: \"Confirm\",\n            trigger: \".modal button:contains(Confirm Password)\",\n            run: \"click\",\n        }, {\n            content: 'Open user account menu',\n            trigger: '.o_user_menu .dropdown-toggle',\n            run: 'click',\n        }, {\n            content: \"Open preferences / profile screen\",\n            trigger: '[data-menu=preferences]',\n            run: 'click',\n        }, {\n            // The HR module causes the switch to security tab to trigger on the old DOM, before the new one is loaded\n            content: \"Make sure the Preferences tab is open\",\n            trigger: 'label:contains(\"Email Signature\")',\n        }, {\n            content: \"Switch to security tab\",\n            trigger: 'a[role=tab]:contains(\"Security\")',\n            run: 'click',\n        }, {\n            content: \"Ensure there are no more passkeys\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                let amount = document.querySelectorAll(\"div[name='auth_passkey_key_ids'] article\").length;\n                if(amount != 0) {\n                    throw Error(\"Amount of Passkeys must be 0\");\n                }\n            },\n        }\n    ]\n})\n", "import { registry } from \"@web/core/registry\";\nimport { patch } from \"@web/core/utils/patch\";\nimport * as passkeyLib from \"../lib/simplewebauthn\";\n\nregistry.category(\"web_tour.tours\").add('passkeys_tour_login', {\n    url: '/web/login',\n    steps: () => [\n        {\n            content: \"Inject authenticator data\",\n            trigger: 'body',\n            run: () => {\n                // Due to switching from /web/login to /odoo, the asset bundles will be different. As a result this will automatically clean up the test.\n                patch(passkeyLib, {\n                    async startAuthentication() {\n                        return {\n                            // test-keepassxc\n                            \"id\": \"y6aJVJsvvSSkbwTeGZ1FbQP_jCDho7EBPwZq-3lAjQ0\",\n                            \"rawId\": \"y6aJVJsvvSSkbwTeGZ1FbQP_jCDho7EBPwZq-3lAjQ0\",\n                            \"response\": {\n                                \"authenticatorData\": \"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA\",\n                                \"clientDataJSON\": \"eyJjaGFsbGVuZ2UiOiJMTnBWMGRQSU10bXBTd0dlbklIX2gxVnljUXVBZ0ZnUVJKOVRQS0JvTmF5U2NOQUVyUy1yc25hVTE5bjdfQWFYemVpWVJnM25HSTN5dUgwYWk2VVBYQSIsImNyb3NzT3JpZ2luIjpmYWxzZSwib3JpZ2luIjoiaHR0cHM6Ly9sb2NhbGhvc3Q6ODg4OCIsInR5cGUiOiJ3ZWJhdXRobi5nZXQifQ\",\n                                \"signature\": \"MEYCIQCqkh2NBQQao5uDTaBKyNhiEpnk4jgbH-PjdLAul9-d0gIhAMObtNTbaEMUILdNgCT01BKNN4NHRzkzsGaDN2Ozu0WX\",\n                                \"userHandle\": \"Ng\",\n                            },\n                            \"type\": \"public-key\",\n                            \"clientExtensionResults\": {},\n                            \"authenticatorAttachment\": \"platform\",\n                        };\n                    },\n                });\n            },\n        }, {\n            content: 'Login with Passkey',\n            trigger: 'a:contains(\"Use a Passkey\")',\n            run: 'click',\n            expectUnloadPage: true,\n        }, {\n            content: 'Check if we are logged in',\n            trigger: '.o_user_menu .dropdown-toggle',\n        },\n    ]\n})\n", "import { registry } from \"@web/core/registry\";\nimport { patch } from \"@web/core/utils/patch\";\nimport * as passkeyLib from \"../lib/simplewebauthn\";\n\nlet unpatchPasskeyRegistration;\n\nregistry.category(\"web_tour.tours\").add('passkeys_tour_registration', {\n    url: '/odoo',\n    steps: () => [\n        {\n            content: 'Open user account menu',\n            trigger: '.o_user_menu .dropdown-toggle',\n            run: 'click',\n        }, {\n            content: \"Open preferences / profile screen\",\n            trigger: '[data-menu=preferences]',\n            run: 'click',\n        }, {\n            content: \"Switch to security tab\",\n            trigger: 'a[role=tab]:contains(\"Security\")',\n            run: 'click',\n        }, {\n            content: \"Ensure there are no passkeys already\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                let amount = document.querySelectorAll(\"div[name='auth_passkey_key_ids'] article\").length;\n                if(amount != 0) {\n                    throw Error(\"Amount of Passkeys must be 0\");\n                }\n            },\n        }, {\n            content: \"Add a Passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: 'click',\n        }, {\n            content: \"Check that we have to enter enhanced security mode\",\n            trigger: \".modal div:contains(Enter your current password)\",\n        }, {\n            content: \"Input password\",\n            trigger: '.modal [name=password] input',\n            run: \"edit admin\",\n        }, {\n            content: \"Confirm\",\n            trigger: \".modal button:contains(Confirm Password)\",\n            run: \"click\",\n        }, {\n            content: \"Ready to create Passkey\",\n            trigger: \".modal div:contains(Create Passkey)\",\n        }, {\n            content: \"Input passkey name\",\n            trigger: '.modal .o_field_char input',\n            run: \"edit test_passkey_one\",\n        }, {\n            content: \"Override startRegistration\",\n            trigger: 'body',\n            run: () => {\n                unpatchPasskeyRegistration = patch(passkeyLib, {\n                    async startRegistration() {\n                        return {\n                            // test-yubikey\n                            \"id\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"rawId\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"response\": {\n                                \"attestationObject\": \"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjCSZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI\",\n                                \"clientDataJSON\": \"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiVW9hNk01akVQN0kzVG95SzlRQTB2ZjhJY3NlemZlSmswcmdzMXBMVVdyTWdGOXZkMC03RHY1aVYzeFc3cjcwLVlxa3dlUlhoQUNtRFBtaEhLdEFJZVEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\n                                \"transports\": [\n                                    \"nfc\",\n                                    \"usb\",\n                                ],\n                                \"publicKeyAlgorithm\": -7,\n                                \"publicKey\": \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEL2p6jvcWuCMTRmkZHDEsgbnQviQ2WGPYMjKpJz9iJFLarpsvb4ignqP8aRVN188rLHxEXl7zDNf35mTfsDKQzw\",\n                                \"authenticatorData\": \"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI\",\n                            },\n                            \"type\": \"public-key\",\n                            \"clientExtensionResults\": {},\n                            \"authenticatorAttachment\": \"cross-platform\",\n                        };\n                    },\n                });\n            },\n        }, {\n            content: \"Click the Create button\",\n            trigger: \".modal button:contains(Create)\",\n            run: \"click\",\n        }, {\n            content: 'Open user account menu',\n            trigger: '.o_user_menu .dropdown-toggle',\n            run: 'click',\n        }, {\n            content: \"Return startRegistration to original state\",\n            trigger: 'body',\n            run: () => {\n                unpatchPasskeyRegistration();\n            },\n        }, {\n            content: \"Open preferences / profile screen\",\n            trigger: '[data-menu=preferences]',\n            run: 'click',\n        }, {\n            // The HR module causes the switch to security tab to trigger on the old DOM, before the new one is loaded\n            content: \"Make sure the Preferences tab is open\",\n            trigger: 'label:contains(\"Email Signature\")',\n        }, {\n            content: \"Switch to security tab\",\n            trigger: 'a[role=tab]:contains(\"Security\")',\n            run: 'click',\n        }, {\n            content: \"Ensure there is one passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                let amount = document.querySelectorAll(\"div[name='auth_passkey_key_ids'] article\").length;\n                if(amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        },\n    ]\n})\n", "import { registry } from \"@web/core/registry\";\nimport { patch } from \"@web/core/utils/patch\";\nimport * as passkeyLib from \"../lib/simplewebauthn\";\n\nlet unpatchPasskeyVerify;\n\nregistry.category(\"web_tour.tours\").add('passkeys_tour_verify', {\n    url: '/odoo',\n    steps: () => [\n        {\n            content: 'Open user account menu',\n            trigger: '.o_user_menu .dropdown-toggle',\n            run: 'click',\n        }, {\n            content: \"Open preferences / profile screen\",\n            trigger: '[data-menu=preferences]',\n            run: 'click',\n        }, {\n            content: \"Switch to security tab\",\n            trigger: 'a[role=tab]:contains(\"Security\")',\n            run: 'click',\n        }, {\n            content: \"Ensure there is one passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                let amount = document.querySelectorAll(\"div[name='auth_passkey_key_ids'] article\").length;\n                if(amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        }, {\n            content: \"Trigger security prompt\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: 'click',\n        }, {\n            content: \"Override startAuthentication\",\n            trigger: 'body',\n            run: () => {\n                unpatchPasskeyVerify = patch(passkeyLib, {\n                    async startAuthentication() {\n                        return {\n                            // test-yubikey\n                            \"id\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"rawId\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"response\": {\n                                \"authenticatorData\": \"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAw\",\n                                \"clientDataJSON\": \"eyJ0eXBlIjoid2ViYXV0aG4uZ2V0IiwiY2hhbGxlbmdlIjoiREtydzVJZUZpTDB3X3k1b0IwUkFUUHJxRzFlRk9DMlA3eUVpWENzdEJSdVpZYlNCQmtBV2ZoQUlJbmtNcVdqWUlOOHZiS243SjNQTVhfVGh6bkhwcWciLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\n                                \"signature\": \"MEUCIQD5iaPp48QMS3amx4PS89kv_EBAo3bBkaWnLzWlSgFSXgIgLWKEv9xR_ZwVXZbw2zx459RKbrQuAcd-UqD4gJw1lWY\",\n                                \"userHandle\": \"Mg\",\n                            },\n                            \"type\": \"public-key\",\n                            \"clientExtensionResults\": {},\n                            \"authenticatorAttachment\": \"cross-platform\",\n                        };\n                    },\n                });\n            },\n        }, {\n            content: \"Click Use Passkey\",\n            trigger: 'button:contains(\"Use Passkey\")',\n            run: 'click',\n        }, {\n            content: \"Ready to create Passkey\",\n            trigger: \".modal div:contains(Create Passkey)\",\n        }, {\n            content: \"Return startAuthentication to original state\",\n            trigger: 'body',\n            run: () => {\n                unpatchPasskeyVerify();\n            },\n        }\n    ]\n})\n", "import { registry } from \"@web/core/registry\";\nimport { patch } from \"@web/core/utils/patch\";\nimport * as passkeyLib from \"@auth_passkey/../lib/simplewebauthn\";\n\nlet unpatchPasskeyRegistrationPortal;\n\nregistry.category(\"web_tour.tours\").add(\"passkeys_portal_create\", {\n    url: \"/my/security\",\n    steps: () => [\n        {\n            content: \"Ensure there are no passkeys already\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                const amount = document.querySelectorAll(\".o_passkey_portal_entry\").length;\n                if (amount != 0) {\n                    throw Error(\"Amount of Passkeys must be 0\");\n                }\n            },\n        }, {\n            content: \"Add a Passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: \"click\",\n        }, {\n            content: \"Check that we have to enter enhanced security mode\",\n            trigger: \"form strong:contains(Please enter your password to confirm you own this account)\",\n        }, {\n            content: \"Input password\",\n            trigger: \"form input[name=password]\",\n            run: \"edit passkey_portal\",\n        }, {\n            content: \"Confirm\",\n            trigger: \".modal-footer button:contains(Confirm Password)\",\n            run: \"click\",\n        }, {\n            content: \"Ready to create Passkey\",\n            trigger: \".modal-title:contains(Create Passkey)\",\n        }, {\n            content: \"Input passkey name\",\n            trigger: 'input[name=\"keyname\"]',\n            run: \"edit test_passkey_one\",\n        }, {\n            content: \"Override startRegistration\",\n            trigger: \"body\",\n            run: () => {\n                unpatchPasskeyRegistrationPortal = patch(passkeyLib, {\n                    async startRegistration() {\n                        return {\n                            // test-yubikey\n                            \"id\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"rawId\": \"L2p6jvcWuCMTRmkZHKqqvQbz0Dhk3JbJOx1F8ci99nSNjlfx3Z7nkigMdUACLggB\",\n                            \"response\": {\n                                \"attestationObject\": \"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVjCSZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI\",\n                                \"clientDataJSON\": \"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiVW9hNk01akVQN0kzVG95SzlRQTB2ZjhJY3NlemZlSmswcmdzMXBMVVdyTWdGOXZkMC03RHY1aVYzeFc3cjcwLVlxa3dlUlhoQUNtRFBtaEhLdEFJZVEiLCJvcmlnaW4iOiJodHRwOi8vbG9jYWxob3N0OjgwNjkiLCJjcm9zc09yaWdpbiI6ZmFsc2V9\",\n                                \"transports\": [\n                                    \"nfc\",\n                                    \"usb\",\n                                ],\n                                \"publicKeyAlgorithm\": -7,\n                                \"publicKey\": \"MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEL2p6jvcWuCMTRmkZHDEsgbnQviQ2WGPYMjKpJz9iJFLarpsvb4ignqP8aRVN188rLHxEXl7zDNf35mTfsDKQzw\",\n                                \"authenticatorData\": \"SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2PFAAAAAgAAAAAAAAAAAAAAAAAAAAAAMC9qeo73FrgjE0ZpGRyqqr0G89A4ZNyWyTsdRfHIvfZ0jY5X8d2e55IoDHVAAi4IAaUBAgMmIAEhWCAvanqO9xa4IxNGaRkcMSyBudC-JDZYY9gyMqknP2IkUiJYINqumy9viKCeo_xpFU3XzyssfEReXvMM1_fmZN-wMpDPoWtjcmVkUHJvdGVjdAI\",\n                            },\n                            \"type\": \"public-key\",\n                            \"clientExtensionResults\": {},\n                            \"authenticatorAttachment\": \"cross-platform\",\n                        };\n                    },\n                });\n            },\n        }, {\n            content: \"Click the Create button\",\n            trigger: \".modal-content button:contains(Create)\",\n            run: \"click\",\n            expectUnloadPage: true,\n        }, {\n            content: \"Return startRegistration to original state\",\n            trigger: \"body\",\n            run: () => {\n                if (unpatchPasskeyRegistrationPortal) {\n                    unpatchPasskeyRegistrationPortal();\n                }\n            },\n        }, {\n            content: \"Ensure there is one passkey\",\n            trigger: \".o_passkey_name\",\n            run: () => {\n                const amount = document.querySelectorAll(\".o_passkey_portal_entry\").length;\n                if (amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        },\n    ],\n});\n\nregistry.category(\"web_tour.tours\").add(\"passkeys_portal_rename\", {\n    url: \"/my/security\",\n    steps: () => [\n        {\n            content: \"Ensure there is one passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                const amount = document.querySelectorAll(\".o_passkey_portal_entry\").length;\n                if (amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        }, {\n            content: \"Click rename\",\n            trigger: '.o_passkey_portal_rename',\n            run: \"click\",\n        }, {\n            content: \"Input passkey name\",\n            trigger: 'input[name=\"keyname\"]',\n            run: \"edit edited_key\",\n        }, {\n            content: \"Confirm the rename\",\n            trigger: \".modal-content button:contains(Rename)\",\n            run: \"click\",\n            expectUnloadPage: true,\n        }, {\n            content: \"Ensure the rename occurred\",\n            trigger: \".o_passkey_name:contains(edited_key)\",\n        },\n    ],\n});\n\nregistry.category(\"web_tour.tours\").add(\"passkeys_portal_delete\", {\n    url: \"/my/security\",\n    steps: () => [\n        {\n            content: \"Ensure there is one passkey\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                const amount = document.querySelectorAll(\".o_passkey_portal_entry\").length;\n                if (amount != 1) {\n                    throw Error(\"Amount of Passkeys must be 1\");\n                }\n            },\n        }, {\n            content: \"Click delete\",\n            trigger: '.o_passkey_portal_delete',\n            run: \"click\",\n        }, {\n            content: \"Check that we have to enter enhanced security mode\",\n            trigger: \"form strong:contains(Please enter your password to confirm you own this account)\",\n        }, {\n            content: \"Input password\",\n            trigger: \"form input[name=password]\",\n            run: \"edit passkey_portal\",\n        }, {\n            content: \"Confirm\",\n            trigger: \".modal-footer button:contains(Confirm Password)\",\n            run: \"click\",\n            expectUnloadPage: true,\n        }, {\n            content: \"Ensure there are no more passkeys\",\n            trigger: 'button:contains(\"Add Passkey\")',\n            run: () => {\n                const amount = document.querySelectorAll(\".o_passkey_portal_entry\").length;\n                if (amount != 0) {\n                    throw Error(\"Amount of Passkeys must be 0\");\n                }\n            },\n        },\n    ],\n});\n", "import { rpc } from \"@web/core/network/rpc\";\nimport { registry } from \"@web/core/registry\";\n\nconst openUserPreferenceSecurity = () => [{\n    content: 'Open user account menu',\n    trigger: '.o_user_menu .dropdown-toggle',\n    run: 'click',\n}, {\n    content: \"Open preferences / profile screen\",\n    trigger: '[data-menu=preferences]',\n    run: 'click',\n}, {\n    content: \"Switch to security tab\",\n    trigger: 'a[role=tab]:contains(\"Security\")',\n    run: 'click',\n}]\n\nregistry.category(\"web_tour.tours\").add('apikeys_tour_setup', {\n    url: '/odoo?debug=1', // Needed as API key part is now only displayed in debug mode\n    steps: () => [\n    ...openUserPreferenceSecurity(), {\n    content: \"Open API keys wizard\",\n    trigger: 'button:contains(\"Add API Key\")',\n    run: \"click\",\n}, {\n    content: \"Check that we have to enter enhanced security mode\",\n    trigger: \".modal div:contains(Enter your current password)\",\n}, {\n    content: \"Input password\",\n    trigger: '.modal [name=password] input',\n    run: \"edit test_user\",\n}, {\n    content: \"Confirm\",\n    trigger: \".modal button:contains(Confirm Password)\",\n    run: \"click\",\n}, {\n    content: \"Check that we're now on the key description dialog\",\n    trigger: '.modal p:contains(\"Enter a description of and purpose for the key.\")',\n}, {\n    content: \"Enter description\",\n    trigger: '.modal [name=name] input',\n    run: \"edit my key\",\n}, {\n    content: \"Confirm key creation\",\n    trigger: '.modal button:contains(\"Generate key\")',\n    run: \"click\",\n}, {\n    content: \"Check that we're on the last step & grab key\",\n    trigger: '.modal p:contains(\"Here is your new API key\")',\n    run: async () => {\n        const key = document.querySelector(\"code [name=key] span\").textContent;\n        await rpc('/web/dataset/call_kw', {\n            model: 'ir.logging', method: 'send_key',\n            args: [key],\n            kwargs: {},\n        });\n    }\n},\n{\n    trigger: \"button:contains(Done)\",\n    run: \"click\",\n},\n...openUserPreferenceSecurity(),\n{\n    content: \"check that our key is present\",\n    trigger: '[name=api_key_ids] .o_kanban_record:contains(\"my key\")',\n}]});\n\n// deletes the previously created key\nregistry.category(\"web_tour.tours\").add('apikeys_tour_teardown', {\n    url: '/odoo?debug=1', // Needed as API key part is now only displayed in debug mode\n    steps: () => [{\n    content: 'Open preferences',\n    trigger: '.o_user_menu .dropdown-toggle',\n    run: \"click\",\n}, {\n    trigger: '[data-menu=preferences]',\n    run: \"click\",\n}, {\n    content: \"Switch to security tab\",\n    trigger: 'a[role=tab]:contains(\"Security\")',\n    run: 'click',\n}, {\n    content: \"Open kanban dropdown menu of the key\",\n    trigger: '[name=api_key_ids] .o_kanban_record:contains(\"my key\") .oe_kanban_action[name=\"remove\"]',\n    run: 'click',\n}, {\n    content: \"Input password for security mode again\",\n    trigger: \".modal [name=password] input\",\n    run: \"edit test_user\",\n}, {\n    content: \"And confirm\",\n    trigger: \".modal button:contains(Confirm Password)\",\n    run: \"click\",\n},\n{\n    trigger: \"body:not(:has(.modal))\",\n},\n{\n    content: 'Re-open preferences again',\n    trigger: '.o_user_menu .dropdown-toggle',\n    run: \"click\",\n}, {\n    trigger: '[data-menu=preferences]',\n    run: \"click\",\n}, {\n    content: \"Switch to security tab\",\n    trigger: 'a[role=tab]:contains(\"Security\")',\n    run: 'click',\n}, {\n    content: \"Check that there's no more keys\",\n    trigger: \"body:not(:has(.o_notebook [name=api_key_ids]))\",\n}]});\n", "import { WORKER_STATE } from \"@bus/workers/websocket_worker\";\nimport { rpc } from \"@web/core/network/rpc\";\nimport { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\nimport { whenReady } from \"@odoo/owl\";\n\nfunction openRoot() {\n    return [{\n        content: \"return to client root to avoid race condition\",\n        trigger: 'body',\n        run() {\n            document.querySelector(\"body\").classList.add(\"wait\");\n            window.location = '/odoo';\n        },\n        expectUnloadPage: true,\n    }, {\n        content: \"wait for client reload\",\n        trigger: 'body:not(.wait)',\n    }];\n}\nfunction openUserPreferencesAtSecurityTab() {\n    return [{\n        content: 'Open user account menu',\n        trigger: '.o_user_menu .dropdown-toggle',\n        run: 'click',\n    }, {\n        content: \"Open My Preferences\",\n        trigger: '[data-menu=preferences]',\n        run: 'click',\n    }, {\n        content: \"wait for security tab\",\n        trigger: 'a[role=tab]:contains(\"Security\")',\n    }, {\n        content: \"Switch to security tab\",\n        trigger: 'a[role=tab]:contains(\"Security\")',\n        run: 'click',\n    }];\n}\n\n/**\n * Checks that the TOTP button is in the specified state (true = enabled =\n * can disable, false = disabled = can enable), then closes the preferences dialog\n * if it's one (= hr not installed).\n *\n * If no totp state is provided, just checks that the toggle exists.\n */\nfunction closePreferencesDialog({content, totp_state}) {\n    let trigger;\n    switch (totp_state) {\n    case true: trigger = 'button[name=action_totp_disable]'; break;\n    case false: trigger = 'button[name=action_totp_enable_wizard]'; break;\n    case undefined: trigger = 'div:contains(\"Two-factor Authentication\") + button'; break;\n    default: throw new Error(`Invalid totp state ${totp_state}`)\n    }\n\n    return [{\n        content,\n        trigger: 'a[role=tab]:contains(\"Security\").active',\n    }, \n    {\n        trigger,\n        async run(helpers) {\n            const modal = document.querySelector(\".o_dialog\");\n            if (modal) {\n                modal.querySelector(\"button[name=preference_cancel]\").click();\n            }\n        }\n    },\n    {\n        trigger: 'body:not(:has(.o_dialog))',\n    }];\n}\n\nregistry.category(\"web_tour.tours\").add('totp_tour_setup', {\n    url: '/odoo',\n    steps: () => [\n...openUserPreferencesAtSecurityTab(),\n{\n    content: \"Open totp wizard\",\n    trigger: 'a[role=tab]:contains(\"Security\").active',\n},\n{\n    trigger: \"button[name=action_totp_enable_wizard]\",\n    run: \"click\",\n},\n{\n    trigger: \".modal div:contains(Enter your current password)\",\n},\n{\n    content: \"Check that we have to enter enhanced security mode and input password\",\n    trigger: '[name=password] input',\n    run: 'edit test_user',\n}, {\n    content: \"Confirm\",\n    trigger: \"button:contains(Confirm Password)\",\n    run: \"click\",\n}, {\n    content: \"Check the wizard has opened\",\n    trigger: '.modal:contains(\"Two-Factor Authentication Activation\")',\n}, {\n    content: \"Get secret from collapsed div\",\n    trigger: `.modal a:contains(\"Cannot scan it?\")`,\n    async run(helpers) {\n        const secret = this.anchor\n            .closest(\"div\")\n            .querySelector(\"[name=secret] span:first-child\");\n        const copyBtn = secret.querySelector(\"button\");\n        if (copyBtn) {\n            copyBtn.remove();\n        }\n        const token = await rpc('/totphook', {\n            secret: secret.textContent,\n            offset: 0,\n        });\n        await helpers.edit(token, '[name=code] input');\n    }\n},\n{\n    trigger: \".modal button.btn-primary:contains(Enable Two-Factor Authentication)\",\n    run: \"click\",\n},\n{\n    trigger: \".o_notification_content:contains(2-Factor authentication is now enabled)\",\n},\n...openRoot(),\n...openUserPreferencesAtSecurityTab(),\n...closePreferencesDialog({\n    content: \"Check that the button has changed\",\n    totp_state: true,\n}),\n]});\n\nregistry.category(\"web_tour.tours\").add('totp_login_enabled', {\n    url: '/',\n    steps: () => [{\n    content: \"check that we're on the login page or go to it\",\n    isActive: [\"body:not(:has(input#login))\"],\n    trigger: \"a:contains(Sign in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"input login\",\n    trigger: 'input#login',\n    run: \"edit test_user\",\n}, {\n    content: 'input password',\n    trigger: 'input#password',\n    run: \"edit test_user\",\n}, {\n    content: \"click da button\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"expect totp screen\",\n    trigger: 'label:contains(Authentication Code)',\n    run: \"click\",\n}, {\n    content: \"input incorrect code\",\n    trigger: 'input[name=totp_token]',\n    async run(helpers) {\n        // set the offset in the past, so the token will be always wrong\n        await rpc(\"/totphook\", { offset: -2 });\n        helpers.edit(\"123456\");\n    }\n}, {\n    trigger: `button:contains(\"Log in\")`,\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"using an incorrect token should fail\",\n    trigger: \"p.alert.alert-danger:contains(Verification failed, please double-check the 6-digit code)\",\n}, {\n    content: \"reuse same code\",\n    trigger: 'input[name=totp_token]',\n    async run(helpers) {\n        // send the same token as the one last one from the setup tour\n        const token = await rpc(\"/totphook\", { offset: 0 });\n        helpers.edit(token);\n    }\n}, {\n    trigger: `button:contains(\"Log in\")`,\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"reusing the same token should fail\",\n    trigger: \"p.alert.alert-danger:contains(Verification failed, please use the latest 6-digit code)\",\n}, {\n    content: \"input code\",\n    trigger: 'input[name=totp_token]',\n    async run(helpers) {\n        const token = await rpc('/totphook', { offset: 1 });\n        helpers.edit(token);\n    }\n},\n{\n    trigger: `button:contains(\"Log in\")`,\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"check we're logged in\",\n    trigger: \".o_user_menu .dropdown-toggle\",\n}]});\n\nregistry.category(\"web_tour.tours\").add('totp_login_device', {\n    url: '/',\n    steps: () => [{\n    content: \"check that we're on the login page or go to it\",\n    isActive: [\"body:not(:has(input#login))\"],\n    trigger: \"a:contains(Sign in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"input login\",\n    trigger: 'input#login',\n    run: \"edit test_user\",\n}, {\n    content: 'input password',\n    trigger: 'input#password',\n    run: \"edit test_user\",\n}, {\n    content: \"click da button\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"expect totp screen\",\n    trigger: 'label:contains(Authentication Code)',\n    run: \"click\",\n}, {\n    content: \"check remember device box\",\n    trigger: 'label[for=switch-remember]',\n    run: \"click\",\n}, {\n    content: \"input code\",\n    trigger: 'input[name=totp_token]',\n    async run(helpers) {\n        const token = await rpc('/totphook', { offset: 2 });\n        helpers.edit(token);\n    }\n},\n{\n    trigger: \"button:contains(Log in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n},\n{\n    trigger: \".o_web_client .o_navbar\",\n    async run() {\n        await whenReady();\n    }\n},\n{\n    trigger: \".o_web_client .o_navbar\",\n    async run() {\n        await new Promise((resolve) => {\n            const bus = odoo.__WOWL_DEBUG__.root.env.services.bus_service;\n            bus.addEventListener(\"BUS:CONNECT\", resolve, { once: true });\n            if (bus.workerState === WORKER_STATE.CONNECTED) {\n                resolve();\n            }\n        });\n    },\n},\n{\n    content: \"check we're logged in\",\n    trigger: \".o_user_menu .dropdown-toggle\",\n    run: 'click',\n}, {\n    content: \"click the Log out button\",\n    trigger: '.dropdown-item[data-menu=logout]',\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"check that we're back on the login page or go to it\",\n    trigger: 'input#login, a:contains(Log in)',\n    run: \"edit Test\",\n}, {\n    content: \"input login again\",\n    trigger: 'input#login',\n    run: \"edit test_user\",\n}, {\n    content: 'input password again',\n    trigger: 'input#password',\n    run: \"edit test_user\",\n}, {\n    content: \"click da button again\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n},  {\n    content: \"check we're logged in without 2FA\",\n    trigger: \".o_user_menu .dropdown-toggle\",\n},\n// now go and disable two-factor authentication would be annoying to do in a separate tour\n// because we'd need to login & totp again as HttpCase.authenticate can't\n// succeed w/ totp enabled\n...openUserPreferencesAtSecurityTab(),\n{\n    content: \"Open totp wizard\",\n    trigger: 'a[role=tab]:contains(\"Security\").active',\n},\n{\n    trigger: \"button[name=action_totp_disable]\",\n    run: \"click\",\n},\n{\n    trigger: \".modal div:contains(Enter your current password)\",\n},\n{\n    content: \"Check that we have to enter enhanced security mode and input password\",\n    trigger: '.modal [name=password] input',\n    run: \"edit test_user\",\n}, {\n    content: \"Confirm\",\n    trigger: \".modal button:contains(Confirm Password)\",\n    run: \"click\",\n},\n{\n    trigger:\".o_notification_content:contains(Two-factor authentication disabled)\",\n},\n...openRoot(),\n...openUserPreferencesAtSecurityTab(),\n...closePreferencesDialog({\n    content: \"Check that the button has changed\",\n    totp_state: false\n}),\n]});\n\nregistry.category(\"web_tour.tours\").add('totp_login_disabled', {\n    url: '/',\n    steps: () => [{\n    content: \"check that we're on the login page or go to it\",\n    isActive: [\"body:not(:has(input#login))\"],\n    trigger: \"a:contains(Sign in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"input login\",\n    trigger: 'input#login',\n    run: \"edit test_user\",\n}, {\n    content: 'input password',\n    trigger: 'input#password',\n    run: \"edit test_user\",\n}, {\n    content: \"click da button\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n},\n// normally we'd end the tour here as it's all we care about but there are a\n// bunch of ongoing queries from the loading of the web client which cause\n// issues, so go and open the preferences screen to make sure\n// everything settles down\n...openUserPreferencesAtSecurityTab(),\n// close the dialog if that makes sense\n...closePreferencesDialog({})\n]});\n\nregistry.category(\"web_tour.tours\").add('totp_admin_disables', {\n    url: '/odoo',\n    steps: () => [stepUtils.showAppsMenuItem(), {\n    content: 'Go to settings',\n    trigger: '[data-menu-xmlid=\"base.menu_administration\"]',\n    run: \"click\",\n}, {\n    content: 'Wait for page',\n    trigger: '.o_menu_brand:contains(\"Settings\")',\n}, {\n    content: \"Open Users menu\",\n    trigger: '[data-menu-xmlid=\"base.menu_users\"]',\n    run: \"click\",\n}, {\n    content: \"Open Users view\",\n    trigger: '[data-menu-xmlid=\"base.menu_action_res_users\"]',\n    run: \"click\",\n}, {\n    content: \"Find test_user User\",\n    trigger: 'tr:has(td.o_data_cell:contains(\"test_user\")) ' +\n                '.o_list_record_selector input[type=checkbox]',\n    run: \"click\",\n}, {\n    content: \"Open Actions menu\",\n    trigger: 'button.dropdown-toggle:contains(\"Action\")',\n    run: \"click\",\n}, {\n    content: \"Select totp remover\",\n    trigger: 'span.dropdown-item:contains(Disable two-factor authentication)',\n    run: \"click\",\n},\n{\n    trigger: \".modal div:contains(Enter your current password)\",\n},\n{ // enhanced security yo\n    content: \"Check that we have to enter enhanced security mode & input password\",\n    trigger: '.modal [name=password] input',\n    run: \"edit admin\",\n}, {\n    content: \"Confirm\",\n    trigger: \".modal button:contains(Confirm Password)\",\n    run: \"click\",\n},\n{\n    content: \"Wait for user to be unchecked (~ action done)\",\n    trigger: 'tr:has(td.o_data_cell:contains(test_user)) ' +\n                '.o_list_record_selector input[type=checkbox]:not(:checked)',\n},\n{\n    content: \"open the user's form\",\n    trigger: \"td.o_data_cell:contains(test_user)\",\n    run: \"click\",\n}, {\n    content: \"wait for Security Tab to appear\",\n    trigger: \"a.nav-link:contains(Security)\",\n},{\n    content: \"go to Security Tab\",\n    trigger: \"a.nav-link:contains(Security)\",\n    run: \"click\",\n}, {\n    content: \"check 2FA button: should be disabled\",\n    trigger: 'body:not(:has(button[name=action_totp_enable_wizard]))',\n}\n]})\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nfunction openAccountSettingsTab() {\n    return [{\n        content: 'Go to settings',\n        trigger: '[data-menu-xmlid=\"base.menu_administration\"]',\n        run: \"click\",\n    }, {\n        content: 'Wait for page',\n        trigger: '.o_menu_brand:contains(\"Settings\")',\n    }, {\n        content: \"Open Users menu\",\n        trigger: '[data-menu-xmlid=\"base.menu_users\"]',\n        run: \"click\",\n    }, {\n        content: \"Open Users view\",\n        trigger: '[data-menu-xmlid=\"base.menu_action_res_users\"]',\n        run: function (helpers) {\n            // funny story: the users view we're trying to reach, sometimes we're\n            // already there, but if we re-click the next step executes before the\n            // action has the time to re-load, the one after that doesn't, and our\n            // selection get discarded by the action reloading, so here try to\n            // see if we're already on the users action through the breadcrumb and\n            // just close the menu if so\n            const breadcrumb = document.querySelector('.breadcrumb');\n            if (!breadcrumb || !breadcrumb.textContent.includes(\"Users\")) {\n                // on general settings page, click menu\n                helpers.click();\n            } else {\n                // else close menu\n                helpers.click('[data-menu-xmlid=\"base.menu_users\"]');\n            }\n        }\n    }];\n}\n\nregistry.category(\"web_tour.tours\").add('totp_admin_self_invite', {\n    url: '/odoo',\n    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {\n    content: \"open the user's form\",\n    trigger: \"td.o_data_cell:contains(admin)\",\n    run: \"click\",\n}, {\n    content: \"go to Security Tab\",\n    trigger: \"a.nav-link:contains(Security)\",\n    run: \"click\",\n}, {\n    content: \"check that user cannot invite themselves to use 2FA.\",\n    trigger: \"body:not(:has(button:contains(Invite to use 2FA)))\",\n}]});\n\nregistry.category(\"web_tour.tours\").add('totp_admin_invite', {\n    url: '/odoo',\n    steps: () => [stepUtils.showAppsMenuItem(), ...openAccountSettingsTab(), {\n    content: \"open the user's form\",\n    trigger: \"td.o_data_cell:contains(test_user)\",\n    run: \"click\",\n}, {\n    content: \"go to security Tab\",\n    trigger: \"a.nav-link:contains(Security)\",\n    run: \"click\",\n}, {\n    content: \"check that test_user user can be invited to use 2FA.\",\n    trigger: \"button:contains(Invite to use 2FA)\",\n}]});\n", "import { registry } from \"@web/core/registry\";\nimport { rpc } from \"@web/core/network/rpc\";\n\nregistry.category(\"web_tour.tours\").add('totportal_tour_setup', {\n    url: '/my/security',\n    steps: () => [{\n    content: \"Open totp wizard\",\n    trigger: 'button#auth_totp_portal_enable',\n    run: \"click\",\n}, {\n    content: \"Check that we have to enter enhanced security mode\",\n    trigger: \".modal div:contains(enter your password)\",\n}, {\n    content: \"Input password\",\n    trigger: '[name=password]',\n    run: \"edit portal\", // FIXME: better way to do this?\n}, {\n    content: \"Confirm\",\n    trigger: \"button:contains(Confirm Password)\",\n    run: \"click\",\n}, {\n    content: \"Check the wizard has opened\",\n    trigger: '.o_auth_totp_enable_2FA',\n}, {\n    content: \"Get secret from collapsed div\",\n    trigger: 'a:contains(\"Cannot scan it?\")',\n},\n{\n    trigger: `span[name=\"secret\"]:hidden`,\n    async run(helpers) {\n        const secret = this.anchor.textContent;\n        const token = await rpc(\"/totphook\", {\n            secret,\n            offset: 0,\n        });\n        await helpers.edit(token, 'input[name=\"code\"]');\n    }\n}, {\n    trigger: \"button.btn-primary:contains(Activate)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"Check that the button has changed\",\n    trigger: 'button:contains(Disable two-factor authentication)',\n}]});\n\nregistry.category(\"web_tour.tours\").add('totportal_login_enabled', {\n    url: '/',\n    steps: () => [{\n    content: \"check that we're on the login page or go to it\",\n    isActive: [\"body:not(:has(input#login))\"],\n    trigger: \"a:contains(Sign in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"input login\",\n    trigger: 'input#login',\n    run: \"edit portal\",\n}, {\n    content: 'input password',\n    trigger: 'input#password',\n    run: \"edit portal\",\n}, {\n    content: \"click da button\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"expect totp screen\",\n    trigger: 'label:contains(Authentication Code)',\n    run: \"click\",\n}, {\n    content: \"input code\",\n    trigger: 'input[name=totp_token]',\n    run: async function (helpers) {\n        const token = await rpc('/totphook', { offset: 1 });\n        await helpers.edit(token);\n    }\n}, {\n    trigger: \"button:contains(Log in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"check we're logged in\",\n    trigger: \"h3:contains(My account)\",\n}, {\n    content: \"go back to security\",\n    trigger: \"a:contains(Security)\",\n    run: \"click\",\n    expectUnloadPage: true,\n},{\n    content: \"Open totp wizard\",\n    trigger: 'button#auth_totp_portal_disable',\n    run: \"click\",\n}, {\n    content: \"Check that we have to enter enhanced security mode\",\n    trigger: \".modal div:contains(enter your password)\",\n}, {\n    content: \"Input password\",\n    trigger: '[name=password]',\n    run: \"edit portal\",\n}, {\n    content: \"Confirm\",\n    trigger: \"button:contains(Confirm Password)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"Check that the button has changed\",\n    trigger: 'button:contains(Enable two-factor authentication)',\n}]});\n\nregistry.category(\"web_tour.tours\").add('totportal_login_disabled', {\n    url: '/',\n    steps: () => [{\n    content: \"check that we're on the login page or go to it\",\n    isActive: [\"body:not(:has(input#login))\"],\n    trigger: \"a:contains(Sign in)\",\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"input login\",\n    trigger: 'input#login',\n    run: \"edit portal\",\n}, {\n    content: 'input password',\n    trigger: 'input#password',\n    run: \"edit portal\",\n}, {\n    content: \"click da button\",\n    trigger: 'button:contains(\"Log in\")',\n    run: \"click\",\n    expectUnloadPage: true,\n}, {\n    content: \"check we're logged in\",\n    trigger: \"h3:contains(My account)\",\n}]});\n", "import { registry } from \"@web/core/registry\";\nimport { stepUtils } from \"@web_tour/tour_utils\";\n\nregistry.category(\"web_tour.tours\").add('custom_content_kanban_like_tour', {\n    steps: () => [\n        {\n            trigger: \"ul.nav a:contains(Quote Builder)\",\n            run: \"click\",\n        },\n        {\n            trigger: \"label:contains(Header)\",\n            run: \"click\",\n        },\n        {\n            trigger: \"h5:contains(custom_1) ~ div textarea\",\n            break: true,\n            run: \"edit Test\",\n        },\n        ...stepUtils.saveForm(),\n        // TODO VCR: Finish this\n    ]\n});\n"], "file": "/web/assets/3b79898/web.assets_tests.js", "sourceRoot": "../../../"}